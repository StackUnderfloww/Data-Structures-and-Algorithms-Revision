File: kthSmallestBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    int count=0;
    public int kthSmallest(TreeNode root, int k) {
        return inorderHelper(root,k).val;
    }
    TreeNode inorderHelper(TreeNode root,int k){
        if(root==null) return null;
        TreeNode left=inorderHelper(root.left,k);
        if(left!=null) return left;
        count++;
        if(k==count) return root;
        return inorderHelper(root.right,k);    
    }
}

File: Validate BST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        TreeNode[] prev=new TreeNode[1];
        return helper(root,prev); 
    }

    boolean helper(TreeNode node,TreeNode[] prev){
        if(node==null) return true;
        if(!helper(node.left,prev)) return false;
        if(prev[0]!=null && node.val<=prev[0].val) return false;
        prev[0]=node;
        if(!helper(node.right,prev)) return false;
        return true;
    }
}


class Solution {
    Integer prev=null;
    public boolean isValidBST(TreeNode root) {
           if(root==null) return true;
           if(!isValidBST(root.left)) return false;
           if(prev!=null && prev>=root.val) return false;
           prev=root.val;
           if(!isValidBST(root.right)) return false;
           return true; 
            
    }    
}


File: SortedListToBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return helper(head);
    }
    
    TreeNode helper(ListNode node){
        if(node==null) return null;
        if(node.next==null) return new TreeNode(node.val);
        ListNode prev=findMiddle(node);
        ListNode middle=prev.next;
        prev.next=null;
        ListNode next=middle.next;
        middle.next=null;
        TreeNode root=new TreeNode(middle.val);
        root.left=helper(node);
        root.right=helper(next);
        return root;
    }
    
    ListNode findMiddle(ListNode node){
        ListNode f=node,s=node,prev=null;
        while(f!=null && f.next!=null){
            f=f.next.next;
            prev=s;
            s=s.next;
        }
        return prev;
    }
}


File: BSTtoGST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    int sum=0;
    public TreeNode bstToGst(TreeNode root) {
        DFS(root);
        return root;
    }
    
    void DFS(TreeNode root){
        if(root==null) return ;
        DFS(root.right);
        root.val=root.val+sum;
        sum=root.val;
        DFS(root.left);
    }
}

File: CloneABT.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class GfG{
    static Map<Integer,Tree> map=new HashMap<>();
    public static Tree cloneTree(Tree root){
        
       DFS(root);
       helper(root);
       return map.get(root.data);
     }
     
     static void DFS(Tree node){
         if(node==null) return;
         map.put(node.data,new Tree(node.data));
         helper(node.left);
         helper(node.right);
     }
     
     static void helper(Tree node){
         if(node==null) return ;
         helper(node.left);
         Tree curr=map.get(node.data);
         if(curr!=null){
             curr.random=node.random==null?null:map.get(node.random.data);
             curr.left=node.left==null?null:map.get(node.left.data);
             curr.right=node.right==null?null:map.get(node.right.data);             
         }
         helper(node.right);
     }
}

File: ListFromTwoBST_Inorder_Flatten.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*
Given two binary search trees(BST) root1 and root2.
Return a list containing all the integers from both trees sorted in ascending order.
*/
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        root1=flatten(root1);
        root2=flatten(root2);
        List<Integer> list=new LinkedList<>();
        while(root1!=null && root2!=null){
            if(root1.val>=root2.val){
                list.add(root2.val);
                root2=root2.right;
            }else{
                list.add(root1.val);
                root1=root1.right;                
            }
        }
        while(root1!=null){
                list.add(root1.val);
                root1=root1.right;
        }
        while(root2!=null){
                list.add(root2.val);
                root2=root2.right;
        }
        return list;
    }
    
    TreeNode dummy=null,prev;
    TreeNode flatten(TreeNode root){
       if(root==null) return null;
        dummy=new TreeNode(-1);
        prev=dummy;
        inorder(root);
        return dummy.right;
    }
    
    void inorder(TreeNode root){
       if(root==null) return; 
       inorder(root.left);
       prev.left=null;
       prev.right=root;
       prev=prev.right; 
       inorder(root.right);
    }
}

File: TwoSum.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*
Given two binary search trees, return True if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer target.
 */
class Solution {
    Boolean ans=false;
    public boolean twoSumBSTs(TreeNode root1, TreeNode root2, int target) {
        dfs(root1,root2,target);
        return ans;
    }
    void dfs(TreeNode root1, TreeNode root2,int target){
        if(root1==null || ans) return;
        dfs(root1.left,root2,target);
        BFSSearch(root2,target-root1.val);
        dfs(root1.right,root2,target);
    }
    
    void BFSSearch(TreeNode root2,int target){
        if(root2==null) return ;
        if(root2.val==target) {
            ans=true;
            return;
        }else if(target<root2.val){
            BFSSearch(root2.left,target);
        }else{
            BFSSearch(root2.right,target);
        }
    }
}

File: IncreasingBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    TreeNode curr;
    public TreeNode increasingBST(TreeNode root) {
        curr=new TreeNode();
        TreeNode dummy=curr;
        helper(root);
        return dummy.right;
    }
    
    void helper(TreeNode node){
        if(node==null) return ;
        helper(node.left);
        node.left=null;
        curr.right=node;
        curr=node;
        helper(node.right);        
    }
}

File: RangeSumBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    int sum=0;
    public int rangeSumBST(TreeNode root, int L, int R) {
        if(root==null) return 0;
        if(root.left!=null && root.val>=L)rangeSumBST(root.left,L,R);
        if(root.val>=L && root.val<=R) sum=sum+root.val;
        if(root.right!=null && root.val<=R)rangeSumBST(root.right,L,R);
        return sum;
    }
}

File: InvertTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode invertTree(TreeNode root) {//100
        if(root==null){
            return root;
        }
        return invert(root);
        
    }
    
    TreeNode invert(TreeNode node){
        if(node==null) return null;
        TreeNode left=invert(node.left);
        TreeNode right=invert(node.right);
        node.left=right;
        node.right=left;
        return node;
    }
}

class Solution {
    public TreeNode invertTree(TreeNode root) {//20
        helper(root);
        return root;
    }
    
    void helper(TreeNode root){
        if(root==null) return ;
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        helper(root.left);
        helper(root.right);
    }
}

File: BTMaximumPathSum.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes 
from some starting node to any node in the tree along the parent-child connections.
 The path must contain at least one node and does not need to go through the root.
 */
class Solution {
    int maxPathSum=Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
       helper(root);  
       return maxPathSum; 
    }
    
    int helper(TreeNode root){
        if(root==null) return 0;
        int left=helper(root.left);
        if(left<0){left=0;}
        int right=helper(root.right);
        if(right<0){right=0;}
        maxPathSum=Math.max(maxPathSum,root.val+left+right);
        return root.val+Math.max(left,right);
    }
        
}

class Solution {
    Integer result=Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return result;
    }
    
    int dfs(TreeNode node){
        if(node==null) return 0;
        int leftGain=Math.max(0,dfs(node.left));
        int rightGain=Math.max(0,dfs(node.right));
        result=Math.max(result,node.val+leftGain+rightGain);
        return node.val+Math.max(leftGain,rightGain);
    }
}


File: BoundaryOfBinaryTreeAnticlockwise.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.  (The values of the nodes may still be duplicates.)
Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn't have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.
The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.
The right-most node is also defined by the same way with left and right exchanged.
 */
class Solution {
    List<Integer> result=new ArrayList<>();
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        if(root==null) return result;
        result.add(root.val);
        addLeftBoundary(root.left);
        if(root.left!=null || root.right!=null){
            addLeaves(root);
        }
        addRightBoundary(root.right);
        return result;
    }
    
    void addRightBoundary(TreeNode root){
        if(root==null)return ;
        if(root.right!=null){
            addRightBoundary(root.right);
            result.add(root.val); 
        }else if(root.left!=null){
            addRightBoundary(root.left);
            result.add(root.val); 
        }     
    }
    
    void addLeftBoundary(TreeNode root){
        if(root==null)return ;
        if(root.left!=null){
            result.add(root.val);     
            addLeftBoundary(root.left);
        }else if(root.right!=null){
            result.add(root.val);     
            addLeftBoundary(root.right);
        }     
    }
    
    void addLeaves(TreeNode root){
        if(root==null)return ;
        addLeaves(root.left);
        if(root.left==null && root.right==null){
            result.add(root.val);
        }
        addLeaves(root.right);
    }
}

File: BinaryTreeAllTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
import java.util.Queue;
import java.util.LinkedList;
//		1
//	      2	  3
//         4  5   6  7
public class BinaryTreeAllTraversal{

	static void inOrderTraversal(BTNode root){
		if(root==null) return;
		inOrderTraversal(root.left);
		System.out.print(root.data+"--");
		inOrderTraversal(root.right);
	}
	
	static void preOrderTraversal(BTNode root){
		if(root==null) return;
		System.out.print(root.data+"--");
		inOrderTraversal(root.left);
		inOrderTraversal(root.right);
	}
	static void postOrderTraversal(BTNode root){
		if(root==null) return;
		inOrderTraversal(root.left);
		inOrderTraversal(root.right);
		System.out.print(root.data+"--");
	}

	static void levelOrderTraversal(BTNode root){
		Queue<BTNode> queue=new LinkedList<BTNode>();
		queue.offer(root);
		BTNode currentNode=null;
		while(!queue.isEmpty()){
			currentNode=queue.poll();
			System.out.print(currentNode.data+"--");
			if(currentNode.left!=null){
				queue.offer(currentNode.left);
			}
			if(currentNode.right!=null){
				queue.offer(currentNode.right);
			}
		}
	}

	public static void main(String args[]){
		BTNode root=new BTNode(1);
		root.left=new BTNode(2);
		root.right=new BTNode(3);
		root.left.left=new BTNode(4);
		root.left.right=new BTNode(5);
		root.right.left=new BTNode(6);
		root.right.right=new BTNode(7);

		//DFS traversals
		System.out.print("Inorder Traversal :-");inOrderTraversal(root);
		System.out.print("\nPreorder Traversal :-");preOrderTraversal(root);
		System.out.print("\nPostOrder Traversal :-");postOrderTraversal(root);
		//BFS traversals
		System.out.print("\nlevelOrder Traversal :-");levelOrderTraversal(root);
	}
}


File: NaryTreePreorderAndPostOrderTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    List<Integer> traverse=new ArrayList<>();
    public List<Integer> preorder(Node root) {
        helperPreorder(root);
        return traverse;
    }
    
    void helperPreorder(Node root){
        if(root==null) return;
        traverse.add(root.val);
        for(Node child:root.children){
            helperPreorder(child);
        }
    }
}

class Solution {
    List<Integer> traverse=new ArrayList<>();
    public List<Integer> postorder(Node root) {
        helperPostorder(root);
        return traverse;
    }
    
    void helperPostorder(Node root){
        if(root==null) return;
        for(Node child:root.children){
            helperPostorder(child);
        }
        traverse.add(root.val);
    }
}

File: isBalanceTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
public class isBalanceTree {

    static Boolean isBalanced = true;

    static boolean checkBalancedTree(Node root) {
        if (root == null)
            return true;
        postOrder(root);
        return isBalanced;
    }

    static int postOrder(Node root){
        if(isBalanced==false) return -1;
        if(root==null) return -1;
        int left=postOrder(root.left);
        int right=postOrder(root.right);
        if(Math.abs(left-right)>1){
            isBalanced=false;
        }
        return 1+Math.max(left,right);
    }
    public static void main(String[] args) {
        /* Constructed binary tree is 
                   1 
                 /   \ 
                2      3 
              /  \    / 
            4     5  6 
            / 
           7         */
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
       // root.right.right = new Node(6);
        root.left.left.left = new Node(7);

        System.out.println(checkBalancedTree(root));
    }
}

class Node {

    int data;
    Node left, right;

    Node(int d) {
        data = d;
        left = right = null;
    }
}


File: BTNode.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class BTNode{
	public int data;
	public BTNode left;
	public BTNode right;

	public BTNode(){
	}

	public BTNode(int data,	BTNode left,BTNode right){
		this.data=data;
		this.left=left;
		this.right=right;
	}

	public BTNode(int data){
		this.data=data;
	}
}

File: SerializeAndDeserializeBT.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory
 buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization
 algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized
 to the original tree structure.
 */
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null) return "";
        return helperS(root);
    }
    
    String helperS(TreeNode root){
        String s="";
        if(root==null){
            s=s+"null,";
        }else{
            s=s+root.val+",";
            s=s+helperS(root.left);
            s=s+helperS(root.right);
        }
        return s;
    }

    // Decodes your encoded data to tree.
    int i=0;
    public TreeNode deserialize(String data) {
        if(data.length()==0) return null;
        String [] arr=data.split(",");
        return helperD(arr);
    }
    
    TreeNode helperD(String[] arr){
        if(i==arr.length) return null;
        Integer val=Integer.parseInt(arr[i]);
        TreeNode root=new TreeNode(val);
        ++i;
        root.left=arr[i].equals("null")?null:helperD(arr);
        ++i;
        root.right=arr[i].equals("null")?null:helperD(arr);
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));

File: Mergetrees.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        return inorder(t1,t2);
    }
    
    TreeNode inorder(TreeNode t1,TreeNode t2){
        if(t1==null && t2==null) return null;
        if(t2==null) return t1;
        if(t1==null) return t2;
        t1.left=inorder(t1.left,t2.left);
        t1.right=inorder(t1.right,t2.right);
        t1.val=t1.val+t2.val;
        return t1;
    }
}

File: VerticalOrderTraversalOfTreeII.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*//987. Vertical Order Traversal of a Binary Tree
Given a binary tree, return the vertical order traversal of its nodes values.
For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).
Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).
If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.
Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.
*/
class Solution {
    int leftMostOrder=Integer.MAX_VALUE,rightMostOrder=Integer.MIN_VALUE;
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        List<List<Integer>> result=new LinkedList<>();
        if(root==null) return result;
        HashMap<Integer,List<Pair<Integer,Integer>>> map=new HashMap<>();
        helper(map,root,0,0);
        
        return getListFromMap(map,result);
    }
    
    List<List<Integer>> getListFromMap(HashMap<Integer,List<Pair<Integer,Integer>>> map,List<List<Integer>> result){
        for(int i=leftMostOrder;i<=rightMostOrder;++i){
            Collections.sort(map.get(i),new Comparator<Pair<Integer,Integer>>(){
                @Override
                public int compare(Pair<Integer,Integer> ob1,Pair<Integer,Integer> ob2){
                    if(ob1.getKey().equals(ob2.getKey())){
                        return ob1.getValue()-ob2.getValue();
                    }
                    return ob1.getKey()-ob2.getKey();
                }
            });
            List<Integer> sortedListByLevel=new LinkedList<>();
            for(Pair<Integer,Integer> p:map.get(i)){
                sortedListByLevel.add(p.getValue());
            }
            result.add(sortedListByLevel);
        }
        return result;
    }
    
    void helper(HashMap<Integer,List<Pair<Integer,Integer>>> map,TreeNode root,int order,int level){
        if(root==null) return;
        leftMostOrder=Math.min(leftMostOrder,order);
        rightMostOrder=Math.max(rightMostOrder,order);
        if(map.containsKey(order)){
            map.get(order).add(new Pair<Integer,Integer>(level,root.val));
        }else{
            LinkedList<Pair<Integer,Integer>> newList=new LinkedList<>();
            newList.add(new Pair<Integer,Integer>(level,root.val));
            map.put(order,newList);
        }
        helper(map,root.left,order-1,level+1);
        helper(map,root.right,order+1,level+1);
    }
}

File: ConstructBinaryTreeFromPreorderAndInorderTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    int preOrderIndex=0;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return helper(preorder,inorder,inorder.length);
    }
    
    TreeNode helper(int [] pre,int[] in,int len){
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<len;++i){
            map.put(in[i],i);
        }
        return buildTree(pre,0,len-1,map);
    }
    
    TreeNode buildTree(int [] pre,int inStartIndex,int inEndIndex,HashMap<Integer,Integer> map){
        if(preOrderIndex==pre.length) return null;
        if(inStartIndex>inEndIndex) return null;
        TreeNode root=new TreeNode(pre[preOrderIndex++]);
        root.left=buildTree(pre,inStartIndex,map.get(root.val)-1,map);
        root.right=buildTree(pre,map.get(root.val)+1,inEndIndex,map);
        return root;
    }
}

File: SumOfPathNumbers.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class SumOfPathNumbers {
    static int sum=0;
    public static int findSumOfPathNumbers(TreeNode root) {
      helper(root,0);
      return sum;
    }
  
    static void helper(TreeNode node,int bSum){
      if(node==null) return;
      bSum=bSum*10+node.val;
      if(node.left==null && node.right==null){
        sum=sum+bSum;
      }
      helper(node.left,bSum);
      helper(node.right,bSum);
    }

File: BinaryTreeRightSideView.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered
 from top to bottom.
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list=new LinkedList<>();
        if(root==null) return list;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            TreeNode curr=null;
            for(int i=0;i<size;++i){
                curr=q.poll();
                if(i==size-1){list.add(curr.val);}
                if(curr.left!=null){q.add(curr.left);}
                if(curr.right!=null){q.add(curr.right);}
            }
        }
        return list;
    }
}

File: BinaryTreeVerticalOrderTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*
Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
*/
class Solution { //61%
    Integer MIN_ORDER=Integer.MAX_VALUE,MAX_ORDER=Integer.MIN_VALUE;
    public List<List<Integer>> verticalOrder(TreeNode root) {
        Map<Integer,ArrayList<Pair<Integer,Integer>>> map=new HashMap<>();
        helper(map,root,0,0);
        List<List<Integer>> ans=new ArrayList<>();
        for(int key=MIN_ORDER;key<=MAX_ORDER;++key){
            Collections.sort(map.get(key),new Comparator<>(){
               public int compare(Pair<Integer,Integer> ob1,Pair<Integer,Integer> ob2){
                   return ob1.getKey()-ob2.getKey();
               } 
            });
            List<Integer> temp=new ArrayList<>();
            for(Pair<Integer,Integer> pair:map.get(key)){
                temp.add(pair.getValue());
            }
            ans.add(temp);
        }
        return ans;
    }
    
    void helper(Map<Integer,ArrayList<Pair<Integer,Integer>>> map,TreeNode root,int order,int level){
        if(root==null) return;
        ArrayList<Pair<Integer,Integer>> list=new ArrayList<>();
        if(map.containsKey(order)){
            list=map.get(order);
        }
        list.add(new Pair(level,root.val));
        map.put(order,list);
        MIN_ORDER=Math.min(MIN_ORDER,order);
        MAX_ORDER=Math.max(MAX_ORDER,order);
        helper(map,root.left,order-1,level+1);
        helper(map,root.right,order+1,level+1);
    }
}

class Solution { //5 %
    int leftMostOrder=Integer.MAX_VALUE,rightMostOrder=Integer.MIN_VALUE;
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> result=new LinkedList<>();
        if(root==null) return result;
        HashMap<Integer,List<Pair<Integer,Integer>>> map=new HashMap<>();
        helper(map,root,0,0);
        
        return getListFromMap(map,result);
    }
    
    List<List<Integer>> getListFromMap(HashMap<Integer,List<Pair<Integer,Integer>>> map,List<List<Integer>> result){
        for(int i=leftMostOrder;i<=rightMostOrder;++i){
            Collections.sort(map.get(i),new Comparator<Pair<Integer,Integer>>(){
                @Override
                public int compare(Pair<Integer,Integer> ob1,Pair<Integer,Integer> ob2){
                    return ob1.getKey()-ob2.getKey();
                }
            });
            List<Integer> sortedListByLevel=new LinkedList<>();
            for(Pair<Integer,Integer> p:map.get(i)){
                sortedListByLevel.add(p.getValue());
            }
            result.add(sortedListByLevel);
        }
        return result;
    }
    
    void helper(HashMap<Integer,List<Pair<Integer,Integer>>> map,TreeNode root,int order,int level){
        if(root==null) return;
        leftMostOrder=Math.min(leftMostOrder,order);
        rightMostOrder=Math.max(rightMostOrder,order);
        if(map.containsKey(order)){
            map.get(order).add(new Pair<Integer,Integer>(level,root.val));
        }else{
            LinkedList<Pair<Integer,Integer>> newList=new LinkedList<>();
            newList.add(new Pair<Integer,Integer>(level,root.val));
            map.put(order,newList);
        }
        helper(map,root.left,order-1,level+1);
        helper(map,root.right,order+1,level+1);
    }
}


File: SumPathExist.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
public static boolean hasPath(TreeNode root, int sum) {
    if(root==null && sum==0) return true;
    if(root==null) return false;
    if(hasPath(root.left,sum-root.val)) return true;
    if(hasPath(root.right,sum-root.val)) return true;
    return false;
  }

File: ConstructBinaryTreeFromPostorderAndInorderTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------

class Solution {
    Integer postOrderIndex=null;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        postOrderIndex=inorder.length-1;
        return helper(postorder,inorder,inorder.length);
    }
    
    TreeNode helper(int [] post,int[] in,int len){
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<len;++i){
            map.put(in[i],i);
        }
        return buildTree(post,0,len-1,map);
    }
    
    TreeNode buildTree(int [] post,int inStartIndex,int inEndIndex,HashMap<Integer,Integer> map){
        if(postOrderIndex==-1) return null;
        if(inStartIndex>inEndIndex) return null;
        TreeNode root=new TreeNode(post[postOrderIndex--]);
        if(inStartIndex==inEndIndex) return root;
        root.right=buildTree(post,map.get(root.val)+1,inEndIndex,map);
        root.left=buildTree(post,inStartIndex,map.get(root.val)-1,map);
       
        return root;
    }
}

File: LevelOrderDataInReverseOrderBottomToUp.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
import java.util.Queue;
import java.util.LinkedList;
import java.util.Stack;
//		1
//	      2	  3
//         4  5   6  7
public class LevelOrderDataInReverseOrderBottomToUp{
	static Stack<BTNode> stack=new Stack();
	static void levelOrderTraversal(BTNode root){
		Queue<BTNode> queue=new LinkedList<BTNode>();
		queue.offer(root);
		BTNode currentNode=null;
		while(!queue.isEmpty()){
			currentNode=queue.poll();
			stack.push(currentNode);
			if(currentNode.left!=null){
				queue.offer(currentNode.left);
			}
			if(currentNode.right!=null){
				queue.offer(currentNode.right);
			}
		}
		
		while(!stack.isEmpty()){
			System.out.println(""+stack.pop().data);
		}	
	}

	public static void main(String args[]){
		BTNode root=new BTNode(1);
		root.left=new BTNode(2);
		root.right=new BTNode(3);
		root.left.left=new BTNode(4);
		root.left.right=new BTNode(5);
		root.right.left=new BTNode(6);
		root.right.right=new BTNode(7);

		System.out.print("levelOrder Traversal in reverse order:-\n");levelOrderTraversal(root);
	}
}


File: isSymmetric.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return helper(root.left,root.right);
    }    
    
    boolean helper(TreeNode left,TreeNode right){
        if(left==null && right==null) return true;
        if(left==null || right==null) return false;
        if(left.val!=right.val) return false;
        if(!helper(left.left,right.right)) return false;
        if(!helper(left.right,right.left)) return false;    
        return true;
    }
 
}

class Solution {
    public boolean isSymmetric(TreeNode root) {
        return helper(root,root);
    }
    
    boolean helper(TreeNode root1,TreeNode root2){
        if(root1==null && root2==null) return true;
        if((root1==null && root2!=null)||(root2==null && root1!=null)) return false;
        if(root1.val!=root2.val) return false;
        if(!helper(root1.left,root2.right)) return false;
        if(!helper(root1.right,root2.left)) return false;
        return true;
    }
}

File: printAllPath.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
import java.util.Stack;

public class printAllPath {
	public static void main(String args[]) 
	{ 
		TNode root = new TNode(10); 
		root.left = new TNode(8); 
		root.right = new TNode(2); 
		root.left.left = new TNode(3); 
		root.left.right = new TNode(5); 
		root.right.left = new TNode(2); 
		
		printPaths(root); 
	}

    private static void printPaths(TNode root) {
        Stack<Integer> s=new Stack<>();
        inorder(root,s);
    }

    private static void inorder(TNode root, Stack<Integer> s) {
        if(root==null) return;
        s.push(root.data);
        inorder(root.left, s);
        if(root.left==null && root.right==null){
            printStack(s);
        }
        inorder(root.right, s);
        s.pop();
    }

    private static void printStack(Stack<Integer> s) {
        if(s.isEmpty()){
            System.out.println("");
            return;
        }
        int top=s.pop();
        System.out.print(top+" ");
        printStack(s);
        s.push(top);
    }
} 

 class TNode{
    int data;
    TNode left;
    TNode right;

    TNode(int data){
        this.data=data;
    }
}

File: diameterOfBinaryTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {//100%
    int ans=Integer.MIN_VALUE;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        depth(root);
        return ans;
    }  
    
    int depth(TreeNode root){
        if(root==null) return 0;
        int left=depth(root.left);
        int right=depth(root.right);
        ans=Math.max(ans,left+right);
        int depth=1+ Math.max(left,right);
        return depth;
    }
} 

class Solution { //Slow
    int ans=Integer.MIN_VALUE;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        helper(root);
        return ans;
    }  
    
    void helper(TreeNode root){
        if(root==null) return ;
        helper(root.left);
        ans=Math.max(ans,depth(root.left)+depth(root.right));
        helper(root.right);
    }
    
    int depth(TreeNode root){
        if(root==null) return 0;
        int depth=1+Math.max(depth(root.left),depth(root.right));
        return depth;
    }
}

class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        //return 0 if root have no child
        return Math.max(height(root.left)+height(root.right),Math.max(diameterOfBinaryTree(root.left),
                                          diameterOfBinaryTree(root.right)));
    }
    
    public int height(TreeNode root){
        if(root==null) return 0;
        return Math.max(height(root.left),height(root.right))+1;
    }  
}

File: FlattenBinaryTreeToSkewTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public void flatten(TreeNode root) {
        if(root==null) return ;
        TreeNode right=root.right;
        flatten(root.left);
        root.right=root.left;
        root.left=null;
        flatten(right);
        TreeNode temp=root;
        while(temp.right!=null){
            temp=temp.right;
        }
        temp.right=right;
    }
}

File: AllNodesDistanceKInBinaryTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*
We are given a binary tree (with root node root), a target node, and an integer value K.
Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.
*/
class Solution {
    HashMap<TreeNode,TreeNode> map=new HashMap<>();
    HashSet<TreeNode> visited=new HashSet<>();
    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
        List<Integer> result=new LinkedList<>();
        if(root==null) return result;
        inorder(root,null);
        Queue<TreeNode> queue=new LinkedList<>();
        visited.add(target);
        queue.add(target); int level=0;
        while(!queue.isEmpty()){
            int size=queue.size();
            if(level==K){
                for(int i=0;i<size;++i){
                    TreeNode curr=queue.poll();
                    result.add(curr.val);
                }
                 return result;
            }
            for(int i=0;i<size;++i){
                TreeNode curr=queue.poll();
                visited.add(curr);
                if(curr.left!=null && !visited.contains(curr.left)){queue.add(curr.left);}
                if(curr.right!=null && !visited.contains(curr.right)){queue.add(curr.right);}
                if(map.get(curr)!=null &&!visited.contains(map.get(curr))){queue.add(map.get(curr));}
            }
             ++level;
        }
        return result;
        
    }
    void inorder(TreeNode root,TreeNode prev){
        if(root==null) return ;
        if(prev!=null){
            map.put(root,prev);
        }
        inorder(root.left,root);
        inorder(root.right,root);
    }
}

File: LCABinaryTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
        if(root==p || root==q) return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left!=null && right!=null) return root;
        if(left!=null) return left;
        if(right!=null) return right;
        return null;
    }
}

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return root;
        if(root==p|| root==q) return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left!=null && right!=null) return root;
        if(left==null) return right;
        if(right==null) return left;
        return null;
    }
}

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return root;
        if(root==p|| root==q) return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left==null && right==null) return right;
        if(left!=null && right!=null) return root;
        if(left==null)return right; 
        else return left;  
    }

File: PopulateNextRightPointerInTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {//100 Intutuion Based
    public Node connect(Node root) {
        dfs(root,null);
        return root;
    }
    
    void dfs(Node root,Node par){
        if(root==null) return ;
        if(par!=null){
            if(par.right!=null && par.right!=root){
                root.next=par.right;
            }else if(par.next!=null){
                root.next=par.next.left;
            }
        }
        dfs(root.left,root);
        dfs(root.right,root);
    }
}

class Solution { //100
    public Node connect(Node root) {
        Node left=root;
        while(left!=null && left.left!=null){
            connectPointerLevelWise(left);
            left=left.left;
        }
        return root;
    }
    
    void connectPointerLevelWise(Node node){
        Node itr=node;
        while(itr!=null){
            itr.left.next=itr.right;
            if(itr.next!=null){
                itr.right.next=itr.next.left;
            }
            itr=itr.next;
        }
    }
}

class Solution {
    public Node connect(Node root) {
        if(root==null) return null;
        Queue<Node> q=new LinkedList<Node>();
        q.add(root);
        Node curr=null;
        while(!q.isEmpty()){
            int n=q.size();
            for(int i=0;i<n;++i){
            Node prev=curr;    
            curr=q.poll();
            if(i>0){  //to skip first element of for loop from setting as next of last element of previous loop.
                prev.next=curr;                
            }    
            if(curr.left!=null) q.add(curr.left);
            if(curr.right!=null) q.add(curr.right);  
            }
          
        }
        return root;
    }
}

class Solution { //45
  public Node connect(Node root) {
      if(root==null) return root;
      helper(root.left,root.right);
      return root;
  }
    
  void helper(Node left,Node right){
      if(left==null) return;
      left.next=right;
      helper(left.right,right.left);
      connect(left);
      connect(right);
  }

}

class Solution { //55
    public Node connect(Node root) {
        if(root==null) return null;
        Queue<Node> q=new LinkedList<Node>();
        q.add(root);
        Node curr=null;
        while(!q.isEmpty()){
            int n=q.size();
            for(int i=0;i<n;++i){
            Node prev=curr;    
            curr=q.poll();
            if(i>0){  //to skip first element of for loop from setting as next of last element of previous loop.
                prev.next=curr;                
            }    
            if(curr.left!=null) q.add(curr.left);
            if(curr.right!=null) q.add(curr.right);  
            }
          
        }
        return root;
    }
}


File: IsUnivaluedTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    Integer val=null;
    public boolean isUnivalTree(TreeNode root) {
        return inorder(root);
    }
    
    boolean inorder(TreeNode root){
        if(root==null) return true;
        if(!inorder(root.left)) return false;
        if(!inorder(root.right)) return false;
        if(val==null){
            val=root.val;
        }
        return val==root.val;
    }
}

File: MinDepthOfBinaryTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        if(root.left==null) return 1+minDepth(root.right);
        if(root.right==null) return 1+minDepth(root.left);
        return 1+ Math.min(minDepth(root.left),minDepth(root.right));
    }
}

File: FindAllTreePath.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class FindAllTreePaths {
    static List<List<Integer>> allPaths = new ArrayList<>();
    public static List<List<Integer>> findPaths(TreeNode root, int sum) {
      
      helper(root,sum,new LinkedList());
      return allPaths;
    }
  
    static void helper(TreeNode node,int sum,LinkedList<Integer> list){
      if(node==null){
        return;
      }
      if(node.val==sum){
        list.add(node.val);
        allPaths.add(new ArrayList<>(list));
        list.remove(list.size()-1);
        return;
      }
      list.add(node.val);
      helper(node.left,sum-node.val,list);
      helper(node.right,sum-node.val,list);
      list.remove(list.size()-1);
    }

File: PathWithGivenSequence.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class PathWithGivenSequence {
    public static boolean findPath(TreeNode root, int[] sequence) {
      return helper(root,0,sequence);
    }
  
    static boolean helper(TreeNode root, int index, int[] arr){
      if(root==null) return false;
      if(root.val!=arr[index]) return false;
      if(index==arr.length-1) return true;
      if(helper(root.left,index+1,arr)) return true;
      if(helper(root.right,index+1,arr)) return true;
      return false;
    }

File: BinaryTreeHeight.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
import java.lang.Math;

//		1
//	      2	  3
//         4  5   6  7
public class BinaryTreeHeight{

static int getHeightOfTree(BTNode root){
	if(root==null) return 0;
	return (1+Math.max(getHeightOfTree(root.left),getHeightOfTree(root.right)));	
}

public static void main(String args[]){
	BTNode root=new BTNode(1);
	root.left=new BTNode(2);
	root.right=new BTNode(3);
	root.left.left=new BTNode(4);
	root.left.right=new BTNode(5);
	root.right.left=new BTNode(6);
	root.right.right=new BTNode(7);

	System.out.println("height of the tree is :--  "+getHeightOfTree(root));
}

}

class Solution {
    int maxDepth=Integer.MIN_VALUE;
    public int maxDepth(TreeNode root) {
        if (root==null) return 0;
        DFS(root,1);
        return maxDepth;
    }
    
    void DFS(TreeNode node,int depth){
        if(node == null) return ;
        maxDepth=Math.max(maxDepth,depth);
        DFS(node.left,depth+1);
        DFS(node.right,depth+1);
    }
}

File: ZigZagLevel.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        if(root==null) return ans;
        Stack<TreeNode> s1=new Stack<>();
        Stack<TreeNode> s2=new Stack<>();
        s1.push(root);
        while(!s1.isEmpty() || !s2.isEmpty()){
            Stack<TreeNode> curr=!s1.isEmpty()?s1:s2;
            boolean leftToRight=!s1.isEmpty();
            Stack<TreeNode> currEmpty=s1.isEmpty()?s1:s2;
            int size=curr.size();
            List<Integer> list=new ArrayList<>();
            for(int i=0;i<size;++i){
                TreeNode currNode=curr.pop();
                list.add(currNode.val);
                if(leftToRight){
                    if(currNode.left!=null) currEmpty.push(currNode.left);
                    if(currNode.right!=null) currEmpty.push(currNode.right);
                }else{
                    if(currNode.right!=null) currEmpty.push(currNode.right);  
                    if(currNode.left!=null) currEmpty.push(currNode.left);
                }

            }
            ans.add(list);
        }
        return ans;
    }
}

class ZigZagLevel{
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result=new LinkedList<>();
        if(root ==null) return result;
        Stack<TreeNode> LtR = new Stack<>();
        Stack<TreeNode> RtL = new Stack<>();
        LtR.push(root);
        Boolean leftToRight=true;
        TreeNode curr=null;
        while(!LtR.isEmpty() || !RtL.isEmpty()){
            if(leftToRight){
               LinkedList<Integer> level=new LinkedList<>();
               while(!LtR.isEmpty()){
                  curr= LtR.pop();
                  if(curr!=null){
                      level.add(curr.val);
                      if(curr.left!=null) RtL.add(curr.left);
                      if(curr.right!=null) RtL.add(curr.right); 
                  } 
               }     
               result.add(level); 
            }else{
                LinkedList<Integer> level=new LinkedList<>();
                while(!RtL.isEmpty()){
                  curr= RtL.pop();
                  if(curr!=null){
                      level.add(curr.val);
                      if(curr.right!=null) LtR.add(curr.right);
                      if(curr.left!=null) LtR.add(curr.left); 
                  }    
               }
                result.add(level);
            }
            leftToRight=!leftToRight;
        }
        return result;
    }
}

File: lowestCommonAncestorBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
        if(root.val>p.val && root.val>q.val) return lowestCommonAncestor(root.left,p,q);
        if(root.val<p.val && root.val<q.val) return lowestCommonAncestor(root.right,p,q);
        return root;
    }
    
}

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return root;
        if(p.val<root.val && q.val<root.val){
          return lowestCommonAncestor(root.left,p,q);  
        }
        if(p.val>root.val && q.val>root.val){
          return lowestCommonAncestor(root.right,p,q);  
        }
        return root;
    }
}

File: CheatBook.txt
Question Type: Data-Structures-and-Algorithms-II
DSA Question: DSA problem related to: CheatBook
----------------------
1)Greedy -  JumpGame(M,goodPosition),
            meetingRoom(SortArray,pQ),
            mergeIntervals(sortArray,PQ),
            bestTimeToBuyAndSellStock(minStock,and maxProfit),
            Most Common Word(forLoop,split by space or check for empty spaces,HashMap),
            ContainerWithMostWater(most Distance,Contract the lowest one,Two Pointer),
            TrappingRainWater(2 array)
2)DP- JumpGame(M,forLoop),
      maximumSubarray(S[i]=max(S[i-1]+arr[i],arr[i]))
      WordBreak(slidingWindow wont work,recursion+for Loop to check all posibility,memo to reduce time complexity)
      CoinChange(recursion+forLoop,maximum value is amount+1,memo),
      MinpathSum(DP)
      ClimbingStairs(DP no recursion solution),
      UniquePaths(DP solution),
      Edit Distance(DP Math.min 3 times)
      fact(n)=n*fact(n-1); (n=0 || n=1)->1
      fibonaci(n)=fibonaci(n-1)+fibonaci(n-2); 
      LCS(char[] arr1,char[] arr2,arr1.length-1,arr2.length-1)=
                          arr1[i1]==arr[i2] -->1+LCS(arr1,arr2,i1-1,i2-1);
                          else
                          Max(LCS(arr1,arr2,i1-1,i2),LCS(arr1,arr2,i1,i2-1));                            
      Maximum continuous Sub Array - MCS(int [] arr,arr.length-1) = max(arr[i],MCS(arr,i-1));
      Longest Increasing SubArray  - Max(LIS[])  -> where -> LIS[i]=1+max(LIS[j]) where  (0>=j<i)
      Coin Change ------------------ minCoinChange(int [] coins,amount) ->
                                                        for(j=0->coins.length){
                                                        result[amount] = Math.min( result[amount] , minCoinChange( coins,amount-coins[j])
                                                        }	
                                                //here we are repeating this for different amount leift
      KnapSAck --------------------- take one item or not - total two decisions required
                                                //here we are repeating for different weight left
                                                //also we are pickig one item only once
6)SubString - longestPalindromincSubString(each index as center,func(index,index),func(index,index))
              Find All Anagrams in a String(backtracking)
              longestPalindromicSubSequence(i+1,j-1)
              longestCommonSubSequence(0 if i or j grater than length,1+lcs(i+1,j+1),max(lcs(i+1,j),lcs(i,j+1)))
              longestIncreasingSubSequence(LIS[i]=Math.max(1+LIS[j])  , 0<=j<i)
              longestConsecutiveSequence(************)
              longestNonRepeatingSubString(********)
              longestProductInArray(***********)
3)Permutation/Combination-letterCombinationsOfPhoneLetter(forLoop,order maintained),
                          Permutations(forLoop,OrderNeed to be changed,swap)
                          GenerateParenthesis(forLoop)
4)String - removeAllAdjacentDuplicates(E,StringBuilder),
           ReverseString(Two Pointer) ,
           FirstUniqueCharaterInAString(2 for loop) ,
           ATOI('0' && '9' numbers between these character including these two)
           Implement strStr() KMP(*******)
           Reverse String(two pointer)
           Reverse Words in a String(two pointer)
5)SlidingWindow- longestSubStringWithoutRepeatingCharacter(HashMap) ,
                 MinimumWindowSubString(HashMap,patCount,dict),
                 SlidingWindowMax(***********)
7)Tree- BTMaximumPathSum(DFS),
        SerializeAndDeserializeBT(DFS),
        Diameter(Depth modified,global variable),
        LCA(left and right not null return node),
        SpiralTrraverse(2 Stack),
        SymetricTree(DFS,left,right pass as arguments),
        validateBST(inOrder),
        BTRightSideVeiw(LevelOrderTraversal),
        DepthOfBT(max of left ,right),
        ConstructBTFromPreOrderInOrderTraversal(map of inorder values and index, global variable for preorder, range of l and h for inorder , return null l>h and preorderVariable==n)
        Flatten Binary Tree to Linked List(Inorder Traversal)
        Convert Sorted List to Binary Search Tree(middle of linked list,newnode=midle.data and  middle.next=null;)
        Construct Binary Tree from Inorder and Postorder Traversal(Same as preOrder and inorder, just start from right side)
        Kth Smallest Element in a BST(counter inorder traversal)
        Populating Next Right Pointers in Each Node(Intutive Approach, left pointer, using previously set next pointer)
        Range Sum of BST(Inorder traversal)
        All Elements in Two Binary Search Trees(flatten two tree and merge two linkd list)
        Invert Binary Tree(Inorder Traversal temp variable swap)
        Binary Tree Vertical Order Traversal(order,level,pre order traversal,map of int,Pair getKey getValue new Pair)
        All Nodes Distance K in Binary Tree(Level Order Traversal, covert tree into graph)
        Boundary of Binary Tree(add left,leaves,right boundary seperately)
        Two Sum BSTs(inorder traversal, BST search)
        Binary Search Tree to Greater Sum Tree(right to left reverse of inorder)
8)Heap- medianFromStreamOfData(minHeap,MaxHeap),
        mergeKSortedList(pq),
        MergeSortedArray(pq,Custom Class)
9)Stack-minStack(2 stack,linkedList) ,
        VaildParenthesis(Stack,hashMap),
        LargestRectangleInHistogram(**************),
        Span(*************)
10)List-addTwoNumber(while Loop),
        ReverseNodeInKGroup(ReverSe Function with limit K,calculate total element first,dummy),
        CloneWithRandomPointer(HashMap or changeStructureoFOriginal List),
        reverseLinkedList(prev) ,
        middleOfALinkedList(2 pointer),
        RemoveNthNodeFromEndOfList(2Pointer),
        Intersection of Two Linked Lists(two pointer)
        Sort List(find middle,get single entity,merge them in order)
        Linked List Cycle(two pointer)
11)Design-     lRU(Map,doublyLinkedList),
               InsertDeleteGetRandomO1Time(Map,LinkedList),
               Design HashMap(*******)
               Design HashSet(******)
12)selection - MedianOfTwoSortedArray(Binary Searching,Ypos=(X+Y+1)/2-XPos,XPosmin,XPosmax,YPosmin,YPosmax),
               TopKFrequentElement(HashMap,partiton method),
               KthLargestElement(partition)  
               KClosestPointsToOrigin
               KthLargestElementInAStreamOfData(partiition,MINHeap)
13)Searching - modifiedBinarySearch(search is sorted parst first)
               kadane(********)
14)Array-TwoSum(HashMap or Sort),
         ThreeSum(TwoSum),
         FloodFill(2 array),
         ProductOfArrayAcceptSelf(2 array left and right),
         RemoveDuplicatesFromSortedArray(index++ if not equal to prev)
         Find First and Last Position of Element in Sorted Array(2 variable approach)
         Maximum Product of Two Elements in an Array(2 variable )
         Move Zeroes(count number of zeroes)
15)Hashing-GroupAnagram
16)Matrix- numberOfIslands(DFS,visitedFirstTimeCount),
           WordSearch(DFS,reach index n-1 of pattern to search),
           FloodFill(DFS),
           MaxAreaOfIsland,
           Rotting Orange,
           GameOfLife,
           MinimumPathSum(DP),
           RotateMatrix(transponse and suffle columns),
           SearchAMatrix(binary search)
           Set Matrix Zeroes(if arr[i][j]==0  arr[i][0]=0  arr[0][j]=0 trick)
           Surrounded Regions(start from end with 0)
17)Math-CountPrimes(visited,multiplication) ,
        FirstMissingNumber(n)(n+1)/2),
        ReverseInteger(/10 %10 until 0),
        SquareRoot(binary Search),
        FirstMissingPositiveNumber(negate by index,range is limited),
        FindDuplicateElement(negate by index,range is limited)
19)BitManupilation - BinaryNumberToDcimalNumber(s^index)
20)Graph- Course Schedule(*******)
          Find the Town Judge(*********)
          Critical Connections in a Network(*******)
          Graph Valid Tree(**********)
21)Trie- **********
22)Divide and Concur *********
23)Greedy Algo ********
24)System Design Questions

*********** Pending Cheats


File: LRUCache.txt
Question Type: Design
DSA Question: DSA problem related to: LRUCache
----------------------
public class Node{
    int val;
    int key;
    Node next;
    Node prev;
    
    Node(){
        
    }
    
    Node(int val,int key){
        this.val=val;
        this.key=key;
    }
}
class LRUCache {
    int capacity;
    Map<Integer,Node> map=new HashMap<>();
    Node head;
    Node tail;
    int size;
    public LRUCache(int capacity) {
        this.capacity=capacity;
            head=new Node();
            tail=new Node();
            head.next=tail;
            tail.prev=head;
            size=0;
    }
    
    public int get(int key) {
        if(!map.containsKey(key)) return -1;
        int toReturn=this.map.get(key).val;
        deleteNode(this.map.get(key));
        addNodeToHead(map.get(key));
        return toReturn;
    }
    
      void addNodeToHead(Node node){
        node.prev=head;
        node.next=head.next;
        node.next.prev=node;
        head.next=node;
    }
    
    void deleteNode(Node node){
        Node prev = node.prev;
        Node next = node.next;
        prev.next = next;
        next.prev = prev;
    }
    
    public void put(int key, int value) {
        Node node=new Node(value,key);
        if(map.containsKey(key)){
             deleteNode(map.get(key));
             --size;
        }
        ++size;
        addNodeToHead(node);
        map.put(key,node);
        if(size>capacity && size!=0){
            Node toRemove=tail.prev;
            deleteNode(toRemove);
            map.remove(toRemove.key);
            --size;
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */


File: DesignHashMap.txt
Question Type: Design
DSA Question: DSA problem related to: DesignHashMap
----------------------
/*
Design a HashMap without using any built-in hash table libraries.

To be specific, your design should include these functions:

put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.
get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.
*/
class MyPair<T,Y>{
    public T key;
    public Y value;
    
    public MyPair(){
        
    }
    
    public MyPair(T key,Y value){
        this.key=key;
        this.value=value;
    }
    
    @Override
    public String toString(){
        return "key: "+key+" Value: "+value;  
    } 
}
class MyHashMap {
    int CAPACITY;
    List<MyPair<Integer,Integer>>[] hashTable;
    public MyHashMap() {
        CAPACITY=2069;
        hashTable = new LinkedList[CAPACITY];
        for (int i = 0; i < this.CAPACITY; ++i) {
            this.hashTable[i]=new LinkedList<>();
        }
    }
    
    int getHash(int key){
       return key%CAPACITY; 
    }
    
    public void put(int key, int value) {
        int hashKey= getHash(key);
            boolean found=false;
            for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
                if(bucket.key==key){
                    hashTable[hashKey].remove(bucket);
                    break;
                 }
            }
            MyPair<Integer,Integer> newPair=new MyPair<>(key,value);
            hashTable[hashKey].add(newPair); 
    }
    
    public int get(int key) {
        int hashKey= getHash(key);
        if(null==hashTable[hashKey]){
            return -1;
        }
        for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
            if(bucket.key==key){
                return bucket.value;
            }
        }
        return -1;
    }
    
    public void remove(int key) {
        int hashKey= getHash(key);
        if(null==hashTable[hashKey]){
            return;
        }
        for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
            if(bucket.key==key){
                hashTable[hashKey].remove(bucket); break;
            }
        }
    }
}



File: FindMedianFromStream.txt
Question Type: Design
DSA Question: DSA problem related to: FindMedianFromStream
----------------------
class MedianFinder {
    PriorityQueue<Integer> minPq=new PriorityQueue<>();
    PriorityQueue<Integer> maxPq=new PriorityQueue<>(new Comparator<Integer>(){
        public int compare(Integer a,Integer b){
            return b-a;
        }
    });
    public MedianFinder() {
        
    }
    
    public void addNum(int num) {
        if(maxPq.isEmpty()){
            maxPq.add(num);
        }
        else if(maxPq.size()==minPq.size()){
            if(minPq.peek()<num){
                maxPq.add(minPq.poll());
                minPq.add(num);
            }else{
                maxPq.add(num);
            }
        }else{
            if( maxPq.peek()>num){
                minPq.add(maxPq.poll());
                maxPq.add(num);
            }else{
                minPq.add(num);
            }
        }
    }
    
    public double findMedian() {
        if(maxPq.size()==minPq.size()){
            return ((double)minPq.peek()+(double)maxPq.peek())/2;
        }else{
            return (double)maxPq.peek();
        }
    }

}


File: LRUCacheUsingDoublyLinkedListHashMap.txt
Question Type: Design
DSA Question: DSA problem related to: LRUCacheUsingDoublyLinkedListHashMap
----------------------

class LRUCache {
    class Node{
        Node next;
        Node prev;
        int key;
        int val;
        
        public Node(){         
        }
        public Node(int key,int value){
            this.key=key; this.val=value;
        }
    }
    Node head ;
    Node tail ;
    HashMap<Integer,Node> map;
    
    int capacity=0;
    
    int size;
    public LRUCache(int capacity) {
        this.capacity=capacity;
        this.map=new HashMap<>();
        this.size=0;
        head=new Node();tail=new Node();
        tail.prev=head; head.next=tail;
    }
    
    void deleteNode(Node node){
    Node prev = node.prev;
    Node next = node.next;

    prev.next = next;
    next.prev = prev;
        
    }
    
    void addNodeToHead(Node node){
        node.prev=head;
        node.next=head.next;
        node.next.prev=node;
        head.next=node;
    }
    
    public int get(int key) {
        Node fetchedNode= map.get(key);
        if(fetchedNode==null) return -1;
        deleteNode(fetchedNode);
        addNodeToHead(fetchedNode);
        return fetchedNode.val;
    }
    
    public void put(int key, int value) {
        Node node = map.get(key);
        if(node==null){
            Node newNode=new Node(key,value);
            map.put(key,newNode);
            addNodeToHead(newNode);
            ++size;
            if(size>capacity){Node toDelete=tail.prev;deleteNode(toDelete); map.remove(toDelete.key);--size;}
        }else{
            node.val=value;
            deleteNode(node);
            addNodeToHead(node);
        }
    }
}


File: MinStack.txt
Question Type: Design
DSA Question: DSA problem related to: MinStack
----------------------
class MinStack {

    /** initialize your data structure here. */
    Stack<Integer> stack=new Stack<>();
    Stack<Integer> minStack=new Stack<>();
    
    public MinStack() {
        stack.push(Integer.MAX_VALUE);
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        stack.push(x);
        if(stack.peek()!= Integer.MAX_VALUE && stack.peek()<=x){
            minStack.push(stack.peek());
        }else{
            minStack.push(x);
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */


File: SerializeAndDeserialize.txt
Question Type: Design
DSA Question: DSA problem related to: SerializeAndDeserialize
----------------------
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null ) return "";
        StringBuilder sb=new StringBuilder();
        helper(sb,root);
        return sb.toString().trim();
    }
    
    void helper(StringBuilder sb,TreeNode root){
        if(root==null){
            sb.append("null ");
            return;
        }
        sb.append(root.val+" ");
        helper(sb,root.left);
        helper(sb,root.right);
    }
    
    

    // Decodes your encoded data to tree.
    //1 2 null null 3 4 null null 5 null null
    int i=-1;
    public TreeNode deserialize(String data) {
        if(data.length()==0) return null;
        String[] dataS=data.split(" ");
        for(String str:dataS){
            System.out.print(str+" ");    
        }
        TreeNode head=null;
        head=helperC(head,dataS);
        return head;
    }
    
    TreeNode helperC(TreeNode head,String[] dataS){
        ++i;
        if(i==dataS.length) return null;
        if(dataS[i].equals("null")){
            head=null;
            return null;
        }else{
            head=new TreeNode(Integer.parseInt(dataS[i]));
        }
        head.left=helperC(head.left,dataS);
        head.right=helperC(head.right,dataS);
        return head;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));


File: MyHashSet.txt
Question Type: Design
DSA Question: DSA problem related to: MyHashSet
----------------------
class MyHashSet {

    int CAPACITY;
    
    List<Integer>[] hashTable;
    
    public MyHashSet() {
        CAPACITY=2069;
        hashTable = new LinkedList[CAPACITY];
        for (int i = 0; i < this.CAPACITY; ++i) {
            this.hashTable[i]=new LinkedList<>();
        }
    }
    
    int getHash(int key){
       return key%CAPACITY; 
    }
    
    public void add(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                hashTable[hashKey].remove(bucket);
                break;
             }
        }
        hashTable[hashKey].add(key); 
    }
    
    public void remove(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                hashTable[hashKey].remove(bucket); break;
            }
        }  
    }
    
    public boolean contains(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                return true;
            }
        }
        return false;
    }
}


File: InsertDeleteGetRandom.txt
Question Type: Design
DSA Question: DSA problem related to: InsertDeleteGetRandom
----------------------
/*
Design a data structure that supports all following operations in average O(1) time.

insert(val): Inserts an item val to the set if not already present.
remove(val): Removes an item val from the set if present.
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
*/
class RandomizedSet {
    HashMap<Integer,Integer> map;
    List<Integer> list;
    Random rad;
    /** Initialize your data structure here. */
    public RandomizedSet() {
        map=new HashMap<>();
        list=new LinkedList<>();
        rad=new Random();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(map.containsKey(val)) return false;
        map.put(val,list.size());
        list.add(list.size(),val);
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if(!map.containsKey(val)) return false;
        int lastElement=list.get(list.size()-1);
        int pos=map.get(val);
        map.put(lastElement,pos);
        list.set(pos,lastElement);
        map.remove(val);
        list.remove(list.size()-1);
        return true;
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        return list.get(rad.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */

File: LRUCacheUsingLinkedHashMap.txt
Question Type: Design
DSA Question: DSA problem related to: LRUCacheUsingLinkedHashMap
----------------------
/*
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

The cache is initialized with a positive capacity.

Follow up:
Could you do both operations in O(1) time complexity?
*/
class LRUCache {
    LinkedHashMap<Integer,Integer> map;
    public LRUCache(int capacity) {
        map=new LinkedHashMap<>(capacity, 0.75F, true){
                protected boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest) {
                return size() > capacity;
            }
        };
    }
    
    public int get(int key) {
        return map.getOrDefault(key,-1);
    }
    
    public void put(int key, int value) {
        map.put(key,value);
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

File: RemoveAllAdjacentDuplicatesInString.txt
Question Type: Strings
DSA Question: DSA problem related to: RemoveAllAdjacentDuplicatesInString
----------------------
/*
Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.

We repeatedly make duplicate removals on S until we no longer can.

Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.
*/
class Solution {
    public String removeDuplicates(String s) {
        StringBuilder sb=new StringBuilder();
        for(char character:s.toCharArray()){
            if(sb.length()!=0 && character==sb.charAt(sb.length()-1)){
                sb.deleteCharAt(sb.length()-1);
            }else{
                sb.append(character);
            }
        }
        return sb.toString();
    }
}

class Solution {
    public String removeDuplicates(String s) {
        StringBuilder sb=new StringBuilder();
        int index=-1,i=0;
        while(i<s.length()){
            if(index!=-1 && s.charAt(i)==sb.charAt(index)){
                sb.deleteCharAt(index);
                --index;
            }else{
                sb.append(s.charAt(i));
                ++index;
            }
            ++i;
        }
        return sb.toString();
    }
}

class Solution {
    public String removeDuplicates(String S) {
         char [] chars=S.toCharArray();
         for(int i=1;i<chars.length;++i){
             int prevIndexToCheck=getPrevIndex(chars,i);
             if(chars[prevIndexToCheck]==chars[i]){
                 chars[prevIndexToCheck]=chars[i]='#';
             }
         }
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<chars.length;++i){
            if(chars[i]!='#'){
                sb.append(chars[i]);
            }
        }
        return sb.toString();
    }
    
    int getPrevIndex(char[] chars,int currIndex){
        int i=currIndex-1;
        while(i>=0 && chars[i]=='#'){
            --i;            
        }
        return i<0?0:i;
    }
    
}


File: PermutationsOrAnagaramsOfAString.txt
Question Type: Strings
DSA Question: DSA problem related to: PermutationsOrAnagaramsOfAString
----------------------
/*
//All possible anagrams or permutation of a string
void helper(String txt,String str,int l,int h){
        if(l==h){
            if(txt.indexOf(str)>=0){
                System.out.println(str);
            }
        }else{
            for(int i=l;i<=h;++i){
                str=swap(str,l,i);
                helper(txt,str,l+1,h);
                str=swap(str,l,i);
            }
        }
    }
    
    public String swap(String a, int i, int j){ 
		char temp; 
		char[] charArray = a.toCharArray(); 
		temp = charArray[i] ; 
		charArray[i] = charArray[j]; 
		charArray[j] = temp; 
		return String.valueOf(charArray); 
	}*/


File: CaptureRegions.txt
Question Type: Strings
DSA Question: DSA problem related to: CaptureRegions
----------------------
/*
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.
*/
class Pair{
    public int i;
    public int j;
    
    public Pair(int i,int j){
        this.i=i;
        this.j=j;
    }
}
class Solution {
    public void solve(char[][] board) {
        if(board.length==0) return;
        List<Pair> list=new ArrayList<>();
        for(int i=0;i<board.length;++i){
            list.add(new Pair(i,0));
            list.add(new Pair(i,board[0].length-1));
        }
        for(int i=0;i<board[0].length;++i){
            list.add(new Pair(0,i));
            list.add(new Pair(board.length-1,i));
        }
        for(Pair pair:list){
            DFS(board,pair.i,pair.j);
        }
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]=='O'){
                 board[i][j]='X';                    
                }else if(board[i][j]=='#'){
                 board[i][j]='O';
                }
            }
        }
    }
    
    void DFS(char[][] board,int i,int j){
        if(board[i][j]!='O') return;
        int []x={0,0,1,-1};
        int []y={1,-1,0,0};
        board[i][j]='#';
        for(int m=0;m<x.length;++m){
            if(isSafe(board,i+x[m],j+y[m])){
                DFS(board,i+x[m],j+y[m]);
            }
        }
    }
    
    boolean isSafe(char[][] board,int i,int j){
        return i>=0 && i<board.length && j>=0 && j<board[0].length && board[i][j]=='O';
    }
}

File: KMP.txt
Question Type: Strings
DSA Question: DSA problem related to: KMP
----------------------
//KMP Algorithm
class Solution {
    public int strStr(String txt, String pat) {
        int N=txt.length(),M=pat.length();
        if(N<M)return -1;
        if(M==0 || N==0) return 0;
        int [] LPS=new int[M];
        fillLPS(pat,LPS);
        int i=0,j=0;
        while(i<N){
            if(txt.charAt(i)==pat.charAt(j)){++i;++j;}
            if(j==M){return i-j;}
            else if(i<N && txt.charAt(i)!=pat.charAt(j)){
                if(j==0) {i++;}
                else{
                    j=LPS[j-1];
                }
            }
        }
        return -1;
    }
    
    void fillLPS(String str,int [] LPS){
        int i=1,j=0;
        LPS[0]=0;
        while(i<str.length()){
            if(str.charAt(i)==str.charAt(j)){++j; LPS[i]=j; ++i;}
            else{
                if(j==0) {LPS[i]=0;i++;}
                else{
                    j=LPS[j-1];
                }
            } 
        }
    }
}

File: Most Common Word.txt
Question Type: Strings
DSA Question: DSA problem related to: Most Common Word
----------------------
class Solution {
    public String mostCommonWord(String p, String[] banned) {
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<banned.length;++i){
            set.add(banned[i]);
        }
        String ans=null;int count=0;
        HashMap<String,Integer> map=new HashMap<>();
        StringBuilder temp=null;
        for(int i=0;i<p.length();++i){
            char c=p.charAt(i);
            if((c>='A'&& c<='Z')||(c>='a'&& c<='z')){
                if(temp==null){
                    temp=new StringBuilder();
                }
                temp.append(c);
            }else{
                if(temp!=null && temp.length()!=0){
                    String sTemp= temp.toString();
                    sTemp=sTemp.toLowerCase();
                    if(set.contains(sTemp)){
                        temp=null;
                        continue;
                    }
                    map.put(sTemp,map.getOrDefault(sTemp,0)+1);
                    if(count<map.get(sTemp)){
                        count=map.get(sTemp);
                        ans=sTemp;
                    }
                    temp=null;
                }
            }
        }
        if(temp!=null && temp.length()!=0){
            String sTemp= temp.toString();
            sTemp=sTemp.toLowerCase();
            if(!set.contains(sTemp)){
                map.put(sTemp,map.getOrDefault(sTemp,0)+1);
                if(count<map.get(sTemp)){
                    count=map.get(sTemp);
                    ans=sTemp;
                }
            }
            temp=null;
        }
        return ans;
    }
}

File: Group Anagram.txt
Question Type: Strings
DSA Question: DSA problem related to: Group Anagram
----------------------
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map=new HashMap<>();
        for(String str:strs){
            String hashCode=getHashCode(str);
            List<String> list=map.getOrDefault(hashCode,new ArrayList<>());
            list.add(str);
            map.put(hashCode,list);
        }
        return new ArrayList(map.values());
    }
    
    private String getHashCode(String str){
        int[] memo=new int[256];
        for(int i=0;i<str.length();++i){
            memo[str.charAt(i)]++;
        }
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<memo.length;++i){
            sb.append(memo[i]+"#");
        }
        return sb.toString();
    }
}

File: CombinationOfString.txt
Question Type: Strings
DSA Question: DSA problem related to: CombinationOfString
----------------------
public class CombinationOfString {
    static void combination(String s){
        if(s.length()==0) return;
        System.out.println(" ");
        for(int i=0;i<s.length();++i){
            DFS(i,s.substring(i,i+1),s.toCharArray());
        }
   
    }
    
    private static void DFS(int index,String ans, char[] cs) {
        System.out.println(ans);
        if(index==cs.length-1) return;
        for (int i = index+1; i < cs.length; ++i) {
            DFS(i,ans +cs[i],cs);
        }
    }


    public static void main(String[] args) {
        combination("ABC");
    }
}


File: ITOA.txt
Question Type: Strings
DSA Question: DSA problem related to: ITOA
----------------------
package main.java.String;

import java.util.Stack;

public class ITOA {//Integer to Alphabet
    public static void main(String args[]){
        String alphabetNumber=getStringFromNumber(12345);
        System.out.println(alphabetNumber);
    }

    private static String getStringFromNumber(int i) {
        if(i==0) return "0";
        StringBuilder sb=new StringBuilder();
        while (i!=0){
            int x=i%10;
            sb.append(x);
            i=i/10;
        }
        return reverse(sb.toString());
    }

    private static String reverse(String str) {
        char[] arr=str.toCharArray();
        int l=0,h=str.length()-1;
        while(l<h){
            char temp=arr[l];
            arr[l]=arr[h];
            arr[h]=temp;
            ++l;
            --h;
        }
        return String.copyValueOf(arr);
    }
}


File: MinimumWindowSubstring.txt
Question Type: Strings
DSA Question: DSA problem related to: MinimumWindowSubstring
----------------------
/*
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

Example:

Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"
Note:

If there is no such window in S that covers all characters in T, return the empty string "".
If there is such window, you are guaranteed that there will always be only one unique minimum window in S.
*/
class Solution {
    public String minWindow(String txt, String pat) {
        int textLen=txt.length();
        int patLen=pat.length();
        int[] needToFind=new int[256];
        for(int i=0;i<patLen;++i){
            needToFind[pat.charAt(i)]++;
        }
        int[] hasFound=new int[256];
        int minWindLen=Integer.MAX_VALUE;
        int minWinBegin=0;
        int minWinEnd=0;
        int count=0;
        for(int begin=0,end=0;end<textLen;end++){  //Expansion
            if(needToFind[txt.charAt(end)]==0) continue;
            hasFound[txt.charAt(end)]++;
            if(hasFound[txt.charAt(end)]<=needToFind[txt.charAt(end)]){
                ++count;
            }
            if(count==patLen){
                while(needToFind[txt.charAt(begin)]==0 || 
                      hasFound[txt.charAt(begin)]>needToFind[txt.charAt(begin)]){
                    if(hasFound[txt.charAt(begin)]>needToFind[txt.charAt(begin)]){
                      hasFound[txt.charAt(begin)]--;  
                    }
                    begin++;//compresing
                }
                int windowLen = end - begin +1;
                if(windowLen<minWindLen){
                    minWinBegin=begin;
                    minWinEnd=end;
                    minWindLen=windowLen;
                }
            }
        }
        return  count==patLen?txt.substring(minWinBegin,minWinEnd+1):"";
    }
}

File: GenerateAllStringOfNBits.txt
Question Type: Strings
DSA Question: DSA problem related to: GenerateAllStringOfNBits
----------------------
public class GenerateAllStringOfNBits {
    static void allStrings(int n){
        int[] ans=new int[n];
        DFS(0,ans);
    }
    
    private static void DFS(int index,int[] ans) {
        if(index==ans.length){
            for(int i=0;i<ans.length;++i){
                System.out.print(ans[i]);
            }
            System.out.println("");
            return;
        } 
        ans[index]=1;
        DFS(index+1, ans);
        ans[index]=0;
        DFS(index+1, ans);
    }


    public static void main(String[] args) {
        allStrings(3);
    }
}


File: RabinKarp.txt
Question Type: Strings
DSA Question: DSA problem related to: RabinKarp
----------------------
/*
Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2
Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
*/
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length()==0) return 0;
        if(haystack.length()==0) return -1;
        if(haystack.length()<needle.length()) return -1;
        int q=101,d=256;
        //h=d^m-1/q
        int h=1;
        for(int i=0;i<needle.length()-1;++i){
            h=(h*d)%q;
        }
        //to and p calculation 
        int t=0,p=0;
        for(int i=0;i<needle.length();++i){
            p=(p*d+needle.charAt(i))%q;
            t=(t*d+haystack.charAt(i))%q;
        }
        
        //comparing t and p and on matching compare the internal characters
        for(int i=0;i<haystack.length()-needle.length()+1;++i){
            if(t==p){
                boolean flag=true;
                for(int j=0;j<needle.length();++j){
                    if(haystack.charAt(i+j)!=needle.charAt(j)){flag=false;break;}
                }
                if(flag) return i;
            }
            if(i<haystack.length()-needle.length()){
                t=(haystack.charAt(i+needle.length())+d*(t-h*haystack.charAt(i)))%q;//calculating t(i+1)
                if(t<0) t=t+q;
            }
        }
        return -1;
    }
}

File: Rank OfString Lexicographic Rank.txt
Question Type: Strings
DSA Question: DSA problem related to: Rank OfString Lexicographic Rank
----------------------

	static int fact(int n){
     	if(n==1 || n==0) return 1; 
      	return n*fact(n-1);
    	}  
  
	// A function to find rank of a string in 
	// all permutations of characters 
	static int findRank(String str) 
	{ 	int rank=1;
     	int len=str.length();
     	int fact=fact(len);
     	int count[] =new int[256];
     	for(int i=0;i<256;i++){
           count[i]=0;
        }
     	for(int i=0;i<str.length();++i){
         	count[str.charAt(i)]++; 
        }
    	for(int i=1;i<256;++i){
         	count[i]=count[i]+count[i-1]; 
        }
     	for(int i=0;i<str.length();++i){
         	fact=fact/(len-i);
          	rank=rank+fact*count[str.charAt(i)-1];
          	for(int j=str.charAt(i);j<256;++j){
             	--count[j]; 
            }
        }     
     	return rank;
	} 

File: PermutationsOrAnagaramsOfAIntegerArray.txt
Question Type: Strings
DSA Question: DSA problem related to: PermutationsOrAnagaramsOfAIntegerArray
----------------------
class Solution {
    List<List<Integer>> list;
    public List<List<Integer>> permute(int[] nums) {
        list=new LinkedList<>();
        if(nums.length==0) return list;
        helper(nums,0,nums.length-1);
        return list;
    }
    
    void helper(int[] nums,int l,int h){
        if(l==h){
            List<Integer> newList=new ArrayList<>();
            for(int i=0;i<nums.length;++i){
                newList.add(nums[i]);
            }
            list.add(newList);
        }else{
            for(int i=l;i<=h;++i){
                swap(nums,i,l);
                helper(nums,l+1,h);
                swap(nums,i,l);
            }
        }
    }
    
    void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}

File: PermutationOfString.txt
Question Type: Strings
DSA Question: DSA problem related to: PermutationOfString
----------------------
public class PermutationOfString {

    static void permutation(String s){
        if(s.length()==0) return;
        DFS(0,s.toCharArray());
    }
    
    private static void DFS(int index, char[] cs) {
        if (index == cs.length-1) {
            System.out.println(cs);
            return;
        }
        for (int i = index; i < cs.length; ++i) {
            swap(cs,index,i);
            DFS(index+1, cs);
            swap(cs,index,i);
        }
    }

    private static void swap(char[] cs, int index, int i) {
        char temp=cs[i];
        cs[i]=cs[index];
        cs[index]=temp;
    }

    public static void main(String[] args) {
        permutation("ABC");
    }
}


File: BackSpaceCompare.txt
Question Type: Strings
DSA Question: DSA problem related to: BackSpaceCompare
----------------------
class BackspaceCompare {

    public static boolean compare(String str1, String str2) {
      char[] s1=str1.toCharArray();
      char[] s2=str2.toCharArray();
      int l1=0;
      for(int h=0;h<s1.length;++h){
         if(s1[h]=='#'){
           --l1;
         }else{
           s1[l1]=s1[h];
           ++l1;
         }
      }
      int l2=0;
      for(int h=0;h<s2.length;++h){
         if(s2[h]=='#'){
           --l2;
         }else{
           s2[l2]=s2[h];
           ++l2;
         }
      }
      if(l1!=l2) return false; 
      for(int i=0;i<l2;++i){
        if(s1[i]!=s2[i]) return false;
      }
      return true;
    }
  }

File: ReverseStringUsingTwoPointer.txt
Question Type: Strings
DSA Question: DSA problem related to: ReverseStringUsingTwoPointer
----------------------
class Solution {
    public void reverseString(char[] s) {
        int l=0,h=s.length-1;
        while(l<h){
            char temp=s[l];
            s[l]=s[h];
            s[h]=temp;
            ++l;
            --h;
        }
    }

}

File: StringCompression.txt
Question Type: Strings
DSA Question: DSA problem related to: StringCompression
----------------------
class Solution {
    public int compress(char[] chars) {
        char currChar=chars[0];
        int currCharCount=1;
        if(chars.length==1){
            return 1;
        }
        int size=0;
        for(int i=1;i<chars.length;++i){
            char temp=chars[i];
            if(temp==currChar){
                currCharCount++;
            }else{
                String number=(currCharCount==1)?"":currCharCount+"";
                chars[size++]=currChar;
                if(number.length()>0){
                    for(int m=0;m<number.length();++m){
                        chars[size++]=number.charAt(m);
                    }
                }
                currChar=temp;
                currCharCount=1;
            }
        }
        String number=(currCharCount==1)?"":currCharCount+"";
        chars[size++]=currChar;
        if(number.length()>0){
            for(int m=0;m<number.length();++m){
                chars[size++]=number.charAt(m);
            }
        }
        return size;
    }
}

File: FirstUniqueCharacterInAString.txt
Question Type: Strings
DSA Question: DSA problem related to: FirstUniqueCharacterInAString
----------------------
//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.
class Solution {
    public int firstUniqChar(String s) {
        Integer[] count=new Integer[256];
        for(int i=0;i<s.length();++i){
            if(count[s.charAt(i)]==null){
                count[s.charAt(i)]=i;
            }else{
                count[s.charAt(i)]=-1;
            }
        }
        
        Integer res=Integer.MAX_VALUE;
        for(int i=0;i<256;++i){
            if(count[i]!=null && count[i]>=0){
                res=Math.min(res,count[i]);
            }
        }
        
        return res==Integer.MAX_VALUE?-1:res;
    }
}

File: ReverseWordsInAString.txt
Question Type: Strings
DSA Question: DSA problem related to: ReverseWordsInAString
----------------------
//Given an input string, reverse the string word by word.
class Solution {
    public String reverseWords(String s) {
        if(s==null || s.length()==0) return "";
        s=reverse(s.toCharArray());
        int curr=0,start=0;
        StringBuilder sb=new StringBuilder();
        while(curr<s.length()){
            if(s.charAt(curr)!=' '){
                ++curr;
            }else{
                if(start!=curr){
                    sb.append(reverse(s.substring(start,curr).toCharArray())+" ");
                    start=curr;
                }else{
                    ++curr;
                    ++start;
                }
            }
        }
        if(start!=curr){
            sb.append(reverse(s.substring(start,curr).toCharArray())+" ");
        }
        return sb.length()==0?"":sb.toString().substring(0,sb.length()-1);
    }
    
    String reverse(char[] arr){
        int l=0,h=arr.length-1;
        while(l<h){
            char temp=arr[l];
            arr[l]=arr[h];
            arr[h]=temp;
            l++;--h;
        }
        return String.valueOf(arr);
    }
}

File: ReverseStringUsingRecursion.txt
Question Type: Strings
DSA Question: DSA problem related to: ReverseStringUsingRecursion
----------------------
/*
Write a function that reverses a string. The input string is given as an array of characters char[].

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

You may assume all the characters consist of printable ascii characters.
*/
class Solution {
    public void reverseString(char[] s) {
        helper(s,0,s.length-1);
    }
    void helper(char[] s,int l,int h){
        if(l<h){
            char temp=s[l];
            s[l]=s[h];
            s[h]=temp;
            helper(s,++l,--h);
        }
    }
}

File: CombinationsOfArray.txt
Question Type: Strings
DSA Question: DSA problem related to: CombinationsOfArray
----------------------
//Combinations Combinations of a Array
class Solution {
    List<List<Integer>> list;
    public List<List<Integer>> subsets(int[] nums) {
        list=new LinkedList<>();
        List<Integer> newList=new LinkedList<>();
        list.add(newList);
        helper(nums,newList,0);
        return list;
    }
    
    void helper(int[] nums,List<Integer> newList,int l){
        for(int i=l;i<nums.length;++i){
            newList.add(nums[i]);
            list.add(new LinkedList(newList));
            if(i+1!=nums.length) {
                helper(nums,newList,i+1);                
            }
            newList.remove(newList.size()-1);
        }
        
    }
    
}

File: ATOI.txt
Question Type: Strings
DSA Question: DSA problem related to: ATOI
----------------------
class Solution {
    public int myAtoi(String str) {//"123"
        if(str.length()==0) return 0;
        str.trim();
        char [] chars=str.toCharArray();
        int result=0;
        int start=0;
        while(start<chars.length && chars[start]==' '){
            ++start;
        }
        boolean isNegative=false;
        if(start<chars.length && chars[start]=='-'){
            ++start;
            isNegative=true;
        }else if(start<chars.length && chars[start]=='+'){
            ++start;
        }
        for(int i=start;i<chars.length;++i){
            if(chars[i]>='0' && chars[i]<='9'){
                int d=chars[i]-'0';
                if(result>(Integer.MAX_VALUE-d)/10){
                    result=isNegative?Integer.MIN_VALUE:Integer.MAX_VALUE;
                    return result;
                }
                result=result*10+(d);
            }else{
                break;
            }
        }
        if(isNegative){
            result=-1*result;
        }
        if(result>Integer.MAX_VALUE){
            return Integer.MAX_VALUE;
        }else if(result<Integer.MIN_VALUE){
            return Integer.MIN_VALUE;
        }
        return result;
    }
}

class Solution {//Revision
    public int myAtoi(String str) {//"123" "4193 with words" "words and 987" "-91283472332"
        str=str.trim();
        if(str.length()==0) return 0;
        int start=-1;
        int startWords=Integer.MAX_VALUE; 
        boolean signEncounterd=false ;
        boolean zeroEncounterd=false;
        for(int i=0;i<str.length();++i){
            char c=str.charAt(i);
            if(c>='1' && c<='9'){
                start=i;
                break;
            }else if(c=='-' || c=='+'){
                if(signEncounterd==true || zeroEncounterd==true){
                    return 0;
                }
                signEncounterd=true;
                continue;
            }else if(c=='0'){
                zeroEncounterd=true;
                continue;
            }else{
                startWords=i;
            }
        }
        if(startWords<start || start==-1){
            return 0;
        }
        int negativeMultiplier=1;
        if(str.charAt(0)=='-'){
            negativeMultiplier=-1;
        }
        double resultF=0.0;
        for(int i=start;i<str.length();++i){
            char c=str.charAt(i);
            if(c<'0' || c>'9') break;
            resultF=resultF*10+(c-'0');
        }
        int ans=0;
        if(resultF>Integer.MAX_VALUE && negativeMultiplier==1){
            ans=Integer.MAX_VALUE;
        }
        else if(resultF>Integer.MAX_VALUE && negativeMultiplier==-1){
            ans=Integer.MIN_VALUE;
        }else{
           ans=(int)resultF;
           ans=ans*negativeMultiplier;
        }
        return ans;
    }
}

File: LongestSubstringWithoutRepeatingCharacters.txt
Question Type: Strings
DSA Question: DSA problem related to: LongestSubstringWithoutRepeatingCharacters
----------------------
//Given a string, find the length of the longest substring without repeating characters.
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int N=s.length();
        int [] memo=new int[128];
        Arrays.fill(memo,-1);
        int maxLen=0;
        for(int j=0,i=0;j<N;++j){
            i=Math.max(i,memo[s.charAt(j)]+1);
            maxLen=Math.max(maxLen,j-i+1);
            memo[s.charAt(j)]=j;
        }
        return maxLen;
    }
}

// Longest Substring Without Repeating Characters
class Solution {//Revision
    public int lengthOfLongestSubstring(String s) {
        int maxSoFar=0;
        int l=0,h;
        Integer memo[]=new Integer[256];
        for(h=0;h<s.length();++h){
            if(memo[s.charAt(h)]!=null){
                l=Math.max(l,1+memo[s.charAt(h)]);    
            }
            maxSoFar=Math.max(maxSoFar,h-l+1);
            memo[s.charAt(h)]=h;
        }
        return maxSoFar;
    }
}   
    

File: DesignHashMap.txt
Question Type: Hashing and HashTable
DSA Question: DSA problem related to: DesignHashMap
----------------------
/*
Design a HashMap without using any built-in hash table libraries.

To be specific, your design should include these functions:

put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.
get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.
*/
class MyPair<T,Y>{
    public T key;
    public Y value;
    
    public MyPair(){
        
    }
    
    public MyPair(T key,Y value){
        this.key=key;
        this.value=value;
    }
    
    @Override
    public String toString(){
        return "key: "+key+" Value: "+value;  
    } 
}
class MyHashMap {
    int CAPACITY;
    List<MyPair<Integer,Integer>>[] hashTable;
    public MyHashMap() {
        CAPACITY=2069;
        hashTable = new LinkedList[CAPACITY];
        for (int i = 0; i < this.CAPACITY; ++i) {
            this.hashTable[i]=new LinkedList<>();
        }
    }
    
    int getHash(int key){
       return key%CAPACITY; 
    }
    
    public void put(int key, int value) {
        int hashKey= getHash(key);
            boolean found=false;
            for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
                if(bucket.key==key){
                    hashTable[hashKey].remove(bucket);
                    break;
                 }
            }
            MyPair<Integer,Integer> newPair=new MyPair<>(key,value);
            hashTable[hashKey].add(newPair); 
    }
    
    public int get(int key) {
        int hashKey= getHash(key);
        if(null==hashTable[hashKey]){
            return -1;
        }
        for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
            if(bucket.key==key){
                return bucket.value;
            }
        }
        return -1;
    }
    
    public void remove(int key) {
        int hashKey= getHash(key);
        if(null==hashTable[hashKey]){
            return;
        }
        for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
            if(bucket.key==key){
                hashTable[hashKey].remove(bucket); break;
            }
        }
    }
}



File: MyHashSet.txt
Question Type: Hashing and HashTable
DSA Question: DSA problem related to: MyHashSet
----------------------
class MyHashSet {

    int CAPACITY;
    
    List<Integer>[] hashTable;
    
    public MyHashSet() {
        CAPACITY=2069;
        hashTable = new LinkedList[CAPACITY];
        for (int i = 0; i < this.CAPACITY; ++i) {
            this.hashTable[i]=new LinkedList<>();
        }
    }
    
    int getHash(int key){
       return key%CAPACITY; 
    }
    
    public void add(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                hashTable[hashKey].remove(bucket);
                break;
             }
        }
        hashTable[hashKey].add(key); 
    }
    
    public void remove(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                hashTable[hashKey].remove(bucket); break;
            }
        }  
    }
    
    public boolean contains(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                return true;
            }
        }
        return false;
    }
}


File: RemoveDuplicatesInAnArray.txt
Question Type: Hashing and HashTable
DSA Question: DSA problem related to: RemoveDuplicatesInAnArray
----------------------
class Solution {
    public int removeDuplicates(int[] arr) {
       int index=0; 
       HashSet<Integer> set=new HashSet<>(); 
       for(int i=0;i<arr.length;++i){
            if(!set.contains(arr[i])){
                set.add(arr[i]); 
                arr[index]=arr[i];
                ++index;
            }
       }
        return index; 
    }
}

File: MinOperationToReduceXToZero.txt
Question Type: TwoPointer
DSA Question: DSA problem related to: MinOperationToReduceXToZero
----------------------
/*
You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.

Return the minimum number of operations to reduce x to exactly 0 if it's possible, otherwise, return -1.
*/
class Solution {//Not Efficent
    
    public int minOperations(int[] arr, int x) {
        int moves=dfs(arr,x,0,arr.length-1);
        System.out.println(moves);
        return moves>arr.length?-1:moves;
    }
    
    int dfs(int[] arr,int target,int l,int h){
        if(target==0) return 0;
        if(l>h || l>arr.length-1 || h<0 || target<0)  return arr.length+1;
        return 1+Math.min(dfs(arr,target-arr[h],l,h-1),dfs(arr,target-arr[l],l+1,h));
    }
}

class Solution {
    public int minOperations(int[] nums, int x) {
        int sum=0;
        for(int num:nums){
            sum+=num;
        }
        int target=sum-x;
        int l=0,max=-1,sumW=0;
        for(int h=0;h<nums.length;++h){
            sumW+=nums[h];
            while(l<=h && sumW>target){
                sumW-=nums[l];
                ++l;
            }
            if(sumW==target){
                max=Math.max(max,h-l+1);
            }
        }
        if(max==-1) return -1;
        return nums.length-max;
    }
}

File: MaxNumberKSumPairs.txt
Question Type: TwoPointer
DSA Question: DSA problem related to: MaxNumberKSumPairs
----------------------
//Max Number of K-Sum Pairs
class Solution {
    public int maxOperations(int[] arr, int k) {
        Arrays.sort(arr);
        int l=0,h=arr.length-1;
        int count=0;
        while(l<h){
            int sum=arr[l]+arr[h];
            if(sum==k){
                ++count;
                ++l;
                --h;
            }else if(sum>k){
                --h;
            }else{
                ++l;
            }
        }
        return count;
    }
}

File: MinSwapsToSortAnDistinctArray.txt
Question Type: CyclicSort
DSA Question: Write an algorithm to sort an array.
----------------------
int minSwapCount(int[] arr){
    int count=0;
    boolean[] visited=new boolean[arr.length];
    for(int i=0;i<arr.length;++i){
        if(visited[i] || arr[i]==i) continue;
        visited[i]=true;
        int cycleCount=0;
        int c=i;
        while(!visited[c]){
            c=arr[c];
            visited[c]=true;
            ++cycleCount;
        }
        count=count+cycleCount-1;
    }
    return count;
}

File: DucthInternationalFlag.txt
Question Type: Array
DSA Question: DSA problem related to: DucthInternationalFlag
----------------------
class Solution {
    public void sortColors(int[] arr) {
        int l=0,m=0,h=arr.length-1;
        while(m<=h){
            if(arr[m]==0){
                swap(arr,l,m);
                l++;
                ++m;
            }else if(arr[m]==1){
                ++m;
            }else if(arr[m]==2){
                swap(arr,m,h);
                --h;
            }
        }
    }
    
    void swap(int[] arr,int m,int h){
        int temp=arr[m];
        arr[m]=arr[h];
        arr[h]=temp;
    }
}

File: TripletSumToZero.txt
Question Type: Array
DSA Question: DSA problem related to: TripletSumToZero
----------------------
import java.util.*;

class TripletSumToZero {

  public static List<List<Integer>> searchTriplets(int[] arr) {
    List<List<Integer>> triplets = new ArrayList<>();
    Arrays.sort(arr);
    for(int i=0;i<arr.length;++i){
      int l=i+1,h=arr.length-1;
      while(l<h){
        int tSum=arr[i]+arr[l]+arr[h];
        if(tSum==0){
          List<Integer> list=new ArrayList<>();
          list.add(arr[i]);list.add(arr[l]);list.add(arr[h]);
          triplets.add(list);
          l++;h--;
        }else if(tSum>0){
          h--;
        }else{
          l++;
        }
      }
    }
    return triplets;
  }
}

class Solution {
  public List<List<Integer>> threeSumDistinctTriplets(int[] arr) {
      List<List<Integer>> triplets = new ArrayList<>();
      Arrays.sort(arr);
      for(int i=0;i<arr.length;++i){
         if(i>0 && arr[i]==arr[i-1]) continue;
        int l=i+1,h=arr.length-1;
        while(l<h){
          int tSum=arr[i]+arr[l]+arr[h];
          if(l>i+1 && arr[l]==arr[l-1]){
              ++l;
          }else if(h<arr.length-1 && arr[h]==arr[h+1]){
              --h;
          }else if(tSum==0){
            List<Integer> list=new ArrayList<>();
            list.add(arr[i]);list.add(arr[l]);list.add(arr[h]);
            triplets.add(list);
            l++;h--;
          }else if(tSum>0){
            h--;
          }else{
            l++;
          }
        }
      }
      return triplets;
  }
}

File: RotateArray.txt
Question Type: Array
DSA Question: DSA problem related to: RotateArray
----------------------
class Solution {
    //1 2 3 4 5 6   //2
    //6 5 4 3 2 1
    //5 6  1 2 3 4 
    public void rotate(int[] nums, int k) {
        k=k%nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    
    void reverse(int[] nums,int l,int h){
        int i=l,j=h;
        while(i<j){
            nums[i]=nums[i]^nums[j];
            nums[j]=nums[i]^nums[j];
            nums[i]=nums[i]^nums[j];
            ++i;
            j--;
        }
    }
}

File: EuclideanDistanceKClosetPointsToOrigin.txt
Question Type: Array
DSA Question: DSA problem related to: EuclideanDistanceKClosetPointsToOrigin
----------------------
/*
We have a list of points on the plane.  Find the K closest points to the origin (0, 0).

(Here, the distance between two points on a plane is the Euclidean distance.)

You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)
*/
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        Arrays.sort(points,new Comparator<int[]>(){
            public int compare(int[] ob1,int[] ob2){
                return getEuclideanDistance(ob1).compareTo(getEuclideanDistance(ob2));
            }
        });
        int[][] result=new int[K][2];
        for(int i=0;i<K;++i){
            result[i][0]=points[i][0];
            result[i][1]=points[i][1];
        }
        return result;
    }
    

    Double getEuclideanDistance(int ob[]){
        int x=ob[0],y=ob[1];
        int compute=x*x+y*y;
        return Math.sqrt(compute);
    }

}


File: MergeIntervals.txt
Question Type: Array
DSA Question: DSA problem related to: MergeIntervals
----------------------
//Given a collection of intervals, merge all overlapping intervals.
class PairComparator implements Comparator<int[]>{ 
    public int compare(int[] p1, int[] p2) { 
        return p1[0]-p2[0];
    } 
} 
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length==0) return intervals;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] ob1,int[] ob2){
                return ob1[0]-ob2[0];
            }
        });
        LinkedList<int[]> list=new LinkedList<>();
        list.add(intervals[0]);
        for(int i=1;i<intervals.length;++i){
            if(list.get(list.size()-1)[1]>=intervals[i][0]){
                list.get(list.size()-1)[1]=Math.max(intervals[i][1],list.get(list.size()-1)[1]);
            }else{
                list.add(intervals[i]);    
            }
        }
        return list.toArray(new int[list.size()][]);
    }
}

File: TwoSum.txt
Question Type: Array
DSA Question: DSA problem related to: TwoSum
----------------------
int twoSumDistinctPairs(int[] arr,int target){
    int count=0;
    int l=0,h=arr.length-1;
    while(l<h){
        int sum=arr[l]+arr[h];
        if(l>0 && arr[l-1]==arr[l]){
            ++l;
        }else if(h<arr.length-1 && arr[h]==arr[h+1]){
            --h;
        }else if(sum==target){
            ++count;
            ++l;
            --h;
        }else if(sum>target){
            h--;
        }else{
            l++;
        }
        return count;
    }
}

{1,1,2,4,5,4} 5
{1,1,2,4,4,5}

l          h 
l         h       +1
  l     h
    l   h
    l h
    h l

File: MinimumSizeSubArraySum.txt
Question Type: Array
DSA Question: DSA problem related to: MinimumSizeSubArraySum
----------------------
class Solution {
    //minimum number of people required for meeting the criteria
    public int minSubArrayLen(int s, int[] nums) {
        if(nums.length==0) return 0;
        int minLengthRequired=Integer.MAX_VALUE;
        int currSumInWindow=0;
        int l=0;
        for(int h=0;h<nums.length;++h){//expansion
            currSumInWindow=currSumInWindow+nums[h];
            while(currSumInWindow>=s){//contraction
                minLengthRequired=Math.min(h-l+1,minLengthRequired);
                currSumInWindow=currSumInWindow-nums[l];
                l++;
            }
        }
        if(minLengthRequired==Integer.MAX_VALUE){
            return 0;
        }
        return minLengthRequired;
        
    }
}

File: MoveZeroes.txt
Question Type: Array
DSA Question: DSA problem related to: MoveZeroes
----------------------
/*
Given an array nums, write a function to move all 0's to the end of it while maintaining the 
relative order of the non-zero elements.
Example:
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.
*/
class Solution {
    public void moveZeroes(int[] nums) {
        int index=0,zeroCount=0;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==0){
                zeroCount++;
            }
            else if(nums[i]!=0){
                nums[index]=nums[i];index++;
            }
        }
        index=nums.length-1;
        for(int i=zeroCount;i>0;--i){
            nums[index]=0; --index;
        }
    }
}

File: TripletWithSmallerSum.txt
Question Type: Array
DSA Question: DSA problem related to: TripletWithSmallerSum
----------------------
import java.util.*;

class TripletWithSmallerSum {

  public static int searchTriplets(int[] arr, int target) {
    int count=0;
    Arrays.sort(arr);
    for(int i=0;i<arr.length;++i){
      int l=i+1,h=arr.length-1;
      while(l<h){
        int sum=arr[i]+arr[l]+arr[h];
        if(sum<target){
          count=count+h-l;
          l++;
        }
        else if(sum>=target){
          --h;
        }
      }
    }
    return count;
  }
}

File: Container with most water.txt
Question Type: Array
DSA Question: DSA problem related to: Container with most water
----------------------
class Solution {
    public int maxArea(int[] height) {
        int maxWater=0;
        int l=0,h=height.length-1;
        while(l<h){
            int water=Math.min(height[l],height[h])*(h-l);
            maxWater=Math.max(maxWater,water);
            if(height[l]<height[h]){
                ++l;
            }else{
                --h;
            }
        }
        return maxWater;
    }
}

File: LongestConsecutiveSequence.txt
Question Type: Array
DSA Question: DSA problem related to: LongestConsecutiveSequence
----------------------
/*
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
*/
class Solution {  //0(nlogn)
    public int longestConsecutive(int[] nums) {
        if(nums.length==0) return 0;
        Arrays.sort(nums);
        int maxCount=1,count=1;
        for(int i=1;i<nums.length;++i){
            if(nums[i]!=nums[i-1]){
                if(nums[i]==nums[i-1]+1){ ++count;}
                else{
                    maxCount=Math.max(count,maxCount);
                    count=1;
                }   
            }
        }
        return Math.max(count,maxCount);
    }
}

File: TwoDifference.txt
Question Type: Array
DSA Question: DSA problem related to: TwoDifference
----------------------
public class TwoDifference {
    int count=0;
    int countDiffPair(int[] arr,int target){
        if(arr.length==0) return 0;
        for(int i=0;i<arr.length;++i){
            binarySearch(i,arr,target-arr[i],true);
            binarySearch(i,arr,target-arr[i],false);
            if(target-arr[i]==0) continue;
            binarySearch(i,arr,arr[i]-target,true);
            binarySearch(i,arr,arr[i]-target,false);
        }
        return count;
    }

    void binarySearch(int l,int[] arr,int key,boolean leftSearch){
        int h=arr.length-1;
        while(l<h){
            int mid=l+(h-l)/2;
            if(arr[mid]==key){
                ++count;
                if(leftSearch){
                    h=mid-1;
                }else{
                    l=mid+1;
                }
            }else if(arr[mid]>key){
                --l;
            }else{
                ++h;
            }
        }
    }
}


File: MergeSortedArray.txt
Question Type: Array
DSA Question: DSA problem related to: MergeSortedArray
----------------------
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index=nums1.length-1;
        int m1=nums1.length;
        while(n>0){
            if(m==0 || nums1[m-1]<nums2[n-1]){
               nums1[index]=nums2[n-1];
               n--; 
            }else{
               nums1[index]=nums1[m-1]; 
               m--; 
            }
            index--;
        }
    }
}

File: Duplicates.txt
Question Type: Array
DSA Question: DSA problem related to: Duplicates
----------------------
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> ans=new ArrayList<>();
        if(nums.length==0) return ans;
        for(int num:nums){
            if(nums[Math.abs(num)-1]<0){
                ans.add(Math.abs(num));
            }else{
                nums[Math.abs(num)-1]=-nums[Math.abs(num)-1];
            }
        }
        return ans;
    }
}

File: RemoveElement.txt
Question Type: Array
DSA Question: DSA problem related to: RemoveElement
----------------------
/*
Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.
*/
class Solution {
    public int removeElement(int[] nums, int val) {
        int index=0;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==val){continue;}
            else{
                nums[index]=nums[i];
                ++index;
            }
        }
        return index;
    }
}

File: Trapping Rain Water.txt
Question Type: Array
DSA Question: DSA problem related to: Trapping Rain Water
----------------------
class Solution {
    public int trap(int[] height) {
        if(height.length==0) return 0;
        int left[]=new int[height.length];
        left[0]=height[0];
        int right[]=new int[height.length];
        right[height.length-1]=height[height.length-1];
        for(int i=1;i<height.length;++i){
            left[i]=Math.max(height[i],left[i-1]);
        }
        for(int i=height.length-2;i>=0;--i){
            right[i]=Math.max(height[i],right[i+1]);
        }
        int maxWater=0;
        for(int i=0;i<height.length;++i){
            maxWater=maxWater+(Math.min(left[i],right[i])-height[i]);
        }
        return maxWater;
    }
}

File: FindFirstMissingNumber.txt
Question Type: Array
DSA Question: DSA problem related to: FindFirstMissingNumber
----------------------
/*
Given an unsorted integer array, find the smallest missing positive integer.
*/
class Solution {
    public int firstMissingPositive(int[] nums) {
        Arrays.sort(nums);
        int number=1;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==number){++number;}
            else if(nums[i]>number){
                break;
            }
        }
        return number;
    }
}

class Solution {
    public int solution(int[] A) {
        for(int i=0;i<A.length;++i){
            if(A[i]<0){
                A[i]=0;
            }
        }
        for(int i=0;i<A.length;++i){
            if(A[i]==0 || A[Math.abs(A[i])-1]<0) continue;
            A[Math.abs(A[i])-1]=-1*A[Math.abs(A[i])-1];
        }
       
        int i=0;
        for(i=0;i<A.length;++i){
            if(A[i]>=0) return i+1;
        }
        return i+1;
    }
}

File: BestTimeToBuyAndSellStock.txt
Question Type: Array
DSA Question: DSA problem related to: BestTimeToBuyAndSellStock
----------------------
/*
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.
*/
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice=Integer.MAX_VALUE,maxProfit=0;
        for(int i=0;i<prices.length;++i){
            if(minPrice>prices[i]){
                minPrice=prices[i];
            }else if(maxProfit<prices[i]-minPrice){
                maxProfit=prices[i]-minPrice;
            }
        }
        return maxProfit;
    }
}

class Solution {//Revision
    public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        int lowest=0;
        int maxProfit=Integer.MIN_VALUE;
        for(int i=1;i<prices.length;++i){
            if(prices[lowest]>prices[i]){
                lowest=i;
            }else{
                int profit=prices[i]-prices[lowest];
                maxProfit=Math.max(maxProfit,profit);
            }
        }
        if(maxProfit==Integer.MIN_VALUE) return 0;
        return maxProfit;
    }
}

File: TripletSumClosestToTarget.txt
Question Type: Array
DSA Question: DSA problem related to: TripletSumClosestToTarget
----------------------
import java.util.*;

class TripletSumCloseToTarget {

  public static int searchTriplet(int[] arr, int targetSum) {
    int sDiff=Integer.MAX_VALUE;
    Arrays.sort(arr);
    for(int i=0;i<arr.length;++i){
      int l=i+1,h=arr.length-1;
      while(l<h){
        int cDiff=arr[i]+arr[l]+arr[h]-targetSum;
        if(Math.abs(cDiff)<Math.abs(sDiff)){
          sDiff=cDiff;
        }
        if(cDiff==0) return 0;
        if(cDiff>0){
          --h;
        }else{
          ++l;
        }
      }
    }
    return targetSum+sDiff;
  }
}

File: ArraySumPartition.txt
Question Type: Array
DSA Question: DSA problem related to: ArraySumPartition
----------------------
/*Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.
*/
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int maxSum=0;
        for(int i=0;i<nums.length;i=i+2){
            maxSum=maxSum+Math.min(nums[i],nums[i+1]);
        }
        return maxSum;
    }
}

File: ProductOfNumbersExceptSelf.txt
Question Type: Array
DSA Question: DSA problem related to: ProductOfNumbersExceptSelf
----------------------
/*
Given an array nums of n integers where n > 1,  return an array output such that output[i] 
is equal to the product of all the elements of nums except nums[i].
*/
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] answer = new int[length];
        answer[0] = 1;
        for (int i = 1; i < length; i++) {
            answer[i] = nums[i - 1] * answer[i - 1];
        }
        int R = 1;
        for (int i = length - 1; i >= 0; i--) {
            answer[i] = answer[i] * R;
            R *= nums[i];
        }
        return answer;
    }
}

class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] left=new int[nums.length];
        int[] right=new int[nums.length];
        left[0]=1;
        for(int i=1;i<left.length;++i){
            left[i]=nums[i-1]*left[i-1];
        }
        right[nums.length-1]=1;
        for(int i=nums.length-2;i>=0;--i){
            right[i]=nums[i+1]*right[i+1];
        }
        for(int i=0;i<nums.length;++i){
            nums[i]=left[i]*right[i];
        }
        return nums;
    }
}

File: MaxConsecutiveOnes.txt
Question Type: Array
DSA Question: DSA problem related to: MaxConsecutiveOnes
----------------------
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int maxSeqLen=0;
        int currSeqLength=0;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==1){
                ++currSeqLength;
            }else{
                maxSeqLen=Math.max(currSeqLength,maxSeqLen);
                currSeqLength=0;
            }
        }
        return maxSeqLen=Math.max(currSeqLength,maxSeqLen);
    }
}

File: GetMaximumInGenereatedArray.txt
Question Type: Array
DSA Question: DSA problem related to: GetMaximumInGenereatedArray
----------------------
/*
You are given an integer n. An array nums of length n + 1 is generated in the following way:

nums[0] = 0
nums[1] = 1
nums[2 * i] = nums[i] when 2 <= 2 * i <= n
nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n
Return the maximum integer in the array nums​​​.
*/
class Solution {
    public int getMaximumGenerated(int n) {
        if(n<=0) return 0;
        int[] memo=new int[n+1];
        memo[0]=0;
        memo[1]=1;
        int max=1;
        for(int i=2;i<memo.length;++i){
            if(i%2==0){
                memo[i]=memo[i/2];
            }else{
                memo[i]=memo[i/2]+memo[i/2+1];
            }
            max=Math.max(max,memo[i]);
        }
        return max;
    }
}

File: NestedlistWeightSum.txt
Question Type: Recursion
DSA Question: DSA problem related to: NestedlistWeightSum
----------------------
/**
 * 
 * You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.

The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.

Return the sum of each integer in nestedList multiplied by its depth.

 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *     // Constructor initializes an empty nested list.
 *     public NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     public NestedInteger(int value);
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // Set this NestedInteger to hold a single integer.
 *     public void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     public void add(NestedInteger ni);
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List<NestedInteger> getList();
 * }
 */
class Solution {
    int sum=0;
    public int depthSum(List<NestedInteger> nestedList) {
        dfs(nestedList,1,0);
        return sum;
    }
    
    void dfs(List<NestedInteger> list,int depth,int index){
        if(index==list.size()) return;
        NestedInteger curr=list.get(index);
        if(curr.isInteger()){
            sum=sum+depth*curr.getInteger();
            dfs(list,depth,index+1);
        }else{
            dfs(curr.getList(),depth+1,0);
            dfs(list,depth,index+1);
        }
    }
}

File: CountSortedVowelString.txt
Question Type: Recursion
DSA Question: DSA problem related to: CountSortedVowelString
----------------------
class Solution {//Not Efficient
    char[] arr={'a','e','i','o','u'};
    public int countVowelStrings(int n) {
         return helper("",0,n);          
    }
    
    int helper(String str,int index,int n){
        if(str.length()==n) {
            System.out.println(str);
            return 1;
        }
        int count=0;
        for(int i=index;i<arr.length;++i){
            count=count+helper(str+arr[i],i,n);
        }
        return count;
    }
}

class Solution {//Not efficent
    char[] arr={'a','e','i','o','u'};
    HashSet<String> set=new HashSet<>();
    public int countVowelStrings(int n) {
        for(int i=0;i<arr.length;++i){
          helper(""+arr[i],i,n);          
        }
        return set.size();
    }
    
    void helper(String str,int index,int n){
        if(str.length()==n) {
            set.add(str);
            return ;
        }
        if(index==arr.length) return;
        helper(str+arr[index],index,n);
        helper(str,index+1,n);
        if(index+1>=arr.length) return;
        helper(str+arr[index+1],index+1,n);
    }
}

File: LetterCombination.txt
Question Type: Recursion
DSA Question: DSA problem related to: LetterCombination
----------------------
class Solution {
   
    public List<String> letterCombinations(String digits) {
        List<String> ans=new ArrayList<>();
        if(digits.length()==0) return ans;
        Map<Integer,String> map=new HashMap<>();
        map.put(2,"abc");
        map.put(3,"def");
        map.put(4,"ghi");
        map.put(5,"jkl");
        map.put(6,"mno");
        map.put(7,"pqrs");
        map.put(8,"tuv");
        map.put(9,"wxyz");
        helper(map,ans,digits,0,"");        
        return ans;
    }
    
    void helper(Map<Integer,String> map,List<String> ans,String digits,int digit,String s){
        if(digit==digits.length()){
            ans.add(s);
            return;
        }
        for(int i=0;i<map.get(Integer.parseInt(""+digits.charAt(digit))).length();++i){
            helper(map,ans,digits,digit+1,s+map.get(Integer.parseInt(""+digits.charAt(digit))).charAt(i));
        }   
    }

}

File: GenerateParenthesis.txt
Question Type: Recursion
DSA Question: DSA problem related to: GenerateParenthesis
----------------------
class Solution {

    public List<String> generateParenthesis(int n) {
        List<String> ans=new ArrayList<>();
        if(n==0) return ans;
        StringBuilder sb=new StringBuilder();
        helper(ans,n,0,"");
        return ans;
    }
    
    void helper(List<String> ans,int n,int openCount,String s){
        if(s.length()==n*2){
            ans.add(s);
            return;
        }
        if(openCount<n){
            helper(ans,n,openCount+1,s+"(");
        }
        int closeCount=s.length()-openCount;
        if(closeCount<openCount && closeCount<n){
            helper(ans,n,openCount,s+")");
        }
    }

}

File: TowerOfHinoe.txt
Question Type: Recursion
DSA Question: DSA problem related to: TowerOfHinoe
----------------------


File: CombinationSum.txt
Question Type: Recursion
DSA Question: DSA problem related to: CombinationSum
----------------------
/*
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), 
find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
*/
class Solution {
    
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result=new ArrayList<>();
        helper(candidates,0,target,result,new ArrayList<Integer>());
        return result; 
    }
    
    void helper(int[] arr,int index,int target,List<List<Integer>> result,List<Integer> temp){
        if(target<0) return;
        if(target==0){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i]){
                temp.add(arr[i]);
                helper(arr,i,target-arr[i],result,temp);
                temp.remove(temp.size()-1);
            }
        }
    }
}

File: Factorial.txt
Question Type: Recursion
DSA Question: DSA problem related to: Factorial
----------------------
public class Factorial{
	static int factorial(int n){
		if(n==0 || n==1) return 1;
		return n*factorial(n-1);
	}

	public static void main(String args[]){
		System.out.print("factorial of 5 is :  "+factorial(5));
	}
}

File: Fibonacii.txt
Question Type: Recursion
DSA Question: DSA problem related to: Fibonacii
----------------------
public class Fibonacii{
	static int fibonacii(int n){
		if(n==0)return 0;
		if(n==1) return 1;
		return fibonacii(n-1)+fibonacii(n-2);
	}

	public static void main(String args[]){
		System.out.print("fibonacii of 8 is :  "+fibonacii(8));
	}
}

File: PermutationOfNumbersInAnArray.txt
Question Type: Recursion
DSA Question: DSA problem related to: PermutationOfNumbersInAnArray
----------------------
class Solution {
    List<List<Integer>> list;
    public List<List<Integer>> permute(int[] nums) {
        list=new LinkedList<>();
        if(nums.length==0) return list;
        helper(nums,0,nums.length-1);
        return list;
    }
    
    void helper(int[] nums,int l,int h){
        if(l==h){
            List<Integer> newList=new ArrayList<>();
            for(int i=0;i<nums.length;++i){
                newList.add(nums[i]);
            }
            list.add(newList);
        }else{
            for(int i=l;i<=h;++i){
                swap(nums,i,l);
                helper(nums,l+1,h);
                swap(nums,i,l);
            }
        }
    }
    
    void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}


File: CombinationSumII.txt
Question Type: Recursion
DSA Question: DSA problem related to: CombinationSumII
----------------------
/*
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
*/
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> result=new ArrayList<>();
        helper(candidates,0,target,result,new ArrayList<Integer>());
        return result;
    }
    
    void helper(int[] arr,int index,int target,List<List<Integer>> result,List<Integer> selected){
        if(target<0){
          return;   
        }
        if(target==0){
            result.add(new ArrayList<>(selected));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i] && (i==index || arr[i]!=arr[i-1])){
                selected.add(arr[i]);
                helper(arr,i+1,target-arr[i],result,selected);
                selected.remove(selected.size()-1);
            }
        }
    }
}

File: AlteredBinarySearchPivot.txt
Question Type: Searching
DSA Question: Implement a searching algorithm.
----------------------
/*
Search in Rotated Sorted Array*/

class Solution {//[4,5,6,7,0,1,2]
    public int search(int[] nums, int target) {
        return helper(nums,target,0,nums.length-1);
    }
    
    int helper(int[] nums,int target,int l,int h){
        if(l>h) return -1;
        int mid=l+(h-l)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[l]<=nums[mid]){
            int index1= helper(nums,target,l,mid-1);
            if(index1>=0) return index1;
            return helper(nums,target,mid+1,h);
        }
        int index2=helper(nums,target,mid+1,h);
        if(index2>=0) return index2;
        return helper(nums,target,l,mid-1);
    }
    
}

class AlteredBinarySearchPivot { //binary Search Altered
    public int search(int[] arr, int target) {
       return srch(arr,0,arr.length-1,target);
    }
    
    int srch(int[] arr,int l,int h,int target){ // trick: find the sorted half and check if target in it
                                                // if not in sorted half go to unsorted half
        if(h<l){return -1;}
        int mid=(l+h)/2;
        if(arr[mid]==target) return mid;
        if(arr[mid]>=arr[l]){ //is first half sorted
            if(target>=arr[l] && target<=arr[mid]){   //is in first half             
                return srch(arr,l,mid-1,target);
            }else{
                return srch(arr,mid+1,h,target); //in secound half
            }   
        }else{//2nd half sorted
            if(target>=arr[mid] && target<=arr[h]){//in secound half
                return srch(arr,mid+1,h,target);
            } else{ // in first half
                return srch(arr,l,mid-1,target);
            }

        }       
    } 
}

class Solution {  // revision one
    public int search(int[] nums, int target) {
        if(nums.length==0) return -1;
        return binarySearch(nums,0,nums.length-1,target);          
    }
    
    int binarySearch(int[] arr,int l,int h,int target){
        if(l<=h){
            int mid=(l+h)/2;
            if(arr[mid]==target){return mid;}
            else if(l<=mid-1 && arr[l]<=arr[mid-1]){
                int val=binarySearch(arr,l,mid-1,target);
                if(val>=0){return val;}
                else return binarySearch(arr,mid+1,h,target);
            }else{
                int val=binarySearch(arr,mid+1,h,target);
                if(val>=0){return val;}
                else return binarySearch(arr,l,mid-1,target);
            }
        }
        return -1;
    }
    
}

File: Searching.txt
Question Type: Searching
DSA Question: Implement a searching algorithm.
----------------------
Linear Search -> o(n)
Binary Search ->o(logn)  -> calculate mid and check whether the element at mid equals the key if not either
 search on left or right of the mid based on whether the mid element is less than or greate than the key.

File: RangeSearch.txt
Question Type: Searching
DSA Question: Implement a searching algorithm.
----------------------
h
int findCountOfElement(int[] arr,int target){
    if(arr.length==0)return -1;
    int left=getRange(arr,0,arr.length-1,false,target);
    if(left==-1) return -1;
    int right=getRange(arr,0,arr.length-1,true,target);
    return right-left+1;
} 
int getRange(int[] arr,int l,int h,boolean isLeft,int target){
    int range=-1;
    while(l<=h){
        int mid=l+(h-l)/2;
        if(arr[mid]==target){
            range=mid;
            if(!isLeft){
                h=mid-1;
            }else{
                l=mid+1;
            }
        }
        else if(arr[mid]>target){
            h=mid-1;
        }else{
            l=mid+1;
        }
    }
    
    return range;
}

File: StartAndEndOfTragetValueInAnArray.txt
Question Type: Searching
DSA Question: Implement a searching algorithm.
----------------------
/*
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].
*/
class StartAndEndOfTragetValueInAnArray {
    public int[] searchRange(int[] nums, int target) {
        int l=-1,h=-1;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==target){
                if(l==-1){
                    l=i;h=i;
                }else{
                    h=i;
                }
            }
            if(nums[i]!=target && l!=-1){
                break;
            }
        }
        int [] result={l,h};
        return result;
    }
}

File: AddTwoNumberIIUsingStack.txt
Question Type: LinkedList
DSA Question: DSA problem related to: AddTwoNumberIIUsingStack
----------------------
/*
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.
*/
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<Integer> s1=getStack(l1);
        Stack<Integer> s2=getStack(l2);
        ListNode dummy=new ListNode();
        int carry=0;
        while(!s1.isEmpty() || !s2.isEmpty()){
            int x=s1.isEmpty()?0:s1.pop();int y=s2.isEmpty()?0:s2.pop();
            int sum=(x+y+carry)%10;
            carry=(x+y+carry)/10;
            addAfterDummyNode(new ListNode(sum), dummy);
        }
        if(carry!=0){
            addAfterDummyNode(new ListNode(carry), dummy);
        }
        return dummy.next;
    }
    
    void addAfterDummyNode(ListNode node,ListNode dummy){
        node.next=dummy.next;
        dummy.next=node;
    }
    
    Stack getStack(ListNode node){
        Stack<Integer> stack=new Stack<>();
        while(node !=null){
            stack.add(node.val);
            node=node.next;
        }
        return stack;
    }
        
}

File: AddTwoNumberIIUsingReverse.txt
Question Type: LinkedList
DSA Question: DSA problem related to: AddTwoNumberIIUsingReverse
----------------------
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1=reverse(l1);
        l2=reverse(l2);
        int carry=0,sum;
        ListNode current1=l1,current2=l2,prev1=null,prev2=null;
        while(current1 !=null && current2 !=null){
            sum=current1.val+current2.val+carry;
            carry=sum/10;
            current1.val=sum%10;
            prev1=current1; prev2=current2;
            current1=current1.next; current2=current2.next;
        }
        while(current1!=null){
            sum= current1.val+carry;
            current1.val=sum%10;
            carry=sum/10;
            prev1=current1;
            current1=current1.next;
        }
        while(current2!=null){
            sum= current2.val+carry;
            prev1.next=new ListNode(sum%10);
            carry=sum/10;
            prev1=prev1.next;
            current2=current2.next;
        }
        if(carry!=0){
            prev1.next=new ListNode(carry);
        }
       return reverse(l1); 
    }
    
    ListNode reverse(ListNode head){
        ListNode prev=null,next=null,curr=head;
        while(curr!=null){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
    }
}

File: ReverseNodesInKGroup.txt
Question Type: LinkedList
DSA Question: DSA problem related to: ReverseNodesInKGroup
----------------------
/**
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes 
is not a multiple of k then left-out nodes in the end should remain as it is.
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode curr=head;
        int size=0;
        while(curr!=null){
            curr=curr.next;
            ++size;
        }
        ListNode dummy=new ListNode();
        dummy.next=head;
        ListNode last=dummy;
        int i=0;
        while(last!=null && size-i>=k){
            last=reverseKElementsOnly(last,k);
            i=i+k;
        }
        return dummy.next;
        
    }
    
    ListNode reverseKElementsOnly(ListNode last,int k){
        int i=0;
        ListNode head=last.next;
        ListNode curr=head,prev=null,next=null;
        while(i<k && curr!=null){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
            ++i;
        }
        last.next=prev;//prev have become head nad will be attached to last 
        if(head!=null){
            head.next=curr;    
        }
        return head;//head have come to end and will become last for next call
    }
}

class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode curr=head,prevTail=null,newHead=null;
        while(curr!=null){
            int count=0;
            curr=head;
            while(count<k && curr!=null){
                curr=curr.next;
                ++count;
            }
            if(count==k){
                ListNode revHead=reversekNodes(head,k);
                if(prevTail!=null){prevTail.next=revHead;}
                if(newHead==null){newHead=revHead;}
                prevTail=head;
                head=curr;
            }
        }
        if(prevTail!=null){prevTail.next=head;}
        return newHead==null?head:newHead;
    }
    
    ListNode reversekNodes(ListNode node,int k){
        ListNode curr=node,prev=null,next=null;
        while(k>0){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
            --k;
        }
        return prev;
    }
}

File: SortLinkedListusingMergeSort.txt
Question Type: LinkedList
DSA Question: DSA problem related to: SortLinkedListusingMergeSort
----------------------
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode fast=head;
        ListNode half=head;
        ListNode tail=half;
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            tail=half;
            half=half.next;
        }
        tail.next=null;
        ListNode left= sortList(head);
        ListNode right= sortList(half);
        return merge(left,right);
    }
    
    ListNode merge(ListNode left, ListNode right){
        ListNode dummy=new ListNode();
        ListNode current=dummy;
        while(left!=null && right!=null){
            if(left.val>=right.val){
                current.next=right;
                right=right.next;
                current=current.next;
            }else{
                current.next=left;
                left=left.next;
                current=current.next;
            }
        }
        if(left!=null){current.next=left;}
        if(right!=null){current.next=right;}
        return dummy.next;
    }
}

File: ReverseLinkedListBetweenAandB.txt
Question Type: LinkedList
DSA Question: DSA problem related to: ReverseLinkedListBetweenAandB
----------------------
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if (head == null) {
            return null;
        }
        ListNode dummy=new ListNode(-1);
        dummy.next=head;
        ListNode prev=dummy;
        int i=0;
        while(head!=null && m>1){
            m--;
            n--;
            prev=head;
            head=head.next;
        }
        prev.next=reverse(head,n);
        return dummy.next;
    }
    
    ListNode reverse(ListNode head,int n){
        if(head==null) return null;
        ListNode dummy=new ListNode();
        dummy.next=head;
        ListNode next=null,prev=null,curr=head;
        while(curr!=null && n>0){
            --n;
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        head.next=curr;
        return prev;
    }
}

File: ReverseList.txt
Question Type: LinkedList
DSA Question: DSA problem related to: ReverseList
----------------------
public class ReverseList{
	static void printAll(Node head){
		while(head!=null){
			System.out.print(head.data+"->");
			head=head.next;
		}
		System.out.print("\n");
	}
	//prev  current
	//null   //1       2 3 4 5 6
	static Node reverseList(Node head){
		Node current=head;
		Node prev=null;
		Node temp;
		while(current!=null){
			temp=current.next;
			current.next=prev;
			prev=current;
			current=temp;
		}
		head=prev;
		return head;
	}	

	public static void main(String args[]){
		Node head=new Node(1);
		head.next=new Node(2);
		head.next.next=new Node(3);
		head.next.next.next=new Node(4);
		head.next.next.next.next=new Node(5);
		head.next.next.next.next.next=new Node(6);
		head.next.next.next.next.next.next=new Node(7);
		
		printAll(head);		
		printAll(reverseList(head));	
	}
}

class Node{
	public int data;
	public Node next;

	public Node(){
		
	}
	public Node(int data){
		this.data=data;
		
	}
	public Node(int data,Node next){
		this.data=data;
		this.next=next;
	}
}

File: DeepCopyRandomPointer.txt
Question Type: LinkedList
DSA Question: DSA problem related to: DeepCopyRandomPointer
----------------------
//Deep Copy
/*
A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

Return a deep copy of the list.

The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:

val: an integer representing Node.val
random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.
*/
class Solution {
    public Node copyRandomList(Node head) {
        Node current=head;
        HashMap<Node,Node> map=new HashMap<>();
        while(current!=null){
            map.put(current,new Node(current.val));
            current=current.next;
        }
        current=head;
        Node temp=null;
        while(current!=null){
            temp=map.get(current);
            temp.next=map.get(current.next);
            temp.random=map.get(current.random);
            current=current.next;
        }
        return map.get(head);
    }
}

File: LinkedListCycleStartPoint.txt
Question Type: LinkedList
DSA Question: DSA problem related to: LinkedListCycleStartPoint
----------------------
/**
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) 
in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

Note: Do not modify the linked list
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head==null) return null;
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow) break;
        }
        if(fast==null || fast.next==null) return null;
        fast=head;
        while(fast!=slow){
            fast=fast.next;
            slow=slow.next;
            if(fast==slow)
            return fast;
        }
        return fast;
    }
}

File: MergeKSortedLinkedList.txt
Question Type: LinkedList
DSA Question: DSA problem related to: MergeKSortedLinkedList
----------------------
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode dummy=new ListNode();
        if(lists.length==0) return null;
        PriorityQueue<ListNode> pq=new PriorityQueue<>(new Comparator<ListNode>(){
            public int compare(ListNode n1,ListNode n2){
                return n1.val-n2.val;
            }            
        });
        for(ListNode node:lists){
            if(node!=null){
                pq.add(node);    
            }
        }
        ListNode curr=dummy;
        while(!pq.isEmpty()){
            ListNode node=pq.poll();
            curr.next=node;
            curr=curr.next;
            if(node.next!=null){
                pq.add(node.next);
            }
        }
        return dummy.next;
      
    }
}

File: SwapInPair.txt
Question Type: LinkedList
DSA Question: DSA problem related to: SwapInPair
----------------------
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null)return null;
        if(head.next==null)return head;
        ListNode current=head,next;
        head=head.next;
        ListNode prev=null;
        while(current!=null && current.next!=null){
            current = reverse(current,prev);
            prev=current.next;
            current=current.next.next;
        }
        return head;
    }
    
    ListNode reverse(ListNode current,ListNode prev){
        ListNode temp=current.next; 
        current.next=temp.next;
        temp.next=current;
        if(prev!=null)prev.next=temp;
        return temp;
    }
}

File: AddTwoNumber.txt
Question Type: LinkedList
DSA Question: DSA problem related to: AddTwoNumber
----------------------
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Queue<Integer> q1=new LinkedList<>(),q2=new LinkedList<>();
        while(l1!=null){
            q1.add(l1.val);
            l1=l1.next;
        }
        while(l2!=null){
            q2.add(l2.val);
            l2=l2.next;
        }
        ListNode dummy=new ListNode();
        ListNode temp=dummy;
        int carry=0;
        while(!q1.isEmpty() || !q2.isEmpty() || carry!=0){
            int x=q1.isEmpty()?0:q1.poll();
            int y=q2.isEmpty()?0:q2.poll();
            int sum=(x+y+carry)%10;
            carry=(x+y+carry)/10;
            temp.next=new ListNode(sum);
            temp=temp.next;
        }
        return dummy.next;
    }
}

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy=new ListNode();
        ListNode curr=dummy;
        int carry=0;
        while(l1!=null && l2!=null){
            int sum=carry+l1.val+l2.val;
            carry=0;
            curr.next=new ListNode(sum%10);
            carry=sum/10;
            l1=l1.next;
            l2=l2.next;
            curr=curr.next;
        }
        
        while(l1!=null){
            int sum=carry+l1.val;
            carry=0;
            curr.next=new ListNode(sum%10);
            carry=sum/10;
            l1=l1.next;
            curr=curr.next;
        }
        
        while(l2!=null){
            int sum=carry+l2.val;
            carry=0;
            curr.next=new ListNode(sum%10);
            carry=sum/10;
            l2=l2.next; 
            curr=curr.next;
        }
        
        if(carry!=0){
            curr.next=new ListNode(carry);
        }
        
        return dummy.next;
    }
}


File: MergeTwoSortedLinkedList.txt
Question Type: LinkedList
DSA Question: DSA problem related to: MergeTwoSortedLinkedList
----------------------
/*
Merge two sorted linked lists and return it as a new list. 
The new list should be made by splicing together the nodes of the first two lists.
 */
class Solution{
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode[] lists={l1,l2};
        return mergeKLists(lists);
        
    }
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode dummy=new ListNode();
        if(lists.length==0) return null;
        PriorityQueue<ListNode> pq=new PriorityQueue<>(new Comparator<ListNode>(){
            public int compare(ListNode n1,ListNode n2){
                return n1.val-n2.val;
            }            
        });
        for(ListNode node:lists){
            if(node!=null){
                pq.add(node);    
            }
        }
        
        ListNode curr=dummy;
        while(!pq.isEmpty()){
            ListNode node=pq.poll();
            curr.next=node;
            curr=curr.next;
            if(node.next!=null){
                pq.add(node.next);
            }
        }
        return dummy.next;
      
    }
}

class MergeTwoSortedLinkedList{
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode result=new ListNode();
        ListNode current=result;
        while(l1!=null && l2!=null){
            if(l1.val<=l2.val){
              current.next=l1;
              current=current.next;  
              l1=l1.next;   
            }
            else{
              current.next=l2;
              current=current.next;  
              l2=l2.next;   
            } 
        }
         while(l1!=null && l2!=null){
            if(l1.val<=l2.val){
              current.next=l1;
              current=current.next;  
              l1=l1.next;   
            }
            else{
              current.next=l2;
              current=current.next;  
              l2=l2.next;   
            } 
        }
         if(l1!=null){
              current.next=l1;
         }
         if(l2!=null){
              current.next=l2;
         }
        return result.next;
    }
}

File: RemoveNthFromEnd.txt
Question Type: LinkedList
DSA Question: DSA problem related to: RemoveNthFromEnd
----------------------
/*
Given a linked list, remove the n-th node from the end of list and return its head.
 */
class RemoveNthFromEnd{
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy=new ListNode();
        dummy.next=head;
        ListNode pointer1=dummy;
        ListNode pointer2=dummy;
        
        for(int i = 1;i<=n+1;++i){
            pointer1=pointer1.next;
        }
        while(pointer1!=null){
            pointer1=pointer1.next;
            pointer2=pointer2.next;
        }
        pointer2.next=pointer2.next.next;
        return dummy.next;
    }
}

File: SumOfSubset.txt
Question Type: BackTracking
DSA Question: DSA problem related to: SumOfSubset
----------------------
class Solution {
    int[] ans;
    public void SumOfSubset(int[] nums, int target) {
        ans=new int[nums.length];//000000
        int sum=0;
        for(int num:nums){
            sum=sum+num;
        }
        for(int i=0;i<nums.length;++i){
            DFS(sum,nums,i,target,0);            
        }
    }
    
    void DFS(int remainSum,int[] nums,int i,int target,int currSum){
        if(target==currSum){
            for(int z=0;z<ans.length;++z){
                System.out.print(ans[z]);
            }
            System.out.println("");
        }
        if(i==nums.length) return;
        if(remainSum<target-currSum) return;
        if(nums[i]+currSum<=target){
            ans[i]=1;
            DFS(remainSum-nums[i],nums,i+1,target,currSum+nums[i]);//selected
            ans[i]=0;
            DFS(remainSum,nums,i+1,target,currSum);//not selected
        }
    }
    
}

File: CombinationSum.txt
Question Type: BackTracking
DSA Question: DSA problem related to: CombinationSum
----------------------
class Solution {
    List<List<Integer>> combinations=new ArrayList<>();
    public List<List<Integer>> combinationSubSequenceSumEqulasTarget(int[] arr, int target) {
        ArrayList<Integer> list=new ArrayList<>();
        helper(arr,target,list,0);
        return combinations;
    }
    
    void helper(int[] arr,int target,ArrayList<Integer> list,int index){
        if(target<0) return;
        if(target==0){
            combinations.add(new ArrayList<Integer>(list));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i]){
                list.add(arr[i]);
                helper(arr,target-arr[i],list,i);
                list.remove(list.size()-1);                
            }
        }
    }
}

File: permutation.txt
Question Type: BackTracking
DSA Question: DSA problem related to: permutation
----------------------
public class permutation {

    public static void printPermutationShuffle(char[] arr){
        backTracking(arr,0);
    }

    static void backTracking(char[] arr,int index){//String is prepared before this index
        if(index==arr.length-1){
            System.out.println(String.valueOf(arr));
            return;
        }
        for(int i=index;i<arr.length;++i){
            swap(arr,i,index);
            backTracking(arr, index+1);
            swap(arr,i,index);
        }
    }
    
    private static void swap(char[] arr, int i, int index) {
        char temp=arr[i];
        arr[i]=arr[index];
        arr[index]=temp;
    }

    public static void main(String[] args) {
        printPermutation("123".toCharArray());
    }
}


File: combination.txt
Question Type: BackTracking
DSA Question: DSA problem related to: combination
----------------------
public class combination {
    public static void printCombinationSubString(char[] arr){
        System.out.println("");
        for(int i=0;i<arr.length;++i){
            backTracking(arr,i,arr[i]+"");
        }
    }

    static void backTracking(char[] arr,int index,String str){//String is prepared before this index
        System.out.println(str);
        if(index==arr.length-1) return;
        backTracking(arr, index+1, str+arr[index+1]);
    }
    
    public static void main(String[] args) {
        printCombination("123".toCharArray());
    }
}


File: SubArraySumEqualsK.txt
Question Type: BackTracking
DSA Question: DSA problem related to: SubArraySumEqualsK
----------------------
/*
Given an array of integers and an integer k, you need to find the total number of 
continuous subarrays whose sum equals to k.
*/
class Solution {  //Using Cumulative Sum Approcah i.e store sum of all the numbers --- o(n2)
    int count=0;
    public int subarraySum(int[] nums, int k) {
        int count=0;
        int[] sum=new int[nums.length+1];
        sum[0]=0;
        for(int i=1;i<=nums.length;++i){
            sum[i]=sum[i-1]+nums[i-1];
        }
        for(int start=0;start<nums.length;++start){
            for(int end=start+1;end<=nums.length;end++){
                if(sum[end]-sum[start]==k){
                    count++;
                }
            }
        }
        return count;
    }
}

File: AllPathsFromSorceToDst.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Solution {
    List<List<Integer>> ans=new ArrayList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        boolean[] visited=new boolean[graph.length];
        LinkedList<Integer> s=new LinkedList<>();
        s.add(0);
        DFS(graph,0,s,visited);
        return ans;
    }
    
    void DFS(int[][] graph,int u,LinkedList<Integer> s,boolean[] visited){
        visited[u]=true;
        if(u==graph.length-1){
            ans.add(new ArrayList<Integer>(s));
            visited[u]=false;
            return;
        }
        for(int v:graph[u]){
            if(visited[v]==false){
                s.add(v);
                DFS(graph,v,s,visited);
                s.remove(s.size()-1);
            }
        }
        visited[u]=false;
    }
    
}

File: ShortestPathInBinaryMatrix.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        if(grid.length==0) return -1;
        if(grid[0][0]==1) return-1;
        return hasPath(grid,new int[]{0,0},new int[]{grid.length-1,grid[0].length-1},0);
    }
    boolean isSafe(int[] v,int[][] maze){
        return v[0]>=0 && v[0]<maze.length && 
            v[1]>=0 && v[1]<maze[0].length && maze[v[0]][v[1]]==0;
    }
    
    public int hasPath(int[][] maze, int[] start, int[] destination,int level) {
        Queue<int[]> q=new LinkedList<>();
        boolean[][] visited=new boolean[maze.length][maze[0].length];
        q.add(start);
        int[] x={0,0,1,-1,1,-1,1,-1};
        int[] y={1,-1,0,0,1,-1,-1,1};
        while(!q.isEmpty()){
            int size=q.size();
            ++level;
            for(int m=0;m<size;++m){
                int[] u=q.poll();
                visited[u[0]][u[1]]=true;
                if(destination[0]==u[0]&&destination[1]==u[1]){
                    return level;
                }
                for(int i=0;i<x.length;++i){
                    int[] v=new int[]{u[0]+x[i],u[1]+y[i]};
                    if(isSafe(v,maze) && visited[v[0]][v[1]]!=true){
                        q.add(v);
                    }
                }                
            }
        }
        return -1;
    }
}



File: CycleDetectionCourseScheduleTopologicalSortDAG.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
/*
There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, 
which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to 
finish all courses?
*/
class Solution {
    public boolean canFinish(int numCourses, int[][] courses) {
        Integer[] inDegree=new Integer[numCourses];
        for(int i=0;i<numCourses;++i){
            inDegree[i]=0;
        }
        List<List<Integer>> graph=new LinkedList<>();
        for(int i=0;i<numCourses;++i){
            graph.add(new LinkedList<Integer>());
        }
        for(int i=0;i<courses.length;++i){
            graph.get(courses[i][1]).add(courses[i][0]);
            inDegree[courses[i][0]]++;
        }
        Boolean visited[]=new Boolean[numCourses];
        Queue<Integer> queue=new LinkedList<>();
        for(int i=0;i<inDegree.length;++i){
            if(inDegree[i]==0){
                queue.add(i);
                visited[i]=true;
            }
        }
        while(!queue.isEmpty()){
            int curr=queue.poll();
            for(int i=0;i<graph.get(curr).size();++i){
                int j=graph.get(curr).get(i);
                if(visited[j]==null){
                    --inDegree[j];
                    if(inDegree[j]==0){
                        queue.add(j);
                        visited[j]=true;
                    }
                }
            }
        }
        for(int i=0;i<inDegree.length;++i){
            if(inDegree[i]!=0) return false;
        }
        return true;
    }
}

File: CriticalConnections.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
/*
There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.

A critical connection is a connection that, if removed, will make some server unable to reach some other server.

Return all critical connections in the network in any order.
*/
class Solution {
    int time=0;
    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        int[] visitTime=new int[n];
        int[] lowTime=new int[n];
        boolean visited[]=new boolean[n];
        List<List<Integer>> result=new ArrayList<>();
        ArrayList<Integer>[] graph=new ArrayList[n];
        for(int i=0;i<graph.length;++i){
            graph[i]=new ArrayList<Integer>();
        }
        for(List<Integer> connection: connections){
            int a=connection.get(0),b=connection.get(1);
            graph[a].add(b); graph[b].add(a);
        }
        for(int i=0;i<n;i++){
            visited[i]=false;
        }
        DFS(graph,visited,0,-1,lowTime,visitTime,result);
        return result;            
    }
    
    void DFS(ArrayList<Integer>[] graph,boolean visited[],Integer currentNode,Integer parentNode
            ,int[] lowTime,int[] visitTime,List<List<Integer>> result){
        visited[currentNode]=true;
        visitTime[currentNode]=lowTime[currentNode]=time++;
        for(int nhbr:graph[currentNode]){
            if(nhbr==parentNode){continue;}
            else if(!visited[nhbr]){
                DFS(graph,visited,nhbr,currentNode,lowTime,visitTime,result);
                lowTime[currentNode]=Math.min(lowTime[currentNode],lowTime[nhbr]); 
                if(visitTime[currentNode]<lowTime[nhbr]){
                    result.add(Arrays.asList(currentNode,nhbr));
                }
            }else{
               lowTime[currentNode]=Math.min(lowTime[currentNode],lowTime[nhbr]); 
            }
        }
    }
        
}

File: BFSAndDFSTraversal.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;

//1       level 1
//0 3 4   level 2
//4       level 3
//1       level 4
//2 1     level 5
//BFS print level by level
public class BFSAndDFSTraversal{
	
	static void doBFSTraverse(ArrayList<ArrayList<Integer>> matrix,int v,int source,Boolean [] visited){
		System.out.print("BFS traverse");
		Queue<Integer> q=new LinkedList<Integer>();
		q.add(source);
		visited[source]=true;
		while(!q.isEmpty()){
			int u=q.poll();
			System.out.print(u+"-");
			for(int i=0;i<matrix.get(u).size();++i){
				if(visited[matrix.get(u).get(i)]==null || 
					!visited[matrix.get(u).get(i)]){
					q.add(matrix.get(u).get(i));
					visited[matrix.get(u).get(i)]=true;
				}
			}
		}
	}

	
	static void BFSHandleDisconnectedCases(ArrayList<ArrayList<Integer>> matrix,int v){
		Boolean [] visited=new Boolean[v];
		for(int source=0;source<v;++source){
			if(visited[source]==null || visited[source]==false){
			doBFSTraverse(matrix,v,source,visited);
			}
		}
	}

	static void doDFSTraverse(ArrayList<ArrayList<Integer>> matrix,int v,int source,Boolean [] visited){
		System.out.print(source+"-");
		visited[source]=true;
			for(int i=0;i<matrix.get(source).size();++i){
				if(matrix.get(source).size()!=0 &&
				  (visited[matrix.get(source).get(i)]==null || !visited[matrix.get(source).get(i)])){
				doDFSTraverse(matrix,v,matrix.get(source).get(i),visited);
				
			}
		}
	}

	static void DFSHandleDisconnectedCases(ArrayList<ArrayList<Integer>> matrix,int v){
		System.out.print("\nDFS traverse");
		Boolean [] visited=new Boolean[v];
		for(int source=0;source<v;++source){
			if(visited[source]==null || visited[source]==false){
			doDFSTraverse(matrix,v,source,visited);
			}
		}
	}

	public static void main(String args[]){
		int v=4;
		GraphUsingList graphUsingList=new GraphUsingList(v);
		graphUsingList.addEdge(0,1);
		graphUsingList.addEdge(1,2);
		graphUsingList.addEdge(2,0);
		graphUsingList.addEdge(2,3);
		graphUsingList.addEdge(3,3);

		graphUsingList.printMatrix();
		
		ArrayList<ArrayList<Integer>> matrix=graphUsingList.matrix;

		BFSHandleDisconnectedCases(matrix,v);

		DFSHandleDisconnectedCases(matrix,v);

		System.out.println("\nDFS from source 2");
		Boolean [] visited=new Boolean[v];
		doDFSTraverse(matrix,v,2,visited);
		
	}

}

File: GraphUsingMatrix.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
public class GraphUsingMatrix{
	public static Boolean matrix[][];
	public static int v;
	
	public GraphUsingMatrix(int v){
		this.v=v;
		this.matrix=new Boolean[v][v];
	}

	public static void addEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			matrix[i][j]=true;
			matrix[j][i]=true;
		}
	}

	public static void removeEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			matrix[i][j]=true;
			matrix[j][i]=true;
		}
	}
	
	public static Boolean isEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			return matrix[i][j]=true;
		}else{
		return false;
		}
	}
	
	//o(n2)- brute force
	public static void printMatrix(){  
		for(int i=0;i<v;++i){
			for(int j=0;j<v;++j){
			System.out.print((matrix[i][j]!=null&&matrix[i][j]?1:0)+" ");			
			}
			System.out.print("\n");
		}
	}
	
	public static void main(String args[]){
		GraphUsingMatrix graphUsingMatrix=new GraphUsingMatrix(3);
		graphUsingMatrix.addEdge(1,1);
		graphUsingMatrix.printMatrix();
	}

}

File: ShortestPathSourceToDestinationBST.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
public void shortestPath(Integer a, Integer b,List<Integer>[] graph) {
    if (a == null || b == null) return null;
    if (a == b) return null;
        
    Queue<Integer> toVisit = new LinkedList<Integer>();
    HashMap<Integer, Integer> parents = new HashMap<Integer, Integer>();
        
    toVisit.add(a);
    parents.put(a, null);
        
    while (!toVisit.isEmpty()) {
        Integer curr = toVisit.remove();
        if (curr == b) break;
        for (Integer n : curr.children) {
            if (!parents.containsKey(n)) {
                toVisit.add(n);
                parents.put(n, curr);
            }
        }
    }
    if (parents.get(b) == null) return null;
    Integer n = b;
    while (n != null) {
        System.out.print(n+"<-");
        n = parents.get(n);
    }
        
    return ;
}

File: GraphUsingList.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
import java.util.ArrayList;

public class GraphUsingList{
	public static ArrayList<ArrayList<Integer>> matrix;	
	static int v;

	public GraphUsingList(int v){
		this.v=v;
		this.matrix=new ArrayList<> (v);
		for(int i=0;i<v;++i){
			this.matrix.add(new ArrayList<>());
		}
	}

	public static void addEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			if(!matrix.get(i).contains(j)){
				matrix.get(i).add(j);
			}
			if(!matrix.get(j).contains(i)){
				matrix.get(j).add(i);
			}
			
		}
	}

	public static void addDirectedEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			if(!matrix.get(i).contains(j)){
				matrix.get(i).add(j);
			}			
		}
	}
	public static void deleteEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			for(int first=0;first<matrix.get(i).size();++first){
				if(matrix.get(i).get(first)==j){
					matrix.get(i).remove(first);
					break;		
				}
			}
			for(int second=0;second<matrix.get(j).size();++second){
				if(matrix.get(j).get(second)==i){
					matrix.get(j).remove(second);
					break;
				}
			}
		}
	}


	//o(n2)- brute force
	public static void printMatrix(){  
		for(int i=0;i<v;++i){
			System.out.println(matrix.get(i));
		}
	}
	
	public static void main(String args[]){
		GraphUsingList graphUsingList=new GraphUsingList(3);
		graphUsingList.addEdge(0,1);
		graphUsingList.addEdge(1,2);
		graphUsingList.addEdge(1,0);
		graphUsingList.printMatrix();
		graphUsingList.deleteEdge(1,0);
		System.out.println("after deleting");
		graphUsingList.printMatrix();

	}

}

File: FindTheJudge.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
/*
In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.
*/
class Solution {
    public int findJudge(int N, int[][] trust) {
        if(trust.length==0 && N==1){
            return 1;
        }    
        List<List<Integer>> graph=new LinkedList<>();
        List<Integer> possibleJudges=new LinkedList<>();
        Integer count[] =new Integer[N+1];
        for(int i=0;i<N;++i){
            graph.add(new LinkedList<Integer>());
        }
        
        for(int i=0;i<trust.length;++i){
            count[trust[i][1]]=count[trust[i][1]]==null?1:count[trust[i][1]]+1;
            if(count[trust[i][1]]==N-1){possibleJudges.add(trust[i][1]);}
            graph.get(trust[i][0]-1).add(trust[i][1]);
        }
        for(int i=0;i<possibleJudges.size();++i){
            if(graph.get(possibleJudges.get(i)-1).size()==0) return possibleJudges.get(i); 
        }
        return -1;
    }
}

File: Dijkstra.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Dijikstra
public static void main(String[] args){
        int[][] graph= {{0,2,4,0,0,0},  //zero means no edge,+ve value means weight of the edge 
                        {0,0,1,7,0,0},
                        {0,0,0,0,3,0},
                        {0,0,0,0,0,1},
                        {0,0,0,2,0,5},				
                        {0,0,0,0,0,0}};
        Integer[] dist=new Integer[graph.length];
        dist[source]=0;
        PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>(){
                public int compare(Integer ob1,Integer ob2){
                    int d1=	dist[ob1]==null?Integer.MAX_VALUE:dist[ob1];
                    int d2=	dist[ob2]==null?Integer.MAX_VALUE:dist[ob2];
                    return d1-d2;
                }});

        Set<Integer> map=new HashSet<Integer>();
        for(int i=0;i<graph.length;++i){
            map.add(i);
            pq.add(i);			
        }
        while(!pq.isEmpty()){
            int u=pq.peek();
            System.out.print(u);
            map.remove(u);			
            for(int v=0;v<graph.length;++v){
                if(graph[u][v]!=0){
                    dist[v]=Math.min(dist[v]==null? Integer.MAX_VALUE:dist[v],dist[u]+graph[u][v]);					
                }
            }
            int removed=pq.poll();
        }
        System.out.println(dist);
 }


File: AllPathsFromSourceToTarget.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Solution {
    List<List<Integer>> paths=new ArrayList<>();
    boolean visited[] ;
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        if(graph.length==0) return paths;
        visited =new boolean[graph.length];
        int src=0;
        int des=graph.length-1;
        List<Integer> path=new ArrayList<>();
        path.add(src);
        DFS(src,des,graph,path);
        return paths;
    }
    
    void DFS(int currNode,int des,int[][] graph,List<Integer> path){
        visited[currNode]=true;
        if(des==currNode){
            paths.add(new ArrayList<>(path));
        }else{
            for(int neighbour:graph[currNode]){
                if(visited[neighbour]==false){
                    path.add(neighbour);
                    DFS(neighbour,des,graph,path);
                    path.remove(path.size()-1);
                }
            }
        }
        visited[currNode]=false;
    }
}

File: GraphValidTree.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
/*
Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.
*/
class Solution {
    Boolean ans=true;
    public boolean validTree(int n, int[][] edges) {
        List<Integer>[] graph=new ArrayList[n];
        buildGraph(graph,edges);
        boolean[] visited=new boolean[n];
        DFS(graph,0,-1,visited);
        if(ans){
            for(int i=0;i<visited.length;++i){
                if(!visited[i]){
                    return false;
                }
            }
        }
        return ans;
    }
    
    void DFS(List<Integer>[] graph,int currentNode,int parentNode,boolean[] visited){
        visited[currentNode]=true;
        if(ans){
            for(int neighbour:graph[currentNode]){
                if(neighbour==parentNode) continue;
                else if(visited[neighbour]==false){
                    DFS(graph,neighbour,currentNode,visited);
                }else{//Cycle exist
                    ans=false;
                    return;
                }
            }            
        }

    }
    
    void buildGraph(List<Integer>[] graph,int[][] edges){
        for(int i=0;i<graph.length;++i){
            graph[i]=new ArrayList<>();
        }
        for(int[] edge: edges){
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
    }
}

File: FindOrderingOfAlienDictionary.txt
Question Type: TopologicalSorting
DSA Question: Write an algorithm to sort an array.
----------------------
/*
Input: Words: ["ba", "bc", "ac"]
Output: bac

Input: Words: ["cab", "aaa", "aab"]
Output: cab
*/
void printOrderOfAlienDictionary(String[] words){
    Map<Character,Set<Character>> graph=new HashMap<>();
    Map<Character,Integer> inDegree=new HashMap<>();
    for(int i=0;i<words.length-1;++i){
        char[] first=words[i].toCharArray();
        char[] scond=words[i+1].toCharArray();
        for(int j=0;j<Math.min(first.length,scond.length);++i){
             char firstC=first[j];
             char scondC=scond[j];
             if(!graph.containsKey(firstC)){
                graph.put(firstC,new HashSet<Character>());
             } 
             if(!graph.containsKey(scondC)){
                graph.put(scondC,new HashSet<Character>());
             } 
             if(firstC!=scondC){
                graph.get(firstC).add(scondC);
                inDegree.put(scondC.inDegree.getOrDefault(scondC,0)+1);
                break;
             }
        }
    }
    //Do Topological Sorting on the maps
}

File: TopologicalSort.txt
Question Type: TopologicalSorting
DSA Question: Write an algorithm to sort an array.
----------------------
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList;

public class TopologicalSort{

	static void doBFSTraverseTopologicalSort(ArrayList<ArrayList<Integer>> matrix,int v){
		System.out.print("BFS traverse - Topological Sort - Khann Algorithm");
		Integer [] indegree=new Integer [v];
		for(int i=0;i<indegree.length;++i){
			indegree[i]=0;
		}
		for(int i=0;i<indegree.length;++i){
			for(int j=0;j<matrix.get(i).size();++j){
				indegree[matrix.get(i).get(j)]++;	
			}
		}
		Queue<Integer> q=new LinkedList<Integer>();
		for(int i=0;i<v;++i){
			if(indegree[i]==0){
				q.add(i);			
			}
		}

		while(!q.isEmpty()){
			int u=q.poll();
			System.out.print(u+"-> ");
			for(int i=0;i<matrix.get(u).size();++i){
				indegree[matrix.get(u).get(i)]--;
				if(indegree[matrix.get(u).get(i)]==0){
					q.add(matrix.get(u).get(i));
				}
			}
		}
	}

	public static void main(String args[]){
		int v=6;
		GraphUsingList g=new GraphUsingList(v);

 	          g.addDirectedEdge(5, 2); 
      		  g.addDirectedEdge(5, 0); 
      		  g.addDirectedEdge(4, 0); 
      		  g.addDirectedEdge(4, 1); 
      		  g.addDirectedEdge(2, 3); 
      		  g.addDirectedEdge(3, 1);

		g.printMatrix();
		
		ArrayList<ArrayList<Integer>> matrix=g.matrix;

		doBFSTraverseTopologicalSort(matrix,v);
	}

}

File: Maze.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Solution {
    boolean isSafe(int[] v,int[][] maze){
        return v[0]>=0 && v[0]<maze.length && 
            v[1]>=0 && v[1]<maze[0].length && maze[v[0]][v[1]]==0;
    }
    
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        Queue<int[]> q=new LinkedList<>();
        boolean[][] visited=new boolean[maze.length][maze[0].length];
        q.add(start);
        int[] x={0,0,1,-1};
        int[] y={1,-1,0,0};
        while(!q.isEmpty()){
            int[] u=q.poll();
            visited[u[0]][u[1]]=true;
            if(destination[0]==u[0]&&destination[1]==u[1]){
                boolean isBlocked=false;
                for(int i=0;i<x.length;++i){
                    int[] m=new int[]{u[0]+x[i],u[1]+y[i]};
                    if(isSafe(m,maze)){
                        if(visited[m[0]][m[1]]==false){
                            return false;
                        }
                    }
                }
                return true;
            }
            for(int i=0;i<x.length;++i){
                int[] v=new int[]{u[0]+x[i],u[1]+y[i]};
                if(isSafe(v,maze) && visited[v[0]][v[1]]!=true){
                    q.add(v);
                }
            }
        }
        return false;
    }
}

File: Maximum Element In Sliding Window.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: Maximum Element In Sliding Window
----------------------
/*
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.
Follow up:
Could you solve it in linear time?
Example:

Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
 */
class Solution {
    //0 1 2// 3 4 5
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans=new int[nums.length-k+1];
        ArrayDeque<Integer> dq=new ArrayDeque<>();
        for(int i=0;i<k;++i){
            while(!dq.isEmpty() && nums[dq.getLast()]<=nums[i]){
                dq.removeLast();
            }
            dq.addLast(i);
        }
        ans[0]=nums[dq.getFirst()];
        for(int i=k;i<nums.length;++i){
            int firstDQ=dq.getFirst();
            while(!dq.isEmpty() && firstDQ<= i-k){
                dq.removeFirst();
                firstDQ=dq.isEmpty()?-1:dq.getFirst();
            }
            while(!dq.isEmpty() && nums[dq.getLast()]<=nums[i]){
                dq.removeLast();
            }
            dq.addLast(i);
            ans[i-k+1]=nums[dq.getFirst()];
        }
        return ans;
    }
}

File: Minimum Window SubString.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: Minimum Window SubString
----------------------
class Pair {
  int l = -1;
  int h = -1;
}

class Solution {
  public String minWindow(String s, String t) {
    if (s == null || t == null || s.length() == 0 || t.length() == 0)
      return "";
    Pair resultIndex = new Pair();
    int charsToCount = t.length();
    HashMap<Character, Integer> map = new HashMap<>();
    for (char c : t.toCharArray()) {
      map.put(c, map.getOrDefault(c, 0) + 1);
    }
    int l = 0;
    for (int h = 0; h < s.length(); ++h) {
      if (charsToCount > 0) {
        if (map.containsKey(s.charAt(h))) {
          int countPending = map.get(s.charAt(h));
          map.put(s.charAt(h), map.get(s.charAt(h)) - 1);
          if (countPending > 0) {
            charsToCount--;
            // map.put(s.charAt(h),map.get(s.charAt(h))-1);
          }
        }
      }
      while (charsToCount == 0) {
        char cl = s.charAt(l);
        if (map.containsKey(cl)) {
          map.put(cl, map.get(cl) + 1);
          int countPending = map.get(cl);
          if (countPending > 0) {

            charsToCount++;
          }
        }
        if ((resultIndex.h == -1 && resultIndex.l == -1) || resultIndex.h - resultIndex.l > h - l) {
          resultIndex.h = h;
          resultIndex.l = l;
        }

        ++l;
      }
    }

    if (resultIndex.l == -1) {
      return "";
    }

    return s.substring(resultIndex.l, resultIndex.h + 1);
  }
}


class Solution {
    public String minWindow(String txt, String pat) {
        int textLen=txt.length();
        int patLen=pat.length();
        int[] needToFind=new int[256];
        for(int i=0;i<patLen;++i){
            needToFind[pat.charAt(i)]++;
        }
        int[] hasFound=new int[256];
        int minWindLen=Integer.MAX_VALUE;
        int minWinBegin=0;
        int minWinEnd=0;
        int count=0;
        for(int begin=0,end=0;end<textLen;end++){
            if(needToFind[txt.charAt(end)]==0) continue;
            hasFound[txt.charAt(end)]++;
            if(hasFound[txt.charAt(end)]<=needToFind[txt.charAt(end)]){
                ++count;
            }
            if(count==patLen){
                while(needToFind[txt.charAt(begin)]==0 || 
                      hasFound[txt.charAt(begin)]>needToFind[txt.charAt(begin)]){
                    if(hasFound[txt.charAt(begin)]>needToFind[txt.charAt(begin)]){
                      hasFound[txt.charAt(begin)]--;  
                    }
                    begin++;
                }
                int windowLen = end - begin +1;
                if(windowLen<minWindLen){
                    minWinBegin=begin;
                    minWinEnd=end;
                    minWindLen=windowLen;
                }
            }
        }
        return  count==patLen?txt.substring(minWinBegin,minWinEnd+1):"";
    }
}

class Solution {
    public String minWindow(String s, String t) {
        Map<Character,Integer> dict=new HashMap<>();
        for(char chr:t.toCharArray()){
            dict.put(chr,dict.getOrDefault(chr,0)+1);
        }
        Map<Character,Integer> map=new HashMap<>();
        int l=0;
        int matchCount=0;
        String ans="";
        int matchSubStringLength=Integer.MAX_VALUE;
        for(int h=0;h<s.length();++h){
            char currChar=s.charAt(h);
            map.put(currChar,map.getOrDefault(currChar,0)+1);
            if(dict.containsKey(currChar) && map.get(currChar)<=dict.get(currChar)){
                matchCount++;
            }
            while(matchCount==t.length()){
                if(matchCount==t.length() && (h-l+1)<matchSubStringLength){
                    ans=s.substring(l,h+1);
                    matchSubStringLength=ans.length();
                }
                char charAtL=s.charAt(l);
                if(map.containsKey(charAtL)){
                    if(dict.containsKey(charAtL) && map.get(charAtL)<=dict.get(charAtL)){
                        --matchCount;                        
                    }
                    map.put(charAtL,map.get(charAtL)-1);
                    if(map.get(charAtL)==0){
                        map.remove(charAtL);
                    }
                }
                ++l;
                while(l<s.length() && !dict.containsKey(s.charAt(l))  && l<h){
                    ++l;
                }
            }
        }
        return ans;
    }
}


File: MinWindowWithSumOrGreater.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: MinWindowWithSumOrGreater
----------------------
class MinSizeSubArraySum {
    public static int findMinSubArray(int S, int[] arr) {
      int wSize=Integer.MAX_VALUE;
      int l=0;
      int sum=0;
      for(int h=0;h<arr.length;++h){
        sum=sum+arr[h];
        while(sum>=S){
            int winL=h-l+1;
            wSize=Math.min(wSize,winL);
            sum=sum-arr[l];
            l++;
        }
      }
      return wSize;
    }
  }

File: LongestSubStringWithAtOnlyKDistictChacaters.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: LongestSubStringWithAtOnlyKDistictChacaters
----------------------
//araaci       1
class LongestSubstringKDistinct {
    public static int findLength(String str, int k) {
      int count=0;
      int l=0;
      int winM=0;  
      HashMap<Character,Integer> map=new HashMap<>();
  
      for(int h=0;h<str.length();++h){
        Character curr=str.charAt(h);
        if(map.containsKey(curr)){
          map.put(curr,map.get(curr)+1);
        }
        else{
          ++count;
            map.put(curr,1);
          while(map.size()>k && l<str.length()){
            char temp=str.charAt(l);
            map.put(temp,map.getOrDefault(temp,0)-1);
            if(map.get(temp)<=0){
              map.remove(temp);
            }
            l++;
          }
        }
        winM=Math.max(winM,h-l+1);
      }
      return winM;
    }
  }

File: LongestSubStringWithoutRepeatingCharacter.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: LongestSubStringWithoutRepeatingCharacter
----------------------
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==0) return 0;
        HashMap<Character,Integer> map=new HashMap<>();
        int l=0;
        int ans=-1;
        int h;
        for(h=0;h<s.length();++h){
            char currChar=s.charAt(h);
            if(map.containsKey(currChar)){
                int oldIndex=map.get(currChar);
                if(oldIndex>=l){
                    ans=Math.max(ans,h-1-l+1);
                    l=oldIndex+1;
                }
            }
            map.put(currChar,h);
        }
        return Math.max(h-1-l+1,ans);
    }   
        
}

public static int findLength(String str) {
    int l=0;
    int winM=0;
    HashMap<Character,Integer> map=new HashMap<>();
    for(int h=0;h<str.length();++h){
      Character curr=str.charAt(h);
      if(!map.containsKey(curr)){
        map.put(curr,h);
        winM=Math.max(winM,h-l+1);
      }else{
        l=Math.max(l,map.get(curr)+1);
        map.put(curr,h);
        winM=Math.max(winM,h-l+1);
      }
    }
    return winM;
  }

  public static int findLength(char[] arr) {
    int max=0; 
    int l=0;
    HashMap<Character,Integer> map=new HashMap<>();
    for(int h=0;h<arr.length;++h){
       if(!map.containsKey(arr[h])){
           map.put(arr[h],h);
       }else{
           l=Math.max(l,map.get(arr[h]))+1;
           map.put(arr[h],h);
       }
       max=Math.max(max,h-l+1);
    }
    return max;
}


File: FruitTwoBasketMaxCount.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: FruitTwoBasketMaxCount
----------------------
public static int findLength(char[] arr) {
    HashMap<Character,Integer> map=new HashMap<>();
       int l=0;
    int max=0;
       for(int h=0;h<arr.length;++h){
             if(map.keySet().size()<2){
               map.put(arr[h],map.getOrDefault(arr[h],0)+1);
             }
             else if(map.keySet().size()==2 && !map.containsKey(arr[h])){
               map.remove(arr[l++]);
                map.put(arr[h],1);
             }else if(map.containsKey(arr[h])){
           map.put(arr[h],map.getOrDefault(arr[h],0)+1);
       }
       int temp=0;
       for(int v:map.values()){
           temp=temp+v;
       }
       max=Math.max(max,temp);
       }
      return max;
 }



File: MinWindowWithExactSum.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: MinWindowWithExactSum
----------------------
class MinSizeSubArraySum {
    public static int findMinSubArray(int S, int[] arr) {
      int wSize=Integer.MAX_VALUE;
      int l=0;
      int sum=0;
      for(int h=0;h<arr.length;++h){
        sum=sum+arr[h];
        int winL=h-l+1;
        if(sum==S){
          wSize=Math.min(wSize,winL);
          sum=sum-arr[l];
          l++;
        }else if(sum>S){
          while(sum>S){
            sum=sum-arr[l];
            l++;
          }
          if(sum==S){
            winL=h-l+1;
            wSize=Math.min(wSize,winL);
            sum=sum-arr[l];
            l++;
          }
        }
      }
      return wSize;
    }

File: MinMeetingRooms.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: MinMeetingRooms
----------------------
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals.length==0) return 0;
        PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>(){
           public int compare(Integer o1,Integer o2){
               return o1-o2; 
           }
        });
        Arrays.sort(intervals,new Comparator<int[]>(){
           public int compare(int[] o1,int[] o2){
               return o1[0]-o2[0]; 
           }
        });
        pq.add(intervals[0][1]);
        for(int i=1;i<intervals.length;++i){
            if(pq.peek()<=intervals[i][0]){
                pq.poll();
            }
            pq.add(intervals[i][1]);
        }
        return pq.size();
    }
}

File: MergeIntervals.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: MergeIntervals
----------------------
//Given a collection of intervals, merge all overlapping intervals.
class PairComparator implements Comparator<int[]>{ 
    public int compare(int[] p1, int[] p2) { 
        return p1[0]-p2[0];
    } 
} 
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length==0) return intervals;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] ob1,int[] ob2){
                return ob1[0]-ob2[0];
            }
        });
        LinkedList<int[]> list=new LinkedList<>();
        list.add(intervals[0]);
        for(int i=1;i<intervals.length;++i){
            if(list.get(list.size()-1)[1]>=intervals[i][0]){
                list.get(list.size()-1)[1]=Math.max(intervals[i][1],list.get(list.size()-1)[1]);
            }else{
                list.add(intervals[i]);    
            }
        }
        return list.toArray(new int[list.size()][]);
    }
}

File: CanPersonAttenndAllMeetings.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: CanPersonAttenndAllMeetings
----------------------
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        if(intervals.length==0) return true;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int ob1[],int ob2[]){
                return ob1[0]-ob2[0];
            }
        });
         PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer ob1,Integer ob2){
                return ob1-ob2;
            } 
         });
        pq.add(intervals[0][1]);
        for(int i=1;i<intervals.length;++i){
            if(pq.peek()>intervals[i][0]) {return false;}
            else{
                pq.poll(); pq.add(intervals[i][1]);
            }
        }
        return true;
    }
}

File: BoatCountToSavePeople.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: BoatCountToSavePeople
----------------------
/*
The i-th person has weight people[i], and each boat can carry a maximum weight of limit.

Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.

Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)

 */
class Solution {
    public int numRescueBoats(int[] arr, int limit) {
        Arrays.sort(arr);
        int l=0,h=arr.length-1;
        int count=0;
        while(l<=h){
            ++count;
            if(arr[l]+arr[h]<=limit){
                ++l;
            }
            --h;
        }
        return count;
    }
}

File: MeetingRoomsII.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: MeetingRoomsII
----------------------
/*
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.
*/
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals.length==0) return 0;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int [] b){
                return a[0]-b[0];
            }
        });
        PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer a,Integer  b){
                return intervals[a][1]-intervals[b][1];
            }            
        });
        pq.add(0);
        for(int i=1;i<intervals.length;++i){
            if(intervals[pq.peek()][1]<=intervals[i][0]){
                pq.poll();
            } 
            pq.add(i);
        }
        
        return pq.size();
    }
}


File: JumpGame.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: JumpGame
----------------------
/*
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.
*/
class Solution {
    Boolean result[]=null;
    public boolean canJump(int[] nums) {
        result=new Boolean[nums.length+1];
        return helper(nums,0);
    }
    
    boolean helper(int[] nums,int i){
        if(i==nums.length-1) return true;
        if(result[i]!=null) return result[i];
        for(int j=1;j<=nums[i];++j){
            if(helper(nums,i+j)) return result[i]=true;
        }
        return result[i]=false;
    }
}

class Solution {
    boolean memo[];
    public boolean canJump(int[] nums) {
        memo=new boolean[nums.length];
        memo[nums.length-1]=true;
        for(int i=nums.length-2;i>=0;--i){
            for(int j=1;j<=nums[i];++j){
                if(i+j<nums.length && memo[i+j]==true){
                    memo[i]=true;
                    break;
                }
            }
        }
        return memo[0];
    }
}

class Solution {
    public boolean canJump(int[] nums) {
        int lastGood=nums.length-1;
        for(int i=nums.length-1;i>=0;--i){
            if(i+nums[i]>=lastGood){
                lastGood=i;
            }    
        }
        return lastGood==0;
    }
}

class Solution {   //Jump Games2              
    public int jump(int[] nums) {
        int jump=0;
        int maxPos=0;
        int nextIndex=0;
        for(int i=0;i<nums.length-1;++i){
            maxPos=Math.max(maxPos,i+nums[i]);
            if(i==nextIndex){
                nextIndex=maxPos;
                ++jump;
            }
        }
        return jump;
    }
}

File: BestTimeToSleep.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: BestTimeToSleep
----------------------
import java.util.*;
class Solution {
    public int solution(String S) {
        String[] strs=S.split("\n");
        HashMap<String,Integer> priority=new HashMap<>();
        priority.put("Sun",7);
        priority.put("Sat",6);
        priority.put("Fri",5);
        priority.put("Thu",4);
        priority.put("Wed",3);
        priority.put("Tue",2);
        priority.put("Mon",1);
        Arrays.sort(strs,new Comparator<String>(){
            public int compare(String ob1,String ob2){
                String[] s1=ob1.split(" ");
                String[] s2=ob2.split(" ");
                if(priority.get(s1[0])==priority.get(s2[0])){
                    return getMin(s1[1].split("-")[0])-getMin(s2[1].split("-")[0]);
                }
                return priority.get(s1[0])-priority.get(s2[0]);
            }
        });
        int maxBreak=getMin(strs[0].split(" ")[1].split("-")[0]);
        for(int i=0;i<strs.length-1;++i){
            int first=getMin(strs[i].split(" ")[1].split("-")[1]);
            int secound=getMin(strs[i+1].split(" ")[1].split("-")[0]);
            int curr=0;
            if(strs[i].split(" ")[0].equals(strs[i+1].split(" ")[0])){
                curr=secound-first;
            }else{
                curr=getMin("24:00")-first+secound;
            }
            maxBreak=Math.max(maxBreak,curr);
        }
        maxBreak=Math.max(maxBreak,getMin("24:00")-getMin(strs[strs.length-1].split(" ")[1].split("-")[1]));
        return maxBreak;
    }
    
    int getMin(String str){
        String[] arr=str.split(":");
        int min=Integer.parseInt(arr[0])*60;
        min=min+Integer.parseInt(arr[1]);
        return min;
    }
}

File: TrainPlatormCount.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: TrainPlatormCount
----------------------
int platformCount(int[][] rail){
    Arrays.sort(rail,new Comparator<int[]>(){
    public int compare(int[] ob1,int[] ob2){
        return ob1[0]-ob2[0];
    }
     });
     PriorityQueue<int[]> pq=new PriorityQueue<>(new Comparator<int[]>(){
    public int compare(int[] ob1,int[] ob2){
        return ob1[1]-ob2[1];
    }	
     });
     pq.add(rail[0]);
     for(int i=1;i<rail.length;++i){
    if(pq.peek()[1]>rail[i][0]){
        pq.add(rail[i]);
    }else{
        int[] poll=pq.poll();
        pq.add(rail[i]);
    }
     }
     return pq.size();
} 

File: CountNumberOfTowerToCoverHouses.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: CountNumberOfTowerToCoverHouses
----------------------
int numberOfTowers(int[] houses,int range){
    int count=1;
    int lastLoc=houses[0]+range;
    for(int i=1;i<houses.length;++i){
     if(Math.abs(houses[i]-lastLoc)>range){
         ++count;
         lastLoc=houses[i]+range;
     }
    }
    return count;
 }

File: questions.txt
Question Type: TODO
DSA Question: DSA problem related to: questions
----------------------
why streams
connection pool
data strucutre for mySql,mongodb
tranactional
difference between rest controller and controlller
proxy setup
cache setup
timeout setup in java
cassandra vs mongoDB
normalization and denormalization-serialID
mySql to cassandra shifting
linkedlist vs arraylist
jdbc classFor
Auth token
microservices
query in mongoDB
how jobs get data from rabbitMQ
runnable interface
customer centric suggestion
cyclic barrier
circuit breaker

AWS
ORM-hibernate
how jpa connects to db
how to add multiple database support
design pattern
DATA EXPORT
LOCKS
collection framework- when to choose set and list
reverse a list using recursion
cycle detection
bubble sort
example of design pattens in Spring
check if string is rotation of other string or not
how spring security works
WHERE INDEXES INFO is stored
how to limit the search totop 100 out of 10000 on db side pagination
how to handle lock on db side,and jump to next available
A server can have how many consecutive read write requests
where your server is hosted(A)
AnyThing you have done from your side - Customer obsession(A)
Count of good nodes(A)
find count of a number in a array(A)
how to get top 100 result based on time.How to optimize db queries
how to do consistent hashing using userID

Function Overloading which funcion will be clled

Generics

Functional Programming
List<Employee> filterEmployees(List<Employee> employees,Set<String> deignations){
	//return employees.stream().filter(emp->deignations.contains(emp.getDesignation()).collect(Collectors.toList());
	return employees.stream().filter(Employee::getStatus).collect(Collectors.toList());
}
Functional Interface
lambda perdicate filter how indetify
Default Method

Method Reference

Immutable

class Employee{
	final Employee emp;
	Employee(){
		emp=new Employee();
	}
	
	Employee getEmployee(){
		return emp;
	}
	Set
}

? 

TypeEraser

Employee emp1,emp2,emp3;
@qualifer

@Component
class c{
	@
	ThirdParty reference;
} 

CrossOrigin

class ThridParty

@Confiuration
@AutoConfiguration

@preDestroy

@postConstruct


i1 i2 getName()  getI1()  getI2()

public sttic void getName(int

List<String>  

public string getname(){
	try{
		return "try";
	}catch(Exception e){
		return "catch";
	}catch(){

	}
	finally(){
		return "finally";
	}
	
}



@PostMapping("/createAccount/1")
List<Employee> createAccount(@RequestBody Employye emp,@Required @PathVaribale id){
	employeeService.save(emp);
}

/createAccount?id="1"
10 Emp,id,
1-
""All

Name marks
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
String name="Arun Bhati";
" "  dup  reverse

ithbnura

String getCustomizeString(String str){
	char[] chars=str.toCharArray();
	chars[] newArray=reverse(removeDuplicatesAndEmptyCharsUpper(chars));
	StringBuilder s=getString(newArray);
	return s.toString();
}

char[] removeDuplicatesAndEmptyCharsUpper(char[] chars){
	StringBuilder s=new StringBuilder();
	HashSet<Charcater> set=new HashSet<>();
	for(int i=0;i<chars.lrngth;++i){
		if(chars[i]=' '|| set.contains(chrs[i]) continue;
		if(chars[i]>='A' && chars[i]<='Z'){
			chars[i]=chars[i]-'A'+'a';
		}
		set.add(chars[i]);
		s.append(chars[i]);
	}
	return s.toString().toCharArray();
}

char[] reverse(char[] arr){
	int l=0,h=arr.length-1;
	while(l<=h){
		char temp=arr[l];
		arr[l]=arr[h];
		arr[h]=temp;
		++l;
		--h;
	}
	return arr;
}


Difference between array and linked list, under which situation would u choose one over the other

3 largest element in MYSQl

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
class DNode{
	String key;
	String value;
	DNode prev;
	DNode next;

	public DNode(){}
	public DNode(String key,String value){
		this.key=key;
		this.value=value;
	}
}

class LRU{
	int size=0;
	int limit;
	        //key   //node
	Hashmap<String,DNode> map;
	DNode head=new DNode(),tail=new DNode();
	public LRU(int limit){
		map=new HashMap<>();
		head.next=tail;
		tail.prev=head;
        this.limit=limit;
	}

	String get(String key){
		if(!map.contains(key)) {
			String data=dataService.fetchData(key);
			return insert(key,data);
		}
		DNode temp=map.get(key);
		moveToHead(temp);
		return temp.value;
	}

	void moveToHead(DNode temp){
		node.next=temp;
		node.prev=head;
		head.next=node;
		map.put(key,node);
	}

	String insert(String key,String value){
		if(map.contains(key)) return;
		if(size==limit){
			delete();
		}
		DNode node=new DNode(key,value);
		DNode temp=head.next;
		moveToHead(temp);
		++size;
		return value;
	}
	
	void delete(){
		Node temp=tail.prev;
		Node prev=temp.prev;
		prev.next=tail;
		tail.prev=prev;
		map.remove(tempkey);
		--size;
	}
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

3. Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1.


Element       NGE
   4      -->   5
   5      -->   25
   2      -->   25
   25     -->   -1
   11     -->   19
   19     -->   -1
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
A 2-D grid consisting of some blocked (represented as '#') and some unblocked (represented as '.') cells is given. The starting position of a pointer is in the top-left corner of the grid. It is guaranteed that the starting position is in an unblocked cell. It is also guaranteed that the bottom-right cell is unblocked. Each cell of the grid is connected with its right, left, top, and bottom cells (if those cells exist). It takes 1 second for a pointer to move from a cell to its adjacent cell. If the pointer can reach the bottom-right corner of the grid within k seconds, return the string 'Yes'. Otherwise, return the string 'No'. 

 

Example

rows = 3

grid = ['..##', '#.##', '#...']

maxTime = 5

. . # #
# . # #
# . . .
It will take the pointer 5 seconds to reach the bottom right corner. As long as k <= 5, return 'Yes'.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Vechile
-------
vechileNumber
type
passCount

Jobs
-----
id
DateTime LastRunDate

Ticket
-------
Integer id
String vechileNumber
String attendentId
DateTime enterTime
DateTime exitTime
Integer SparkingLotId
Double price

Attendents
--------
id
Name
Address

parkingLot
----------
Integer id
address
name


vechileType
----------
TWO_WHEELER
FOUR_WHEELER
BIG_TRUCK
ELECTRIC_VECHILE


ticketRepository.getTickets(by vechileNumber,btween dates).filter(exutTime-enter>=30).count();


Heap working 
KMP working



{1,2-5,3,4,-1,2}

int maximumSum(int[] arr){
	int[] memo=new int[arr.length];
	memo[0]=arr[0];
	int maxSum=memo[0];
	for(int i=1;i<arr.length;++i){
		memo[i]=Math.max(arr[i],arr[i]+memo[i-1]);
		maxSum=Math.max(maxSum.memo[i]);
	}
	return maxSum;
}

//  {1,2-5,3,4,-1,2}
int i=0  1  2  3   4  5  6
memo {1  3  -2  3  7  6   }
maxSm=1  3  3   3  7  7


//Linked list 

	5 7 9 2 3 6->  5 9 3  7 2 6
	
	Node rearrangeListOddEven(Node head){
		if(head==null) return null;
		Node dummyO=new Node(),dummyE=new Node();
		Node currO=dummyO,prevO=null,currE=dummyE;
		Node curr=head;
		boolean isOdd=true;
		while(curr!=null){
			if(isOdd){
			   prev=currO;
			   currO.next=curr;
			   currO=currO.next;
			}else{
			   currE.next=curr;
			   currE=currE.next;
			}
			isOdd=!isOdd;
			curr=curr.next;
		}
		prev.next=dummyE.next;
		dummyE=null;
		return dummyO.next;
	}

	5 7 9 2 3 6
	         curr=5  7  9  2  3  6
	isOdd=        t  f  t  f  t  f
	currO=   New ,5     9     3
	currE=   new    ,7     2     6

File: TODO.txt
Question Type: TODO
DSA Question: DSA problem related to: TODO
----------------------
SystemDesign Problem statement in detail to refer:
-------------------------------------------------
Practice class diagrams
OOPs concept for class diagrams

JWT
consistent hashing
Indexing
Inverse Indexing
Microservices and communication between them
notification service
Messaging queue
time stamp- how to maintain sequencing as clint time stamp may be unreliable
Class diagram for chess,conv
recommendation system

– Explain design patterns used so far.
– How is code review done.
– How is design review done.
What type of cache do you use in your projects/SYstem.
Using generics
How will you resolved the concurrency issue when 2 customers try to book same seat.

Complete design of my project HLD, LLD, UI, DB etc.

Any big enhancement suggested by you to make your code better.
A running stream of numbers is coming you need to keep track of top K elements
Heap interface and using that implement min heap or max heap. And also write the heapify code
Clone a Binary Tree with Random Pointers

Program for Best Fit algorithm in Memory Management
Design a deck of card (only the model classes)
NoSQL vs a SQL database (when to choose which)

Design Promo Code API taking Amazon’s customer traffic into picture (HLD and LLD was discussed – including in memory databases)
Variation of Topological Sorting : You have been given a set of inter-dependent tasks along with the time taken to execute them. We have more number of parallel processors available than the number of tasks given. There could be multiple starting tasks. There could also be cyclic dependencies. Calculate the minimum time required to complete all the task. Complete end to end production ready code was expected.

Design a vending machine with following functionalities

Three types of Users : User, Operator, Admin
User can select and buy multiple items at a time. Money can be inputted multiple times (you will get the item if there is a time gap > 30 secs). He can also do window shopping (see only the prices of items and buy nothing)
Operator can load the items and mark the items as expired if needed, gets notified if a product goes out of stock.
Admin can own multiple vending machines, he should have a analytics report of the items purchased in a month. He can also change the prices directly and it should reflect in all the vending machines which he owns.
Exception handling in all the edge cases

Design a Whatsapp like service.
Given the high level design first, then dived deeper explaining load balancing, splitting into microservies and communication between them, notification service, message queuing, database sharding, etc.
Asked me how to maintain the sequencing of messages, since client’s time-stamp would be unreliable.

Class diagram for a standalone Chess board game.
Discussion on the my design like, why this class/relationship is needed, why this method is in this class rather than that, etc. Convinced him for few of them, giving proper reasons, and made changes in the design for other few.
Pseudo code for all the possible moves of any piece.

Design:
Do integration for Splitwise app with Amazon Pay (or Paytm)
1) where a person can pay to another person and money directly gets deposited into other person’s bank account.
2) A person can also send reminder to another person for owning money.

Design a job scheduler, scalability, fault tolerance, high availability, how scheduler picks up job,
how will you take care where one job can run for 30 min and one for 30 hour, how will you distribute jobs on servers.
Based on frequency & time how will you execute them ?
How will you notify back the user about start/stop or completion of a job ?
How will your system know if a job is killed / terminated due to unknown reasons ?


.........
Behavioural
-----------
Job Description

Any task/project which was designed and implemented in less time but had a great impact on the production/Business Side.

http://kraftshala.com/how-to-raise-the-bar-in-the-amazon-interview/


........
Google :-
........
Given a result of a competition among all the students of a class, write a program to make students stand in a order such that every student must have lost to the student in his/her immediate left and won against the student to his/her immediate right.
https://www.geeksforgeeks.org/anagram-substring-search-search-permutations/
https://www.geeksforgeeks.org/the-celebrity-problem/
B trees and B+ Trees
AVL tree
hamilton path
Rat in a maze
sudoku
knights tour problem
hamiltonian cycle
m coloring
Robber
np hard problem
Best-First Search.
travelling salesman problem
Reliability design dp
Branch and Bound
QuickSort LinkedList
Row-Major and Column-Major

File: DSA_ODO.txt
Question Type: TODO
DSA Question: DSA problem related to: DSA_ODO
----------------------
AVL delete a node
longestPalindromincSubString
longestPalindromicSubSequence
longestCommonSubSequence
longestConsecutiveSequence
longestNonRepeatingSubString
Critical Connections in a Network

File: Tech_TODO.txt
Question Type: TODO
DSA Question: DSA problem related to: Tech_TODO
----------------------
Zookeeper
linux 
PostgreSQL 
AWS
kafka 
ELK
loadbalancer
cache
Proxy
Kubernetes

File: TrieImplementationRecursive.txt
Question Type: Trie
DSA Question: DSA problem related to: TrieImplementationRecursive
----------------------
class TrieNode{
    public Map<Character,TrieNode> map;
    public boolean isEnd;
    
    public TrieNode() {
        map=new HashMap<>();
    }
}
class Trie {
    TrieNode trieNode;
    public Trie() {
        trieNode=new TrieNode();
    }
    
    public void insert(String word) {
        insertCharacter(trieNode,word,0);
    }
    
    void insertCharacter(TrieNode dict,String word,int i){
        if(word.length()-1==i){
            if(dict.map.containsKey(word.charAt(i))){
                dict.map.get(word.charAt(i)).isEnd=true;
            }else{
                TrieNode trieNode=new TrieNode();
                trieNode.isEnd=true;
                dict.map.put(word.charAt(i),trieNode);
            }
            return;
        }else{
            if(dict.map.containsKey(word.charAt(i))){
                insertCharacter(dict.map.get(word.charAt(i)),word,i+1);
            }else{
                TrieNode trieNode=new TrieNode();
                dict.map.put(word.charAt(i),trieNode);
                insertCharacter(dict.map.get(word.charAt(i)),word,i+1);
            }
        }
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        return searchChar(trieNode,word,0);
    }
    
    boolean searchChar(TrieNode dict,String word,int i){
        if(word.length()-1==i){
          if(dict.map.containsKey(word.charAt(i)) && dict.map.get(word.charAt(i)).isEnd) return true; 
          return false;  
        } 
        if(dict.map.containsKey(word.charAt(i))){
            return searchChar(dict.map.get(word.charAt(i)),word,i+1);
        }
        return false;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return searchPrefix(trieNode,prefix,0);
    }
    
    boolean searchPrefix(TrieNode dict,String word,int i){
        if(word.length()-1==i){
          if(dict.map.containsKey(word.charAt(i))) return true; 
          return false;  
        } 
        if(dict.map.containsKey(word.charAt(i))){
            return searchPrefix(dict.map.get(word.charAt(i)),word,i+1);
        }
        return false;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */


File: TrieMapSumPairs.txt
Question Type: Trie
DSA Question: DSA problem related to: TrieMapSumPairs
----------------------
class TrieNode{
    public Map<Character,TrieNode> map;
    public int sum;
    
    public TrieNode() {
        map=new HashMap<>();
    }
}

class MapSum {
    TrieNode trieNode;
    Map<String,Integer> map;
    public MapSum() {
        trieNode=new TrieNode();
        map=new HashMap<>();
    }
    
    public void insert(String key, int val) {
        int existingValue=map.getOrDefault(key,0);
        map.put(key,val);
        insertCharacter(trieNode,key,0,val,existingValue);
    }
    
    void insertCharacter(TrieNode dict,String word,int i,int val,int existingValue){
        if(word.length()-1==i){
            if(dict.map.containsKey(word.charAt(i))){
                dict.map.get(word.charAt(i)).sum=dict.map.get(word.charAt(i)).sum + val - existingValue; 
            }else{
                TrieNode trieNode=new TrieNode();
                trieNode.sum=val;
                dict.map.put(word.charAt(i),trieNode);
            }
            return;
        }else{
            if(dict.map.containsKey(word.charAt(i))){
                dict.map.get(word.charAt(i)).sum=dict.map.get(word.charAt(i)).sum+val- existingValue;
                insertCharacter(dict.map.get(word.charAt(i)),word,i+1,val,existingValue);
            }else{
                TrieNode trieNode=new TrieNode();
                trieNode.sum=val;
                dict.map.put(word.charAt(i),trieNode);
                insertCharacter(dict.map.get(word.charAt(i)),word,i+1,val,existingValue);
            }
        }
    }
    
    public int sum(String prefix) {
        return searchChar(trieNode,prefix,0);
    }
    
    int searchChar(TrieNode dict,String word,int i){
        if(word.length()-1==i){
          if(dict.map.containsKey(word.charAt(i))) {
              return dict.map.get(word.charAt(i)).sum;
          }
        } 
        if(dict.map.containsKey(word.charAt(i))){
            return searchChar(dict.map.get(word.charAt(i)),word,i+1);
        }
        return 0;
    }
}


File: WordBreak.txt
Question Type: Trie
DSA Question: DSA problem related to: WordBreak
----------------------
class Solution {
    HashMap<String,Boolean> map=new HashMap<>();
    public boolean wordBreak(String s, List<String> words) {
        TNode node=new TNode();
        for(String word:words){
            insert(node,word);            
        }
        return searchHelper(node,s);
    }
    
    public boolean searchHelper(TNode node,String s){
       if(map.containsKey(s)) return map.get(s);
       if(s.length()==0) return true;
       for(int i=1;i<=s.length();++i){
           if(search(node,s.substring(0,i)) && searchHelper(node,s.substring(i,s.length()))){
               map.put(s,true);
               return true;
           } 
       }
       map.put(s,false);
       return false; 
    }
    
    public boolean search(TNode node,String s){
        if(map.containsKey(s)) return map.get(s);
        if(s.length()==0) return false;
        int i=0;
        while(i<s.length()){
            if(!node.dic.containsKey(s.charAt(i))) return false;
            node=node.dic.get(s.charAt(i));
            i++;
        }
        map.put(s,node.isEnd);
        return node.isEnd;
    }
    
    public void insert(TNode node,String word){
        int i=0;
        if(word.length()==0) return;
        while(i<word.length()){
            if(!node.dic.containsKey(word.charAt(i))){
                node.dic.put(word.charAt(i),new TNode());
            }
            node=node.dic.get(word.charAt(i));
            i++;
        }
        node.isEnd=true;
    }
}

class TNode{
    public boolean isEnd;
    public Map<Character,TNode> dic=new HashMap<>();
}

File: ReplaceWords.txt
Question Type: Trie
DSA Question: DSA problem related to: ReplaceWords
----------------------
/*
In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word successor. For example, when the root "an" is followed by the successor word "other", we can form a new word "another".
Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. If a successor can be replaced by more than one root, replace it with the root that has the shortest length.
Return the sentence after the replacement.
Example 1:
Input: dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
Output: "the cat was rat by the bat"
*/
class TrieNode{
    Map<Character,TrieNode> map;
    boolean isEnd;
    TrieNode(){
        map=new HashMap<>();
    }
}
class Solution {
    public String replaceWords(List<String> dictionary, String sentence) {
        TrieNode trie=new TrieNode();
        for(String word:dictionary){
            insertWord(trie,word,0);
        }
        String[] arr=sentence.split(" ");
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<arr.length;++i){
            String prefix=searchHelper(trie,arr[i]);
            if(prefix.length()!=0){
                sb.append(prefix+" ");
            }else{
                sb.append(arr[i]+" ");
            }
        }
        return sb.toString().trim();
        
    }
    String searchHelper(TrieNode dict,String word){
        int index=searchChar(dict,word);
        return word.substring(0,index);
    }
    
    int searchChar(TrieNode dict,String word){
        TrieNode curr=dict;
        int i=0;
        while(i<word.length()){
            if(!curr.map.containsKey(word.charAt(i))){
                return 0;
            }else{
                if(curr.map.get(word.charAt(i)).isEnd){
                    return i+1;
                }
                curr=curr.map.get(word.charAt(i));
            }
            ++i;
        }
        return 0;
    }
    
    private void insertWord(TrieNode dict,String word,int i){
        if(word.length()-1==i){
            if(!dict.map.containsKey(word.charAt(i))){
                TrieNode trieNode=new TrieNode();
                trieNode.isEnd=true;
                dict.map.put(word.charAt(i),trieNode);
            }else{
                dict.map.get(word.charAt(i)).isEnd=true;
            }
            return;
        }else{
            if(dict.map.containsKey(word.charAt(i))){
                insertWord(dict.map.get(word.charAt(i)),word,i+1);
            }else{
                TrieNode trieNode=new TrieNode();
                dict.map.put(word.charAt(i),trieNode);
                insertWord(dict.map.get(word.charAt(i)),word,i+1);
            }
        }        
    }
}


File: Trie.txt
Question Type: Trie
DSA Question: DSA problem related to: Trie
----------------------
public boolean search(TNode node,String s){
    if(s.length()==0) return false;
    int i=0;
    while(i<s.length()){
        if(!node.dic.containsKey(s.charAt(i))) return false;
        node=node.dic.get(s.charAt(i));
        i++;
    }
    return node.isEnd;
}
    
public void insert(TNode node,String word){
    int i=0;
    if(word.length()==0) return;
    while(i<word.length()){
        node.dic.put(word.charAt(i),new TNode());
        node=node.dic.get(word.charAt(i));
        i++;
    }
    node.isEnd=true;
}

class TNode{
    public boolean isEnd;
    public Map<Character,TNode> dic=new HashMap<>();
}

File: MinHeap.txt
Question Type: Heap
DSA Question: DSA problem related to: MinHeap
----------------------
public class MinHeap{
	static int [] arr;
	static int size;
	
	MinHeap(int size){
		this.size=size;
		this.arr=new int[size];
	}


	MinHeap(int arr[]){
		this.size=arr.length;
		this.arr=arr;
	}
	
	public static void printAllElements(){
		System.out.println("\nprinting all heap elements");
		for(int i=0;i<size;++i){
			System.out.print(arr[i]+"-");			
		}
	}
	
	public static void buildHeap(){ // bottom to top //o(n)
		for(int i=(size-2)/2;i>=0;--i){
			minHeapify(i);//top to bottom
		}
	}
	
	private static void swap(int x,int y){
		int temp=arr[x];
		arr[x]=arr[y];
		arr[y]=temp;
	}
	
	public static void minHeapify(int root){ //top to bottom - o(logn)
		int left=2*root+1;
		int right=2*root+2;

		int smallest=root;
		if(right<size && arr[smallest]>arr[right]){
			smallest=right;
		}
		if(left<size && arr[smallest]>arr[left]){
			smallest=left;
		}
		if(smallest!=root){
			swap(root,smallest);
			minHeapify(smallest);
		}
	}

	public static int extractMin(){
		if(size==0) return Integer.MAX_VALUE;
		if(size==1){
			size--;
			return arr[0];
		}
		swap(0,size-1);
		--size;
		minHeapify(0);
		return arr[size];
	}

	public static void sort(){
		System.out.print("\nSorted numbers:-");
		while(size!=0){
			System.out.print(extractMin()+"-");
		}
	}

	public static void main(String args[]){
		int arr[]={2,0,21,1221,12,233,3,1};
		MinHeap minHeap=new MinHeap(arr);
		buildHeap();
		printAllElements();
		System.out.println("\nhighest prority element in min heap is: "+extractMin());
		printAllElements();
		sort();
	}

}

File: findKthLargest-Selection Approach better.txt
Question Type: Heap
DSA Question: DSA problem related to: findKthLargest-Selection Approach better
----------------------
class findKthLargest{
    public int findKthLargest(int[] nums, int k) {
        MaxHeap heap=new MaxHeap(nums);
        heap.buildHeap();
        for(int i=0;i<k-1;++i){
            heap.extract();
        }
        return heap.extract();
    }
    
}

public class MaxHeap{
	static int [] arr;
	static int size;
	
	MaxHeap(int size){
		this.size=size;
		this.arr=new int[size];
	}


	MaxHeap(int arr[]){
		this.size=arr.length;
		this.arr=arr;
	}
	
	public static void printAllElements(){
		System.out.println("\nprinting all heap elements");
		for(int i=0;i<size;++i){
			System.out.print(arr[i]+"-");			
		}
	}
	
	public static void buildHeap(){ // bottom to top //o(n)
		for(int i=(size-2)/2;i>=0;--i){
			Heapify(i);
		}
	}
	
	private static void swap(int x,int y){
		int temp=arr[x];
		arr[x]=arr[y];
		arr[y]=temp;
	}
	
	public static void Heapify(int root){ //top to bottom - o(logn)
		int left=2*root+1;
		int right=2*root+2;

		int largest=root;
		if(right<size && arr[largest]<arr[right]){
			largest=right;
		}
		if(left<size && arr[largest]<arr[left]){
			largest=left;
		}
		if(largest!=root){
			swap(root,largest);
			Heapify(largest);
		}
	}

	public static int extract(){
		if(size==0) return Integer.MIN_VALUE;
		if(size==1){
			size--;
			return arr[0];
		}
		swap(0,size-1);
		--size;
		Heapify(0);
		return arr[size];
	}

}

File: MedianOfTwoSortedArray-Selection Approach better.txt
Question Type: Heap
DSA Question: DSA problem related to: MedianOfTwoSortedArray-Selection Approach better
----------------------
class MedianOfTwoSortedArray{
    int size=0;
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {        
      MiddleHeap heap=new MiddleHeap(nums1.length+nums2.length);

      for(int i=0;i<nums1.length;++i){
           heap.insertMiddle(nums1[i]);
      }  
       for(int i=0;i<nums2.length;++i){
           heap.insertMiddle(nums2[i]);
      }    
        return heap.getMedian();
        
    }
    
    

}

 class MiddleHeap {
    MinHeap minHeap;
    MaxHeap maxHeap;

    public MiddleHeap(int capacity) {
        if ((double) (capacity % 2) > 0.0) {
            this.minHeap = new MinHeap(capacity / 2);
            this.maxHeap = new MaxHeap(capacity / 2 + 1);
        } else {
            this.minHeap = new MinHeap(capacity / 2);
            this.maxHeap = new MaxHeap(capacity / 2);
        }
    }

    public void printAll(){
        maxHeap.printAll();
        minHeap.printAll(minHeap.getArr());

    }

    public void insertMiddle(int newValue) {
        if (maxHeap.arr[0] == null) {
            maxHeap.insertMax(newValue);
        } else if (maxHeap.size > minHeap.size) {
            if (newValue < maxHeap.getMax()) {
                minHeap.insertMin(maxHeap.extractMax());
                maxHeap.insertMax(newValue);
            } else {
                minHeap.insertMin(newValue);
            }
        } else if (maxHeap.size == minHeap.size) {
            if (newValue > minHeap.getMin()) {
                maxHeap.insertMax(minHeap.extractMin());
                minHeap.insertMin(newValue);
            } else {
                maxHeap.insertMax(newValue);
            }
        }
    }

    public double getMedian() {
        if ((double) ((maxHeap.size + minHeap.size) % 2) > 0.0) {
           return maxHeap.getMax();
        } else {
            return (double)(maxHeap.getMax() +minHeap.getMin())/2;
        }
    }

    public void extractMedian() {
        if ((double) ((maxHeap.size + minHeap.size) % 2) > 0.0) {
            System.out.println(maxHeap.extractMax());
        } else {
            System.out.println(maxHeap.extractMax() +" & "+ minHeap.extractMin());
        }
    }

    public void medianDelete(int i) {
        if ((double) ((maxHeap.size + minHeap.size) % 2) > 0.0) {
            System.out.println(maxHeap.maxdelete(0));
        } else {
            System.out.println(maxHeap.maxdelete(0) +" & "+ minHeap.Mindelete(0));
        }
    }

}


 class MinHeap {
    public static Integer arr[];
    public static int size;
    public static int capacity;

    public static Integer[] getArr() {
        return arr;
    }

    public static void setArr(Integer[] arr) {
        MinHeap.arr = arr;
    }

    public static void setSize(int size) {
        MinHeap.size = size;
    }

    public static int getCapacity() {
        return capacity;
    }

    public static void setCapacity(int capacity) {
        MinHeap.capacity = capacity;
    }

    public MinHeap() {

    }

    public MinHeap(int capacity) {
        this.arr = new Integer[capacity];
        this.size = 0;
        this.capacity = capacity;
    }

    public int getSize() {
        return this.size;
    }

    public Boolean isEmpty() {
        return this.size < 1;
    }

    public int getParent(int i) {
        return (i - 1) / 2;
    }

    public int getLeftChild(int i) {
        return 2 * i + 1;
    }

    public int getRightChild(int i) {
        return 2 * i + 2;
    }


    public void insertMin(int newValue) {  //O(log(size))
        if (this.getSize() + 1 > capacity) {
            System.out.println("Size is full");
            return;
        }
        size++;
        arr[size - 1] = newValue;
        int i = size - 1;
        while (i >= 0 && arr[getParent(i)] > arr[i]) {
            int temp = arr[getParent(i)];
            arr[getParent(i)] = arr[i];
            arr[i] = temp;
            i = getParent(i);
        }
    }

    public static void printAll(Integer[] arrr) {
        for (int i = 0; i < arrr.length; ++i) {
            System.out.print(arrr[i] + " ");
        }
    }


    public int getMin() {
        return arr[0];
    }


    public int extractMin() {
        if (size == 0) {
            return Integer.MIN_VALUE;
        }
        if (size == 1) {
            size--;
            return arr[0];
        }
        int temp = arr[0];
        arr[0] = arr[size - 1];
        arr[size - 1] = temp;
        size--;
        MinHeapify(arr,size,0);
        return arr[size];
    }


    public int Mindelete(int i) {
        int key;
        if (size < 1) {
            System.out.println("Wrong Position");
            return 0;
        }
        key = arr[i];
        arr[i] = arr[size - 1];
        size--;
        MinHeapify(arr,size,i);
        return key;
    }


    public static void buildMinHeap(Integer[] arrr) {
        arr = arrr;
        capacity = arr.length;
        size = arr.length;
        for (int i = (size - 2) / 2; i >= 0; i--) {
            MinHeapify(arr,size,i);
        }
    }



    public static void MinHeapify(Integer[] arrr, int modifiedSize, int i) { //O(logN)
        int leftIndex = 2*i + 1;
        int rightIndex = 2*i + 2;
        int smallest = i;
        if (leftIndex < modifiedSize && arrr[leftIndex] < arrr[smallest]) {
            smallest = leftIndex;
        }
        if (rightIndex < modifiedSize && arrr[rightIndex] < arrr[smallest]) {
            smallest = rightIndex;
        }
        if (smallest != i) {
            int temp = arrr[i];
            arrr[i] = arrr[smallest];
            arrr[smallest] = temp;
            MinHeapify(arrr,modifiedSize,smallest);
        }
    }

    public static void sort(Integer arr[]) {
        int n = arr.length;
        buildMinHeap(arr);

        for (int i = n - 1; i >=1; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            //we are putting the smallest one in the last position and keep decreasing the size
            MinHeapify(arr, i, 0);
        }
    }
    
}

 class MaxHeap {
    Integer arr[];
    int size;
    int capacity;

    public MaxHeap() {

    }

    public MaxHeap(int capacity) {
        this.arr = new Integer[capacity];
        this.size = 0;
        this.capacity = capacity;
    }

    public int getSize() {
        return this.size;
    }

    public Boolean isEmpty() {
        return this.size < 1;
    }

    public int getParent(int i) {
        return (i - 1) / 2;
    }

    public int getLeftChild(int i) {
        return 2 * i + 1;
    }

    public int getRightChild(int i) {
        return 2 * i + 2;
    }


    public void insertMax(int newValue) {  //O(log(size))
        if (this.getSize() + 1 > capacity) {
            System.out.println("Size is full");
            return;
        }
        size++;
        arr[size - 1] = newValue;
        int i = size - 1;
        while (i >= 0 && arr[getParent(i)] < arr[i]) {
            int temp = arr[getParent(i)];
            arr[getParent(i)] = arr[i];
            arr[i] = temp;
            i = getParent(i);
        }
    }

    public void printAll() {
        for (int i = 0; i < size; ++i) {
            System.out.print(arr[i] + " ");
        }
    }


    public int getMax() {
        return arr[0];
    }


    public int extractMax() {
        if (size == 0) {
            return Integer.MIN_VALUE;
        }
        if (size == 1) {
            size--;
            return arr[0];
        }
        int temp = arr[0];
        arr[0] = arr[size - 1];
        arr[size - 1] = temp;
        size--;
        maxHeapify(arr,size,0);
        return arr[size];
    }


    public int maxdelete(int i) {
        int key;
        if (size < 1) {
            System.out.println("Wrong Position");
            return 0;
        }
        key = arr[i];
        arr[i] = arr[size - 1];
        size--;
        maxHeapify(arr,size,i);
        return key;
    }


    public void buildMaxHeap(Integer[] arr) {
        this.arr = arr;
        this.capacity = arr.length;
        this.size = arr.length;
        for (int i = (size - 2) / 2; i >= 0; i--) {
            maxHeapify(arr,size,i);
        }
    }



    public void maxHeapify(Integer[] arrr, int modifiedSize, int i) { //O(logN)
        int leftIndex = 2*i + 1;
        int rightIndex = 2*i + 2;
        int largest = i;
        if (leftIndex < modifiedSize && arrr[leftIndex] > arrr[largest]) {
            largest = leftIndex;
        }
        if (rightIndex < modifiedSize && arrr[rightIndex] > arrr[largest]) {
            largest = rightIndex;
        }
        if (largest != i) {
            int temp = arrr[i];
            arrr[i] = arrr[largest];
            arrr[largest] = temp;
            maxHeapify(arrr,modifiedSize,largest);
        }
    }

    public void sort(Integer arr[]) {
        int n = arr.length;
        buildMaxHeap(arr);

        for (int i = n - 1; i >=1; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            //we are putting the largest one in the last position and keep decreasing the size
            maxHeapify(arr, i, 0);
        }
    }


}



File: KthLargestElementInAStream.txt
Question Type: Heap
DSA Question: DSA problem related to: KthLargestElementInAStream
----------------------
class KthLargest {
    PriorityQueue<Integer> pq;
    int k;
    public KthLargest(int k, int[] nums) {
        this.k=k;
        pq=new PriorityQueue<>(k+1);
        for(int num:nums){
            add(num);
        }
    }
    public int add(int val) {
        pq.add(val); 
        if(pq.size()==k+1){
            pq.poll();
        }
        return pq.peek();
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest obj = new KthLargest(k, nums);
 * int param_1 = obj.add(val);
 */

File: Top K Frequent Element.txt
Question Type: Heap
DSA Question: DSA problem related to: Top K Frequent Element
----------------------
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        if (k == nums.length) {
            return nums;
        }
        int[] ans=new int[k];
        HashMap<Integer,Integer> map=new HashMap<>();
        PriorityQueue<Integer> pq=new PriorityQueue<>((n1, n2) ->   map.get(n1)-map.get(n2));
        
        int i=0;
        while(i<=nums.length-1){
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
            i++;
        }
        for(Integer key:map.keySet()){
            pq.add(key);
            if(pq.size()>k){
                pq.poll();
            }
        }
        for(i=0;i<k;++i){
            ans[i]=pq.poll();
        }
        return ans;
    }
}

File: MergeKSortedLists.txt
Question Type: Heap
DSA Question: DSA problem related to: MergeKSortedLists
----------------------
/*
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
*/
class The_Comparator implements Comparator<ListNode> { 
    public int compare(ListNode l1, ListNode l2) 
    {  
        return l1.val-l2.val; 
    } 
} 

class MergeKSortedLists{
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0) return null;
        ListNode result=new ListNode();
        ListNode current=result,top=null;
        PriorityQueue<ListNode> pq=new PriorityQueue<>(lists.length,new The_Comparator());
        for(int i=0;i<lists.length;++i){
            if(lists[i]!=null){
                pq.add(lists[i]);
            }
        }
        while(!pq.isEmpty()){
            top=pq.poll();//main point
         
            if(top.next!=null){
                pq.add(top.next);    
            }
            current.next=top;
            current= current.next;
        }
        
      return result.next;  
    }
}

File: firstMissingPositiveInteger.txt
Question Type: Maths
DSA Question: DSA problem related to: firstMissingPositiveInteger
----------------------
class Solution {//100
    public int firstMissingPositive(int[] nums) {
        boolean oneFound=false;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==1){
                oneFound=true;
            }else if(nums[i]>nums.length || nums[i]<=0){
                nums[i]=1;
            }
        }
        if(!oneFound) return 1;
        if(nums.length==1) return 2;
        for(int i=0;i<nums.length;++i){
            int index=Math.abs(nums[i])-1;
            nums[index]=nums[index]>0?-1*nums[index]:nums[index];
        }
        
        for(int i=0;i<nums.length;++i){
            if(nums[i]>0) return i+1;
        }
        
        return nums.length+1;
    }
}


File: Power.txt
Question Type: Maths
DSA Question: DSA problem related to: Power
----------------------
class Solution {
    public double myPow(double x, int n) {
        long N=n;
        if(N<0){
            x=1/x;
            N=-1*N;
        }
        return myPowL(x,N);
    }
    
    public double myPowL(double x, long N) {
        if(N==0) return 1;
        double pow=myPowL(x,N/2);
        if(N%2==0){
            return pow*pow;
        }
        return pow*pow*x;
    }
}

File: SquareRootOfInteger.txt
Question Type: Maths
DSA Question: DSA problem related to: SquareRootOfInteger
----------------------
/*
Implement int sqrt(int x).

Compute and return the square root of x, where x is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.
*/
class Solution {
    public int mySqrt(int x) {
        if(x<2) return x;
        return helper(x,0,x);
    }
    
    int helper(int x,int l,int h){
        if(l>h) return -1;
        if(l+1==h) return l;
        long avg=l+(h-l)/2;
        long mul=avg*avg;
        if(mul==x){
          return (int)avg;  
        }else if(mul<x){
            return helper(x,(int)avg,h);
        } return helper(x,l,(int)avg);
        
    }
}

class Solution {
    public int mySqrt(int x) {
        if(x<=1) return x;
        int left=2,right=x/2;
        while(left<=right){
            int pivot=(left+right)/2;
            if((long)pivot*pivot>x) {right=pivot-1;}
            else if((long)pivot*pivot<x) {left=pivot+1;}
            else return pivot;
        }
        return right;
    }
}


File: FindDuplicateElementsInAnArray.txt
Question Type: Maths
DSA Question: DSA problem related to: FindDuplicateElementsInAnArray
----------------------
class Solution {
    public int findDuplicate(int[] nums) {
        for(int i=0;i<nums.length;++i){
            int abs=Math.abs(nums[i]);
            if(nums[abs]<0){
                return abs;
            }
            nums[abs]=-1*nums[abs];
        }
        return -1;
    }
}


File: ReverseNumber.txt
Question Type: Maths
DSA Question: DSA problem related to: ReverseNumber
----------------------
/*
Given a 32-bit signed integer, reverse digits of an integer.
*/
class Solution {//improved
    public int reverse(int x) {
        boolean negative=x<0?true:false;
        x=Math.abs(x);
        int ans=0;
        while(x!=0){ //123
            int pop=x%10;
/*
However, this approach is dangerous, because the pop can cause overflow.
*/
            if (ans > Integer.MAX_VALUE/10 || (ans == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (ans < Integer.MIN_VALUE/10 || (ans == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            ans=ans*10+pop; //3
            x=x/10;//12
        }
        ans=negative?(ans*-1):ans;
        return ans;
    }
}

class ReverseNumber {
    public int reverse(int x) {
        boolean negative=x<0?true:false;
        x=Math.abs(x);
        String s=((Integer)x).toString();
        int len=s.length();
        s="";
        int rem=0;
        for(int i=1;i<=len;++i){
            rem=x%10;
            s=s+rem;
            x=x/10;
        }
        try{
          x=Integer.parseInt(s);  
        }catch(Exception ex){
            x=0;
        }
        
        x=negative?(x*-1):x;
        return x;
    }
}

File: Convert Binary to Integer.txt
Question Type: Maths
DSA Question: DSA problem related to: Convert Binary to Integer
----------------------
//Convert Binary Number in a Linked List to Integer
class Solution {
    public int getDecimalValue(ListNode head) {
        if(head==null){
            return 0;
        }
        head=reverseList(head);
        int ans=0;
        int i=0;
        while(head!=null){
            ans=ans+head.val*(int)Math.pow(2,i);
            ++i;
            head=head.next;
        }
        return ans;
    }

    ListNode reverseList(ListNode root){
        ListNode prev=null,curr=root,next=null;
        while(curr!=null){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
    }
}

File: PrimeNumber Count upto N number(Sieve of Eratosthenes).txt
Question Type: Maths
DSA Question: DSA problem related to: PrimeNumber Count upto N number(Sieve of Eratosthenes)
----------------------
//The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n.
class Solution {
    public int countPrimes(int n) {
        int count=0;
        boolean[] isPrime=new boolean[n];
        for(int i=2;i<n;++i){
            isPrime[i]=true;
        }
        for(int i=2;i*i<n;++i){
            if(!isPrime[i]) continue;
            markMultiplesAsNotPrime(i,n,isPrime);
        }
        for(int i=2;i<n;++i){
            if(isPrime[i]) count++;
        }
        return count;
    }
    
    void markMultiplesAsNotPrime(int i,int n,boolean [] isPrime){
        for(int j=i*i;j<n;j=j+i){
            isPrime[j]=false;
        }
    }
}

File: InsertionSort.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
//o(n2)

public class InsertionSort{
	static void doInsertionSort(int arr[]){	
		for(int i=1;i<arr.length;++i){ //first loop provides key
			int j,key=arr[i];

			//2nd loop insert the key at right position
			for(j=i-1;j>=0 && arr[j]>key;--j){ // before j all are sorted;   arr[j]>key condition of being unsorted
				arr[j+1]=arr[j];
			}	
			arr[j+1]=key;   
					//for loop go ahead bhavuk hoke 
				        //j is the position i.e arr[j]<key
					//arr[j+1]th element is already shifted to arr[j+2]
					//so no need of swap just allocate j+1 th elemt with key
					//Insertion Sort- as inserting right element at right place.		
		}
	}
	
	static void printAll(int[] arr){
		System.out.print("All Elements are : ");
		for(int i=0;i<arr.length;++i){
			System.out.print(arr[i]+"-");
		}
	}

	public static void main(String args[]){
		int arr[]={21,32,123,12,3,12,434,1};
		doInsertionSort(arr);
		printAll(arr);
	}

}

File: ThreeSum.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums); // Sort the array to enable two-pointer approach
        
        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicates for the first element
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            // Use two pointers to find the other two elements
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    // Found a valid triplet
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // Skip duplicates for the second and third elements
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < 0) {
                    // If sum is less than 0, move the left pointer to increase the sum
                    left++;
                } else {
                    // If sum is greater than 0, move the right pointer to decrease the sum
                    right--;
                }
            }
        }

        return result;
    }
}

class Solution {
    Set<List<Integer>> result=new HashSet<>();
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);

        for(int k=0;k<nums.length;++k){
            twoSum(k,nums);
        }
        return new ArrayList<>(result);
    }

    private void twoSum(int k,int[] nums){
        int l=0,h=nums.length-1;

        while(l<h && l!=k && h!=k){
            int sum=nums[l]+nums[h];
            if(sum+nums[k]==0){
                List<Integer> list=new LinkedList<>();
                if(nums[l]<nums[k]){  
                    list.add(nums[l]);
                    list.add(Math.min(nums[h],nums[k]));
                    list.add(Math.max(nums[h],nums[k]));
                }else{
                    list.add(nums[k]);
                    list.add(nums[l]);
                    list.add(nums[h]);
                }
                result.add(list); ++l;
            }else if(sum>-nums[k]){
                --h;
            }else if(sum<-nums[k]){
                ++l;
            }
        }
    }
}

class Solution {//MAP
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result=new ArrayList<>();
        if(nums.length!=0){
            Integer prev=null;
            for(int i=0;i<nums.length;++i){
                if(prev!=null && prev==nums[i]){
                    continue;
                }
                prev=nums[i];   
                int A=nums[i]*-1;
                twoSum(result,nums,i,A);
            }   
        }
        return result;
    }

    void twoSum(List<List<Integer>> result,int[] nums,int AIndex, int sum) {
        int l=AIndex+1,h=nums.length-1;
        while(l<h){
            int BC=nums[l]+nums[h];
            if(BC>sum || (h<nums.length-1 && nums[h]==nums[h+1])){
                h--;
            }else if(BC<sum || (l>AIndex+1 && nums[l]==nums[l-1])){
                l++;
            }else{
                result.add(Arrays.asList(nums[AIndex],nums[l++],nums[h--]));
            }
            
        }
    }
}


File: BubbleSort.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
public class BubbleSort{//o(n2) //detect if already sorted

	static void doBubbleSort(int arr[]){
		Boolean swapped=true;
		while(swapped){
			swapped=false;
			for(int i=0;i<arr.length-1;++i){
				if(arr[i]>arr[i+1]){
					int temp=arr[i];
					arr[i]=arr[i+1];
					arr[i+1]=temp;
					swapped=true;
				}
			}
		}
	}
	
	static void printAll(int[] arr){
		System.out.print("All Elements are : ");
		for(int i=0;i<arr.length;++i){
			System.out.print(arr[i]+"-");
		}
	}

	public static void main(String args[]){
		int arr[]={21,32,123,12,3,12,434,1};
		doBubbleSort(arr);
		printAll(arr);
	}

}

File: ThreeSumClosest.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    int minDiff=Integer.MAX_VALUE;
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        for(int i=0;i<=nums.length-3;++i){
            twoSum(nums,target,i,i+1,nums.length-1);
            if(minDiff==0) break;
        }
        return target-minDiff;
    }
    
    void twoSum(int[] nums,int target,int i,int l,int h){
        while(l<h){
            int sum=nums[i]+nums[l]+nums[h];
            if(Math.abs(target-sum)<Math.abs(minDiff)){
                minDiff=target-sum;
            }
            if(sum>target){
                --h;
            }else if(sum<target){
                ++l;
            }else{
                return;
            }
        }
    }
}

File: MergeIntervals.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public int[][] merge(int[][] intervals) {
        int[][] ans=new int[0][0];
        if(intervals.length==0) return ans;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[0]-b[0];
            }
        });
        PriorityQueue<int[]> pq=new PriorityQueue<>(new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return b[1]-a[1];
            }
        });
        
        pq.add(intervals[0]);
        for(int i=1;i<intervals.length;++i){
            if(pq.peek()[1]>=intervals[i][0]){
                int[] poll=pq.poll();
                if(poll[1]<intervals[i][1]){
                    poll[1]=intervals[i][1];
                }
                pq.add(poll);
            }else{
                pq.add(intervals[i]);
            }
        }
        ans=new int[pq.size()][2]; 
        int i=0;
        while(!pq.isEmpty()){
            ans[i]=pq.poll();
            ++i;
        }
        return ans;
    }
}

File: MergeSort.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null) return null;
        ListNode last=head;
        while(last.next!=null){
            last=last.next;
        }
        return mergeSort(head,last);
    }
    
    ListNode mergeSort(ListNode l,ListNode h){
        if(l==h) return l;
        ListNode middle=findMiddle(l);
        ListNode next=middle.next;
        middle.next=null;
        ListNode left=mergeSort(l,middle);
        ListNode right=mergeSort(next,h);
        return sort(left,right);
    }
    
    ListNode sort(ListNode list1,ListNode list2){
        ListNode dummy=new ListNode();
        ListNode curr=dummy;
        while(list1!=null && list2!=null){
            if(list1.val<=list2.val){
                curr.next=list1;
                curr=curr.next;
                list1=list1.next;
            }else{
                curr.next=list2;
                curr=curr.next;
                list2=list2.next;                
            }
        }
        while(list1!=null){
                curr.next=list1;
                curr=curr.next;
                list1=list1.next;
        }
        while(list2!=null){
                curr.next=list2;
                curr=curr.next;
                list2=list2.next;
        }
        return dummy.next;
    }
    
    ListNode findMiddle(ListNode head){
        ListNode ptr1=head,ptr2=head;
        while(ptr2.next!=null && ptr2.next.next!=null){
            ptr1=ptr1.next;
            ptr2=ptr2.next.next;
        }
        return ptr1;
    }
}
public class MergeSort{
    static void doMergeSort(int [] arr,int l,int h){
	if(h>l){
        	int mid=(l+(h-l)/2);
		doMergeSort(arr,l,mid);
		doMergeSort(arr,mid+1,h);
		merge(arr,l,mid,h);
	}
    }
	
    static void merge(int[] arr,int l,int mid,int high){
	int[] left=new int[mid-l+1];
	int[] right=new int[high-(mid+1)+1];
	for(int i=l;i<=mid;++i){
		left[i-l]=arr[i];
	}
	for(int i=mid+1;i<=high;++i){
		right[i-(mid+1)]=arr[i];
	}
	int indexL=0; int indexR=0; int mainIndex=l;
	while(indexL<left.length && indexR<right.length){
		if(left[indexL]<right[indexR]){
			arr[mainIndex++]=left[indexL++];
		}else{
			arr[mainIndex++]=right[indexR++];
		}
	}
	while(indexL<left.length){
		arr[mainIndex++]=left[indexL++];
	}
	while(indexR<right.length){
		arr[mainIndex++]=right[indexR++];
	}

    }		

    static void printAll(int[] arr){
        System.out.print("\nAll Elements after partitioning are : ");
        for(int i=0;i<arr.length;++i){
            System.out.print(arr[i]+"-");
        }
    }

    public static void main(String args[]){
        int [] arr={12,2132,12,3,1,32,53,1,212,42};
        doMergeSort(arr,0,arr.length-1);
        printAll(arr);
    }

}


File: TwoSum.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
/*
Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
*/

import java.util.Arrays;
class TwoSum{
    public int[] twoSumUsingSorting(int[] nums, int target) {
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;++i){
            map.put(nums[i],i);
        }
        Arrays.sort(nums);
        int l=0,h=nums.length-1,currSum;
        while(l<h){
            currSum=nums[l]+nums[h];
            if(currSum==target){
                break;
            }
            if(currSum>target) --h;
            else ++l;
        }
        int [] result={map.get(nums[l]),map.get(nums[h])};
        return result;
    }

class Solution {
    public int[] twoSum(int[] nums, int target) {
        int l=0,h=nums.length-1;
        while(l<h){
            int sum=nums[l]+nums[h];
            if(sum==target){
                int[] ans={l+1,h+1};
               return ans; 
            } 
            else if(sum>target){
                --h;
            }else if(sum<target){
                ++l;
            }
        }
        return null;
    }
}

    public static int[] twoSumUsingHashMap(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int[] result = new int[2];
        for (int i = 0; i < nums.length; ++i) {
            if (map.containsKey(target - nums[i])) {
                result[1] = i;
                result[0] = map.get(target - nums[i]);
                break;
            }
            map.put(nums[i], i);
        }
        return result;
    }

class Solution {//Revision
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map=new HashMap<>();
        int [] result=new int[2];
        for(int i=0;i<nums.length;++i){
            if(map.containsKey(target-nums[i])){
                result[1]=i;
                result[0]=map.get(target-nums[i]);
                break;
            }
            map.put(nums[i],i);
        }
        return result;
    }
}
}

File: MinimumSwapsToSortAnArray.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
/*
You are given an unordered array consisting of consecutive integers  [1, 2, 3, ..., n] without any duplicates. You are allowed to swap any two elements. You need to find the minimum number of swaps required to sort the array in ascending order.
*/    
static int minimumSwaps(int[] arr) {
        int count=0;
        boolean [] visited=new boolean[arr.length+1]; 
        for(int i=0;i<arr.length;++i){
            if(visited[i+1]==false){
               visited[i+1]=true;
               if(arr[i]==i+1)continue;
               else{
                   int next=arr[i];
                   while(visited[next]!=true){
                       visited[next]=true;
                       ++count;
                       next=arr[next-1];
                   }
               }
            }
        }
        return count;
    }


File: QuickSortPartition.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public int findKthLargest(int[] nums, int k) {
        sort(nums,0,nums.length);
        return nums[nums.length-k];
    }

    void sort(int[] nums,int l,int h){
      if(l>=h) return ;
      int j=partition(nums,l,h);
      sort(nums,l,j);
      sort(nums,j+1,h);
    }

    int partition(int[] arr,int l,int h){
      int pivot=arr[l];
      int i=l,j=h;
      while(i<h){
        do{
          ++i;
        }while(i<arr.length && arr[i]<=pivot);

        do{
          --j;
        }while(j>=0 && arr[j]>pivot);

        if(j<i){
          break;
        }else{
          swap(i,j,arr);
        }
      }
      swap(l,j,arr);
      return j;
    }

    void swap(int i,int j,int[] arr){
      int temp=arr[i];
      arr[i]=arr[j];
      arr[j]=temp;
    }
}

public class QuickSortPartition{//o(nlogn) // do not use extra memory space other than recursion stack merge sort use memory space for left and right array while merging
					   //in merge sort left and right array are sorted while merging so need to pick one by one from each array for merging
					   // both follow divide nd concur		
    static void doQuickSort(int [] arr,int l,int h){
        int p;
        if(l<h){
            p=doPartition(arr,l,h); //p is pivot at its right place
            doQuickSort(arr,l,p); //p->sorted element
            doQuickSort(arr,p+1,h); //h->infi
        }
    }

    static int doPartition(int [] arr,int l,int h){   //11,1,6,2,21
        int pivot=arr[l];
        int i=l,j=h;
        while(i<j){
            do{
                i++;
            }
            while(i<arr.length && arr[i]<=pivot);
            do{
                j--;
            }
            while(arr[j]>pivot);
            if(j<i) {
                break;
            }else{
                int temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
        }
        int temp2=arr[l];
        arr[l]=arr[j];
        arr[j]=temp2;
        return j;
    }

    static void printAll(int[] arr){
        System.out.print("\nAll Elements after Sorting are : ");
        for(int i=0;i<arr.length;++i){
            System.out.print(arr[i]+"-");
        }
    }

    public static void main(String args[]){
        int [] arr={12,2132,12,3,1,32,53,1,212,42};
        doQuickSort(arr,0,arr.length);
        printAll(arr);
    }

}


File: MergeSortedArray.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i=m-1,j=n-1,ptr=nums1.length-1;
        while(i>=0 && j>=0){
            int temp;
            if(nums1[i]>nums2[j]){
                temp=nums1[i--];
            }else{
                temp=nums2[j--];
            }
            nums1[ptr--]=temp;
        }
        while(i>=0){
            int temp;
            temp=nums1[i--];
            nums1[ptr--]=temp;
        }
        while(j>=0){
            int temp;
            temp=nums2[j--];
            nums1[ptr--]=temp;
        }
    }
}
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index=nums1.length-1;
        int m1=nums1.length;
        while(n>0){
            if(m==0 || nums1[m-1]<nums2[n-1]){
               nums1[index]=nums2[n-1];
               n--; 
            }else{
               nums1[index]=nums1[m-1]; 
               m--; 
            }
            index--;
        }
    }
}


File: ThreeSumSmaller.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    int ans=0;
    public int threeSumSmaller(int[] nums, int target) {
        Arrays.sort(nums);
        for(int i=0;i<=nums.length-3;++i){
            twoSum(nums,target-nums[i],i+1,nums.length-1);
        }
        return ans;
    }
    
    void twoSum(int[] nums,int target,int l,int h){
        while(l<h){
            if(nums[l]+nums[h]>=target){
                --h;
            }else{
                ans=ans+h-l;
                ++l;
            }
        }
    }
}

File: SelectionSort.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
public class SelectionSort{//o(n2) //Selection sort as it selects the lowest one in secound iteration and put at first iteration index

	static void doSelectionSort(int arr[]){
		
		for(int j=0;j<arr.length;++j){
			int min=j;
			for(int i=j;i<arr.length;++i){
				if(arr[min]>arr[i]){
					min=i;
				}
			}
			if(j!=min){
				int temp=arr[j];
				arr[j]=arr[min];
				arr[min]=temp;
			}	
		}
	}
	

	static void printAll(int[] arr){
		System.out.print("All Elements are : ");
		for(int i=0;i<arr.length;++i){
			System.out.print(arr[i]+"-");
		}
	}

	public static void main(String args[]){
		int arr[]={21,32,123,12,3,12,434,1};
		doSelectionSort(arr);
		printAll(arr);
	}

}

File: ContainsDuplicates.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        for(int i=1;i<nums.length;++i){
            if(nums[i-1]==nums[i]) return true;
        }
        return false;    
    }
}

File: NutsAndBolts.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
public class NutsAndBolts{
	
	static void quickSort(int[] nuts,int[] bolts,int l,int h){
		if(l<h){
			int pivot=partition(nuts,l,h);
			partition(bolts,l,h,nuts[pivot]);
			quickSort(nuts,bolts,l,pivot);
			quickSort(nuts,bolts,pivot+1,h);
		}
	}

	static void partition(int[] arr,int l,int h,Integer pivot){
		int i=l-1,j=h;
		while(i<h){
			do{
			 ++i;
			}while(i<(arr.length) && arr[i]<=pivot);

			do{
			 --j;
			}while(arr[j]>pivot);

			if(j>i){
			int temp=arr[i];
			arr[i]=arr[j];
			arr[j]=temp;
			}else{
			 break;
			}
			
		}
	}

	static int partition(int[] arr,int l,int h){
		int pivot=arr[l];
		int i=l,j=h;
		while(i<h){
			do{
			 ++i;
			}while(i<(arr.length) && arr[i]<=pivot);

			do{
			 --j;
			}while(arr[j]>pivot);

			if(j>i){
			int temp=arr[i];
			arr[i]=arr[j];
			arr[j]=temp;
			}else{
			 break;
			}
			
		}
		int temp2=arr[j];
		arr[j]=arr[l];
		arr[l]=temp2;
		return j;
	}
	
	static void printAll(int[] arr){
		System.out.print("\n");
		for(int i=0;i<arr.length;++i){
			System.out.print(arr[i]+" ");
		}
	}

	public static void main(String args[]){
		int nuts[]={2,1,3,4,7,6,9};
		int bolts[]={3,4,2,1,9,7,6};
		quickSort(nuts,bolts,0,nuts.length);
		printAll(nuts);
		printAll(bolts);
		
		
	}
}

File: Readme.txt
Question Type: Data-Structures-and-Algorithms-II
DSA Question: DSA problem related to: Readme
----------------------
Charity given out of duty, 
without expectation of  return, 
at the proper time and place, 
and to a worthy person is considered to be in the mode of goodness.


File: KthLargestElementInAnArray.txt
Question Type: Selection
DSA Question: DSA problem related to: KthLargestElementInAnArray
----------------------
class Solution {
    public int findKthLargest(int[] arr, int k) {
        if(arr.length==0) return 0;
        helper(arr,0,arr.length,k);
        return arr[k-1];
    }
    
    void helper(int[] arr,int l,int h,int k){
        if(l>h) return;
        int j=partition(arr,l,h,k);
        if(j==k-1) {
            return;
        }else if(j<k-1){
            helper(arr,j+1,h,k);
        }else{
            helper(arr,l,j,k);
        }
    }
    
    int partition(int[] arr,int l,int h,int k){
        int i=l,j=h,pivot=arr[l];
        while(i<j){
            do{
                ++i;
            }while(i<h && arr[i]>=pivot);
            do{
                --j;
            }while(j>=0 && arr[j]<pivot);
            if(i<j) swap(arr,i,j);
        }
        swap(arr,l,j);
        return j;
    }
    
    void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}

File: MedianOfTwoSortedArray.txt
Question Type: Selection
DSA Question: DSA problem related to: MedianOfTwoSortedArray
----------------------
    public double findMedianSortedArrays(int[] nums1, int[] nums2) { //log(min(x,y))
        if(nums1.length>nums2.length){
            return findMedianSortedArrays(nums2,nums1);
        }
        int length1=nums1.length;
        int length2=nums2.length;
        int l=0,h=length1;
        while(l<=h){
            int posX=(l+h)/2;
            int posY=(length1 + length2+1)/2-posX;
            
            int minX=(posX==0)?Integer.MIN_VALUE:nums1[posX-1];
            int maxX=(posX==length1)?Integer.MAX_VALUE:nums1[posX];
            int minY=(posY==0)?Integer.MIN_VALUE:nums2[posY-1];
            int maxY=(posY==length2)?Integer.MAX_VALUE:nums2[posY]; 
            if(minX<=maxY && minY<=maxX){
                double avg=(length1 + length2);
                avg=avg%2;
                if(avg==0.0){
                    return (double)(Math.max(minX,minY)+Math.min(maxX,maxY))/2;
                }else{
                    return Math.max(minX,minY);
                }
            }else if(maxY<minX){
                h=posX-1;
            }else if(minY>maxX){
                l=posX+1;
            }
        }
        throw new IllegalArgumentException();
    }


File: KthLargestElementInStream.txt
Question Type: Selection
DSA Question: DSA problem related to: KthLargestElementInStream
----------------------
class KthLargest {
    PriorityQueue<Integer> minPQ=new PriorityQueue<>();
    int k;
    public KthLargest(int k, int[] nums) {
        this.k=k;
        if(nums.length==0) return;
        if(k<nums.length){
            partitionHelper(k,nums,0,nums.length);            
        }
        int index=Math.min(k,nums.length);
        for(int i=0;i<index;++i){
            minPQ.add(nums[i]);
        }
    }
    
    void partitionHelper(int k,int[] nums,int l,int h){
        if(l>h) return ;
        int j=partition(nums,l,h);
        if(j==k-1) return;
        if(j<k-1){
            partitionHelper(k,nums,j+1,h);
        }else{
            partitionHelper(k,nums,l,j);
        }
    }
    
    int partition(int[] nums,int l,int h){
        int i=l,j=h;
        while(i<j){
            do{
                ++i;
            }while(i<nums.length && nums[i]>=nums[l]);  
            do{
                --j;
            }while(nums[j]<nums[l]);
            if(i>j) break;
            swap(nums,i,j);
        }
        swap(nums,l,j);
        return j;
    }
    
    void swap(int[] nums,int l,int h){
        int temp=nums[l];
        nums[l]=nums[h];
        nums[h]=temp;
    }
    
    public int add(int val) {
        if(minPQ.size()<k){
           minPQ.add(val); 
        }
        else if(minPQ.peek()<val){
            minPQ.poll();
            minPQ.add(val);
        }
        return minPQ.peek();
    }
}


File: Top K Frequent Elements.txt
Question Type: Selection
DSA Question: DSA problem related to: Top K Frequent Elements
----------------------
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int[] ans=new int[k];
        if (k == nums.length) {
            return ans=nums;
        }
        HashMap<Integer,Integer> countMap=new HashMap<>();
        for(int i=0;i<nums.length;++i){
            countMap.put(nums[i],countMap.getOrDefault(nums[i],0)+1);
        }
        nums=new int[countMap.keySet().size()];
        int m=0;
        for(Integer key:countMap.keySet()){
            nums[m]=key;
            ++m;
        }
        int j=helper(nums,k,0,nums.length,countMap);
        for(int i=0;i<ans.length;++i){
            ans[i]=nums[i];
        }
        return ans;
    }
    
    int helper(int[] nums,int k,int l,int h,Map<Integer,Integer> map){
        if(l>h) return -1;
        int j=partition(nums,l,h,map);
        if(j==k-1){
            return j;
        }else if(j>k-1){
            return helper(nums,k,l,j,map);
        }
        return helper(nums,k,j+1,h,map);
    }
    
    int partition(int[] nums,int l,int h,Map<Integer,Integer> map){
        int pivot=l,i=l,j=h;
        while(i<j){
            do{
                ++i;
            }while(i<nums.length && map.get(nums[i])>=map.get(nums[pivot]));
            do{
                --j;
            }while(j>=0 && map.get(nums[j])<map.get(nums[pivot]));
            if(i>j) break;
            int temp1=nums[i];
            nums[i]=nums[j];
            nums[j]=temp1;
        }
        int temp2=nums[pivot];
        nums[pivot]=nums[j];
        nums[j]=temp2;
        return j;
    }
}

File: 973. K Closest Points to Origin.txt
Question Type: Selection
DSA Question: DSA problem related to: 973. K Closest Points to Origin
----------------------
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        helper(points,K,0,points.length);
        int[][] result=new int[K][2];
        for(int i=0;i<K;++i){
            result[i][0]=points[i][0];
            result[i][1]=points[i][1];
        }
        return result;
    }
    
    void helper(int[][] nums, int k,int l,int h){
            int pivot=partition(nums,l,h);
            if(pivot==k-1){
                return ;
            }
            else if(k-1<pivot){
                 helper(nums,k,l,pivot);
            }else{
                 helper(nums,k,pivot+1,h);                
            }
    }
    
    int partition(int[][] nums,int l,int h){
        int[] pivot=nums[l];
        int i=l,j=h;
        while(i<j){
            do{
                ++i;
            }while(i<nums.length && getEuclideanDistance(nums[i])<=getEuclideanDistance(pivot));

            do{
               --j; 
            }while(getEuclideanDistance(nums[j])>getEuclideanDistance(pivot));
            if(i>j){
                break;
            }else{
                int[] temp1=nums[j];
                nums[j]=nums[i];
                nums[i]=temp1;
            }
        }
        int[] temp2=nums[j];
        nums[j]=pivot;
        nums[l]=temp2;  
        return j;
    }
    
    
    Double getEuclideanDistance(int ob[]){
        int x=ob[0],y=ob[1];
        int compute=x*x+y*y;
        return Math.sqrt(compute);
    }

}



File: ReverseStack.txt
Question Type: Stack
DSA Question: DSA problem related to: ReverseStack
----------------------
import java.util.Stack;

/* 1       5
 2       4
 3       3
 4       2
 5       1 
 
   
*/
class ABR{
	void reverse(Stack<Integer> s){
		if(s.isEmpty()) return;
		int pop=s.pop();
		reverse(s);
		insertAtBottom(s,pop);
	}
	private void insertAtBottom(Stack<Integer> s, int val){
		if(s.isEmpty()){
			s.push(val);
			return;
		}
		int pop=s.pop();
		insertAtBottom(s,val);
		s.push(pop);
	}

}


File: MinStack.txt
Question Type: Stack
DSA Question: DSA problem related to: MinStack
----------------------
/*
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
*/
class Node {
    Integer val; 
    Node next; 
    public Node(){} 
    public Node(Integer val){this.val=val;}
}

class MinStack {
    int size=0;
    Node top1=new Node(); 
    Node top2=new Node(Integer.MAX_VALUE); 

    public MinStack() {
        
    }
    
    public void push(int x) {
        Node newNode=new Node(x);
        newNode.next=top1; top1=newNode;
        Node newMinNode=new Node(Math.min(x,top2.val));
        newMinNode.next=top2; top2=newMinNode;
        ++size;
    }
    
    public void pop() {
        top1=top1.next; top2=top2.next; --size;
    }
    
    public int top() {
        return top1.val;
    }
    
    public int getMin() {
        return top2.val;
    }
}


File: StackUsingQueue.txt
Question Type: Stack
DSA Question: DSA problem related to: StackUsingQueue
----------------------
class MyStack {
    Queue<Integer> topCarrier,restCarrier;
    public MyStack() {
        topCarrier=new LinkedList<>();
        restCarrier=new LinkedList<>();
        
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        if(topCarrier.isEmpty()){
            topCarrier.add(x);
        }else{
            while(!topCarrier.isEmpty()){
                restCarrier.add(topCarrier.poll());
            }
            topCarrier.add(x);
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        int top=topCarrier.poll();
        while(restCarrier.size()>=2){
            topCarrier.add(restCarrier.poll());
        }
        Queue<Integer> temp=topCarrier;
        topCarrier=restCarrier;
        restCarrier=temp;
        return top;
    }
    
    /** Get the top element. */
    public int top() {
        return topCarrier.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return topCarrier.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */

File: LargestAreaInHistogram.txt
Question Type: Stack
DSA Question: DSA problem related to: LargestAreaInHistogram
----------------------
/*
Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, 
find the area of largest rectangle in the histogram.
*/
class Solution {
    Stack<Integer> stack=new Stack<Integer>();
    int maxArea=0;
    public int largestRectangleArea(int[] heights) {
        stack.push(-1);
        for(int i=0;i<heights.length;++i){
            while(stack.peek()!=-1 && heights[stack.peek()]>=heights[i]){
                maxArea=Math.max(maxArea,heights[stack.pop()]*(i-(stack.peek()+1)));
            }
            stack.push(i);
        }
        while(stack.peek()!=-1){
            maxArea=Math.max(maxArea,heights[stack.pop()]*(heights.length-(stack.peek()+1)));
        }
        return maxArea;
    }
}
//*********************************8
class Solution {   //Revised One
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> s=new Stack<>();
        s.push(-1);
        int maxArea=0;
        for(int i=0;i<heights.length;++i){
            while(s.peek()!=-1 && heights[s.peek()]>=heights[i]){// 1 2 3 4 for decreasing 3
                maxArea=Math.max(maxArea,heights[s.pop()]*(i-(s.peek()+1))); // calculate for (4<-)  , (4 & 3<-) , (2<-,3,4)   (1<-,2,3,4)
            }
            s.push(i);
        }
        while(s.peek()!=-1){ // for increasing 1 2 3 4 5 6 7
            maxArea=Math.max(maxArea,heights[s.pop()]*(heights.length-(s.peek()+1)));
        }
        return maxArea;
        
    }
}


class Solution {//Faulty
    public int largestRectangleArea(int[] arr) {
        if(arr.length==0) return 0;
        int largestArea=arr[0]*1;
        Stack<Integer> stack=new Stack<>();
        stack.push(0);
        for(int i=1;i<arr.length;++i){
                while(!stack.isEmpty()&&arr[i]<=arr[stack.peek()]){
                    int pop=stack.pop();
                    int area=stack.isEmpty()?arr[pop]*(i-0):arr[pop]*(i-pop);
                    largestArea=Math.max(largestArea,area);
                }
            stack.push(i);
        }
        while(!stack.isEmpty()){
           int pop=stack.pop();
           int area=stack.isEmpty()?arr[pop]*(arr.length-0):arr[pop]*(arr.length-pop);
           largestArea=Math.max(largestArea,area);
        }
        return largestArea;
    }
}



File: InfixExpressionEval.txt
Question Type: Stack
DSA Question: DSA problem related to: InfixExpressionEval
----------------------
class Solution {
    public int calculate(String s) {
        Stack<Integer> numbers=new Stack<>();
        Stack<Character> operators=new Stack<>();
        Boolean isPrevInt=false;
        for(char c:s.toCharArray()){
            if(c==' ') continue;
            if(c>='0' && c<='9'){
                if(isPrevInt){
                    int prev=numbers.pop();
                    numbers.push(prev*10+(c-'0'));
                }else{
                    numbers.push(c-'0');
                }
                isPrevInt=true;
            }else if(c=='('){
                operators.push(c);
                isPrevInt=false;
            }
            else if(c=='-'|| c=='+'){
                while(!operators.isEmpty() && operators.peek()!='('){
                    char oper=operators.pop();
                    int b=numbers.pop();
                    int a=numbers.pop();
                    if(oper=='+'){
                        numbers.push(a+b);
                    }else{
                        numbers.push(a-b);
                    } 
                }
                operators.push(c);
                isPrevInt=false;
            }
            else if(c==')'){
                while(operators.peek()!='('){
                    char oper=operators.pop();
                    int b=numbers.pop();
                    int a=numbers.pop();
                    if(oper=='+'){
                        numbers.push(a+b);
                    }else{
                        numbers.push(a-b);
                    }
                }
                operators.pop();  
                isPrevInt=false;
            }
        }
        while(numbers.size()!=1){
            char oper=operators.pop();
            int b=numbers.pop();
            int a=numbers.pop();
            if(oper=='+'){
                numbers.push(a+b);
            }else{
                numbers.push(a-b);
            }
        }
        return numbers.peek();
    }
}

File: StockSpanner.txt
Question Type: Stack
DSA Question: DSA problem related to: StockSpanner
----------------------
class StockSpanner {
    Stack<Integer> stack=new Stack<>();
    HashMap<Integer,Integer> map=new HashMap<>();
    int index=-1;
    public StockSpanner() {
        
    }
    
    public int next(int price) {
        ++index;map.put(index,price);
        int span=1;
        if(index!=0){
            while(!stack.isEmpty() && map.get(stack.peek())<=price){
                stack.pop();
            }
            span=stack.isEmpty()?index+1:index-stack.peek();
        }
        stack.push(index);
        return span;
    }
}

/**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner obj = new StockSpanner();
 * int param_1 = obj.next(price);
 */

File: StockSpan.txt
Question Type: Stack
DSA Question: DSA problem related to: StockSpan
----------------------
/*
import java.util.Stack;

class ABR{
	static void calculateSpan(int arr[], int n, int span[])
	{
		span[0]=1;
		Stack<Integer> stack=new Stack<>();
		stack.push(0);
		for(int i=1;i<arr.length;++i){
			while(!stack.isEmpty()&&arr[stack.peek()]<=arr[i]){
				stack.pop();
			}
			span[i]=stack.isEmpty()?(i-0+1):(i-stack.peek());
			stack.push(i);
		}
	}
}
*/


File: ValidParentheses.txt
Question Type: Stack
DSA Question: DSA problem related to: ValidParentheses
----------------------
/*
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.
*/
class ValidParentheses {
    public  boolean isValid(String s) {
        HashMap<Character,Character> map=new HashMap<>();
        map.put('(',')');
        map.put('{','}');
        map.put('[',']');
        char[] arr=s.toCharArray();
        if(arr.length==0) return true;
        Stack<Character> stack=new Stack<>();
        stack.push(arr[0]);
        for(int i=1;i<arr.length;++i){
            Character top=stack.isEmpty()?null:stack.peek();
            if(top !=null && isOpenBracket(top) && !isOpenBracket(arr[i])){
                if(map.get(top).equals(arr[i])){
                    stack.pop();
                }else {
                    return false;
                }
            }
            else {
                stack.push(arr[i]);
            }
        }
        return stack.isEmpty();
    }
     boolean isOpenBracket(char c){
        if(c=='('||c=='{'||c=='[')
            return true;
        return false;
    }
}

File: MaximumContiguousSubsequence.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MaximumContiguousSubsequence
----------------------
import java.lang.Math;


class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==0) return 0;
        int ans=nums[0];
        int start =0,end=0;
        int tillHere=nums[0];
        for(int i=1;i<nums.length;++i){
            if(tillHere+nums[i]<nums[i]){
                start=i;
            }
            tillHere=Math.max(tillHere+nums[i],nums[i]);
            if(tillHere<=0){
                start=i+1;
            }
            if(ans<tillHere){
                end=i;
            }
            ans=Math.max(ans,tillHere);
            
        }
        System.out.println(start+" ->"+ end);
        return ans;
    }
}


public class MaximumContiguousSubsequence{ // 

   	int max=Integer.MIN_VALUE;
  	public int maxSubArray(int[] nums) {
        	 helper(nums, nums.length-1);
        	 return max;
  	}

    	int helper(int[] nums,int h){
      		 if(h==0) return max= nums[0];
     		 int currMax=Math.max(nums[h],nums[h]+helper(nums,h-1));
       		 max=Math.max(max,currMax);
       		 return currMax;
    	}


	static int MCS(int arr[]){ //o(n2)
		int maxSum=Integer.MIN_VALUE;
		for(int i=0;i<arr.length;++i){
			int sum=0;
			for(int j=i;j<arr.length;++j){
				sum=sum+arr[j];
				maxSum=Math.max(maxSum,sum); // capture every max value
			}
		}
		return maxSum;
	}

	static int MCSLinear(int arr[]){ //o(n)
		
		int [] A=new int[arr.length];
		A[0]=arr[0];
		int maxSum=arr[0];
		for(int i=1;i<arr.length;++i){
			A[i]=Math.max(arr[i]+A[i-1],arr[i]);
			maxSum=Math.max(maxSum,A[i]); // capture every max value

		}
		return maxSum;
	}

    static int solve(String S){ // linear revised
        char[] A=S.toCharArray();
        HashMap<Character,Integer> map=new HashMap<>();
        map.put('A',-1);
        map.put('C',1);
        int[] M=new int[S.length()];
        M[0]=map.get(A[0]);
        int maxSum=map.get(A[0]);
        for(int i=1;i<A.length;++i){
            M[i]=Math.abs(map.get(A[i]))>Math.abs(M[i-1]+map.get(A[i]))?map.get(A[i]):M[i-1]+map.get(A[i]);
            maxSum=Math.abs(maxSum)>Math.abs(M[i])?maxSum:M[i];
        }
        maxSum=Math.abs(maxSum);
        return maxSum;
    }
	
	public static void main(String args[]){
		int arr[]={-2,11,-4,13,-5,2};	//20	
		
		System.out.println("Max Value of Contiguous Subsequence using o(n2) - "+MCS(arr));
		System.out.println("Max Value of Contiguous Subsequence using o(n) - "+MCSLinear(arr));

	}
}

File: NumberOfDistinctSubSequence.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: NumberOfDistinctSubSequence
----------------------
int numberOfDistinctSubSequqnce(String p,String t){
    int[][] memo=new int[p.length+1][t.length+1];
    for(int i=0;i<=t.length;++i){
        memo[0][i]=1;
    }
    for(int i=1;i<=p.length;++i){
        char pc=p.charAt(i-1);
        for(int j=1;j<=t.length;++j){
            char tc=t.charAt(j-1);
              if(tc==pc){
                    memo[i][j]=memo[i-1][j-1]+memo[i][j-1];	
            }else{
                memo[i][j]=memo[i][j-1];
            }
            
        }  
    }
    
    return memo[memo.length-1][memo[0].length-1];
}


File: CoinExchange.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: CoinExchange
----------------------
class Solution {
  int maxCoins;
    public int coinChange(int[] coins, int amount) {
      Integer[][] memo=new Integer[amount+1][coins.length];
      int result=helper(coins,amount,0,memo);
      return result==Integer.MAX_VALUE?-1:result;
    }

    int helper(int[] coins,int amount,int index,Integer[][] memo){
      if(index>=coins.length || amount<0) return Integer.MAX_VALUE;
      if(amount==0) return 0;
      if(memo[amount][index]!=null) return memo[amount][index];
      int include=helper(coins,amount-coins[index],index,memo);
      if(include!=Integer.MAX_VALUE){
        include=include+1;
      }
      int exclude=helper(coins,amount,index+1,memo);
      return memo[amount][index]=Math.min(include,exclude);
    }
}

class Solution {
    Integer[] memo;
    public int coinChange(int[] coins, int amount) {
        memo=new Integer[amount+1];
        return helper(coins,amount);
    }
    
    int helper(int coins[],int amount){
        if(amount<0)return -1;
        if(memo[amount]!=null) return memo[amount];
        if(amount==0)return memo[amount]=0;
        int coinCount=Integer.MAX_VALUE;
        for(int i=0;i<coins.length;++i){
            if(coins[i]<=amount){
                int ahead=helper(coins,amount-coins[i]);
                if(ahead>=0 && ahead<coinCount){
                    coinCount=1+ahead;
                }
            }
        }
        if(coinCount==Integer.MAX_VALUE){
            return memo[amount]=-1;
        }
        return memo[amount]=coinCount;
    }
}


class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount<1) return 0;
        int[] memo=new int[amount+1];
        memo[0]=0;
        for(int i=1;i<memo.length;++i){
            memo[i]=amount+1;
        }
        for(int i=0;i<=amount;++i){//amount 5
            for(int j=0;j<coins.length;++j){//coins 2
                if(i>=coins[j]){
                    memo[i]=Math.min(memo[i],1+memo[i-coins[j]]);                    
                }
            }
        }
        return memo[amount]>amount?-1:memo[amount];
    }
}



File: MaximalSquare.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MaximalSquare
----------------------
//Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.
class Solution {
    public int maximalSquare(char[][] matrix) {
        if(matrix.length==0) return 0;
        int[][] memo=new int[matrix.length+1][matrix[0].length+1];
        int squareSize=0;
        for(int i=1;i<memo.length;++i){
            for(int j=1;j<memo[0].length;++j){
                if(matrix[i-1][j-1]=='1'){
                    memo[i][j]=Math.min(Math.min(memo[i-1][j-1],memo[i-1][j]),memo[i][j-1])+1;
                    squareSize=Math.max(squareSize,memo[i][j]);
                }
            }
        }
        return squareSize*squareSize;
    }
}

File: LongestPalindromicSubSequence.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: LongestPalindromicSubSequence
----------------------
/*
Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.
*/
class Solution {
    Integer memo[][];
    public int longestPalindromeSubseq(String s) {
        if(s.length()==0) return 0;
        memo=new Integer[s.length()][s.length()];
        return helper(s,0,s.length()-1);
    }
    
    int helper(String s,int l,int h){
        if(l>h) return 0;
        if(memo[l][h]!=null) return memo[l][h];
        if(l==h) {
            return memo[l][h]=1;
        }
        if(s.charAt(l)==s.charAt(h)){
            return memo[l][h]=2+helper(s,l+1,h-1);
        }else{
            return memo[l][h]=Math.max(helper(s,l,h-1),helper(s,l+1,h));
        }
    }
}

File: UniquePathRobot.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: UniquePathRobot
----------------------
/*
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the 
bottom-right corner of the grid (marked 'Finish' in the diagram below).
Now consider if some obstacles are added to the grids. How many unique paths would there be?
*/
class Solution {
    Integer memo[][];
    public int uniquePathsWithObstacles(int[][] arr) {
        memo=new Integer[arr.length+1][arr[0].length+1];
        return helper(arr,0,0);
    }
    
    int helper(int[][] arr,int i,int j){
        if(arr[i][j]==1){ return 0;} 
        else if(i==arr.length-1 && j==arr[0].length-1) {return 1;}
        else if (memo[i][j]!=null) return memo[i][j];
        int way=0;
        if(i+1<arr.length){
            way=way+helper(arr,i+1,j);
        }
        if(j+1<arr[0].length){
            way=way+helper(arr,i,j+1);     
        }
        memo[i][j]=way;
        return memo[i][j];
        
    }
}

class Solution {
    Integer[][] memo;
    public int uniquePathsWithObstacles(int[][] grid) {
        memo=new Integer[grid.length][grid[0].length];
        return helper(grid,0,0);
    }
    
    int helper(int[][] grid,int i,int j){
        if(i>grid.length-1||j>grid[0].length-1) return 0;
        if(memo[i][j]!=null) return memo[i][j];
        if(grid[i][j]==1) return memo[i][j]=0;
        if(i==grid.length-1 && j==grid[0].length-1){
            return memo[i][j]=1;
        }
        int count=0;
        count=count+helper(grid,i+1,j);
        count=count+helper(grid,i,j+1);
        return memo[i][j]=count;
    }
}

File: CombinationSum.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: CombinationSum
----------------------
/*
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), 
find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
*/
class Solution {
    
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result=new ArrayList<>();
        helper(candidates,0,target,result,new ArrayList<Integer>());
        return result; 
    }
    
    void helper(int[] arr,int index,int target,List<List<Integer>> result,List<Integer> temp){
        if(target<0) return;
        if(target==0){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i]){
                temp.add(arr[i]);
                helper(arr,i,target-arr[i],result,temp);
                temp.remove(temp.size()-1);
            }
        }
    }
}

File: LongestCommonSubsequence.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: LongestCommonSubsequence
----------------------
class Solution {
    
    public int longestCommonSubsequence(String text1, String text2) {
        int result[][]=new int[text1.length()+1][text2.length()+1];
        for(int i=text1.length()-1;i>=0;--i){
            for(int j=text2.length()-1;j>=0;--j){
                if(text1.charAt(i)==text2.charAt(j)){
                    result[i][j]= 1+result[i+1][j+1];
                }else{
                    result[i][j]= Math.max(result[i+1][j],result[i][j+1]);
                }
            }
        }
        return result[0][0];
    }
}

class Solution {
    Integer[][] memo;
    public int longestCommonSubsequence(String text1, String text2) {
        memo=new Integer[text1.length()][text2.length()];
        return helper(text1,text2,0,0);
    }
    
    int helper(String text1,String text2,int n,int m){
        if(n==text1.length()|| m==text2.length()) return 0;
        if(memo[n][m]!=null) return memo[n][m];
        if(text1.charAt(n)==text2.charAt(m)){
            return memo[n][m]=1+helper(text1,text2,n+1,m+1);
        }
        return memo[n][m]=Math.max(helper(text1,text2,n,m+1),helper(text1,text2,n+1,m));
    }
}

class Solution {
    
    public int longestCommonSubsequence(String text1, String text2) {
        Integer result[][]=new Integer[text1.length()+1][text2.length()+1];
       return helper(text1.toCharArray(),text2.toCharArray(),text1.length()-1,text2.length()-1,result) ;
    }
    
    int helper(char arr1[],char arr2[], int i1,int i2,Integer result[][]){
        if(i1<0 || i2<0){ return 0;}
        if(result[i1][i2]!=null) return result[i1][i2];
        else if(arr1[i1]==arr2[i2]){
           result[i1][i2]= 1+helper(arr1,arr2,i1-1,i2-1,result); 
        }else{
           result[i1][i2]= Math.max(helper(arr1,arr2,i1-1,i2,result),helper(arr1,arr2,i1,i2-1,result));
        }
        return result[i1][i2];
    }
}

File: Factorial.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: Factorial
----------------------
public class Factorial{
	static int factorial(int n){
		if(n==0 || n==1) return 1;
		return n*factorial(n-1);
	}

	public static void main(String args[]){
		System.out.print("factorial of 5 is :  "+factorial(5));
	}
}

File: Fibonacii.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: Fibonacii
----------------------
public class Fibonacii{
	static int fibonacii(int n){
		if(n==0)return 0;
		if(n==1) return 1;
		return fibonacii(n-1)+fibonacii(n-2);
	}

	public static void main(String args[]){
		System.out.print("fibonacii of 8 is :  "+fibonacii(8));
	}
}

File: MinDistance.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MinDistance
----------------------
class Solution {
    Integer[][] arr;
    public int minDistance(String word1, String word2) {
        arr=new Integer[word1.length()+1][word2.length()+1];
        return helper(word1,word1.length(),word2,word2.length());
    }
    
    
    int helper(String word1,int i1,String word2,int i2){
        if(arr[i1][i2]!=null) return arr[i1][i2];
        if(i1==0) return arr[i1][i2]=i2;
        if(i2==0) return arr[i1][i2]=i1;
        if(word1.charAt(i1-1)==word2.charAt(i2-1)){
            return arr[i1][i2]=helper(word1,i1-1,word2,i2-1);
        }else{
            return arr[i1][i2]=1+ Math.min(helper(word1,i1,word2,i2-1), //insetion
                    Math.min(helper(word1,i1-1,word2,i2), //deletion
                             helper(word1,i1-1,word2,i2-1))); //replace
        }
    }
}

File: MinimumPathSum.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MinimumPathSum
----------------------
/*
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the
sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
*/
class Solution {
    Integer[][] memo;
    public int minPathSum(int[][] grid) {
        memo=new Integer[grid.length+1][grid[0].length+1];
        if(grid.length==0) return 0;
        return helper(grid,0,0);
    }
    
    int helper(int[][] grid,int i,int j){
        if(memo[i][j]!=null) return memo[i][j];
        if(i==grid.length || j==grid[0].length) return  memo[i][j]= Integer.MAX_VALUE;
        if(i==grid.length-1 && j==grid[0].length-1) {
            return memo[i][j]=grid[i][j]; 
        }   
        return  memo[i][j]=grid[i][j]+Math.min(helper(grid,i+1,j),helper(grid,i,j+1));
    }
}

File: JumpGame.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: JumpGame
----------------------
/*
Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
*/

class Solution {
    public boolean canJump(int[] nums) {
        int lastGood=nums.length-1;
        for(int i=nums.length-1;i>=0;--i){
            if(i+nums[i]>=lastGood){
                lastGood=i;
            }    
        }
        return lastGood==0;
    }
}

class Solution {
    Boolean result[]=null;
    public boolean canJump(int[] nums) {
        result=new Boolean[nums.length+1];
        return helper(nums,0);
    }
    
    boolean helper(int[] nums,int i){
        if(i==nums.length-1) return true;
        if(result[i]!=null) return result[i];
        for(int j=1;j<=nums[i];++j){
            if(helper(nums,i+j)) return result[i]=true;
        }
        return result[i]=false;
    }
}

class Solution {
    boolean memo[];
    public boolean canJump(int[] nums) {
        memo=new boolean[nums.length];
        memo[nums.length-1]=true;
        for(int i=nums.length-2;i>=0;--i){
            for(int j=1;j<=nums[i];++j){
                if(i+j<nums.length && memo[i+j]==true){
                    memo[i]=true;
                    break;
                }
            }
        }
        return memo[0];
    }
}



File: ClimbStairs.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: ClimbStairs
----------------------
class Solution {
    Integer[] ways;
    public int climbStairs(int n) {
        ways=new Integer[n+1];
        ways[0]=0;
        if(n<3) return n;
        ways[1]=1;
        ways[2]=2;
        for(int i=3;i<=n;++i){
            ways[i]=ways[i-1]+ways[i-2];
        }
        return ways[n];
    }
}

class Solution {
    Integer counter[]=null;
    public int climbStairs(int n) {
        counter=new Integer[n+1];
        return help(n);
    }
    
    public int help(int n){
        if(n<0)return 0;
        if(counter[n]!=null) return counter[n];
        if(n==0) return counter[n]=1;
        return counter[n]=(help(n-2)+help(n-1));
    }
}


File: DP Revision Notes.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: DP Revision Notes
----------------------
Solved List:-
1)Factorial -------------------- fact(n)=n*fact(n-1); (n=0 || n=1)->1
2)Fibonaci --------------------- fibonaci(n)=fibonaci(n-1)+fibonaci(n-2); 
3)Longest Common SubString ----- LCS(char[] arr1,char[] arr2,arr1.length-1,arr2.length-1)=
					arr1[i1]==arr[i2] -->1+LCS(arr1,arr2,i1-1,i2-1);
					else
					Max(LCS(arr1,arr2,i1-1,i2),LCS(arr1,arr2,i1,i2-1));
				
4)Maximum continuous Sub Array - MCS(int [] arr,arr.length-1) =
					max(arr[i],MCS(arr,i-1));
5)Longest Increasing SubArray  - Max(LIS[])  -> where -> LIS[i]=1+max(LIS[j]) where  (0>=j<i)
6)Coin Change ------------------ minCoinChange(int [] coins,amount) ->
					        for(j=0->coins.length){
						result[amount] = Math.min( result[amount] , minCoinChange( coins,amount-coins[j])
						}	
					//here we are repeating this for different amount leift
7)KnapSAck --------------------- take one item or not - total two decisions required
					//here we are repeating for different weight left
					//also we are pickig one item only once

File: CombinationSumII.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: CombinationSumII
----------------------
/*
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
*/
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> result=new ArrayList<>();
        helper(candidates,0,target,result,new ArrayList<Integer>());
        return result;
    }
    
    void helper(int[] arr,int index,int target,List<List<Integer>> result,List<Integer> selected){
        if(target<0){
          return;   
        }
        if(target==0){
            result.add(new ArrayList<>(selected));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i] && (i==index || arr[i]!=arr[i-1])){
                selected.add(arr[i]);
                helper(arr,i+1,target-arr[i],result,selected);
                selected.remove(selected.size()-1);
            }
        }
    }
}

File: DivisorGame.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: DivisorGame
----------------------
/*
Alice and Bob take turns playing a game, with Alice starting first.
Initially, there is a number N on the chalkboard.  On each player's turn, that player makes a move consisting of:
Choosing any x with 0 < x < N and N % x == 0.
Replacing the number N on the chalkboard with N - x.
Also, if a player cannot make a move, they lose the game.
Return True if and only if Alice wins the game, assuming both players play optimally.
 */
// Java program for implementation of
// optimal strategy for the divisor
// game using dynamic programming

public class DivisorGame {

    public static boolean divisorGame(int N) {
        Boolean[] memo =new Boolean[N+1];
        return canWin(N,memo);
    }

    static boolean canWin(int N,Boolean[] memo) {
        if(memo[N]!=null)return memo[N];
        if (N <= 1)
            return memo[N]=false;
        for (int i = 1; i * i <= N && N%i==0; i++) {
            if(!canWin(N-i,memo)){
                return memo[N]=true;
            }
        }
        return memo[N]=false;
    }

    public static void main(String[] args) {
        int N = 3;
        if (divisorGame(N))
            System.out.print("yes you can");
        else
            System.out.print("other will win");
    }
}



File: SubSetSumExistOrNot.txt
Question Type: KnapSack 01
DSA Question: DSA problem related to: SubSetSumExistOrNot
----------------------
public class SubSetSumExistOrNot {
    boolean subsetSumExist(int[] arr,int sum){
        return helper(arr,sum,0);
    }

    helper(int[] arr,int sum,int index){
        if(index>=arr.length || sum<0) return false;
        if(sum==0) return true;
        boolean exist=false;
        if(arr[index]<=sum){
            exist=helper(arr,sum-arr[index],index+1);
        }
        if(exist) return true;
        return helper(arr,sum,index+1);
    }
}

public class SubSetSumExistOrNot {
    boolean subsetSumExist(int[] arr,int sum){
        if(sum==0) return true;
        if(sum<0 || arr.length==0) return false;
        boolean[][] memo=new boolean[arr.length][sum+1];
        for(int i=0;i<arr.length;++i){
            memo[i][0]=true;
        }
        for(int w=1;w<sum+1;++w){
            if(arr[0]==w){
                memo[0][w]=true;
            }
        }
        for(int i=1;i<arr.length;++i){
            for(int w=1;w<sum+1;++w){
                boolean result=false;
                if(arr[i]<=w){
                    result=memo[i-1][w-arr[i]];
                }
                memo[i][w]=result||memo[i-1][w];
            }
        }
        return memo[arr.length-1][sum];
    }
}


File: KnapSack.txt
Question Type: KnapSack 01
DSA Question: DSA problem related to: KnapSack
----------------------
class Knapsack { 
	static int helper(int val[],int wt[],int weight,int i){
      	if(i<0) return 0;
        if(wt[i]>weight ) return 0;
      	return Math.max(helper(val,wt,weight,i-1),val[i]+helper(val,wt,weight-wt[i],i-1));
      	
    }  


	public static void main(String args[]) 
	{ 
		int val[] = new int[] { 60, 100, 120 }; 
		int wt[] = new int[] { 10, 20, 30 }; 
		int W = 50; 
		int n = val.length; 
		System.out.println(helper(val,wt,W,n-1));
	} 
} 

File: CountOfSubSetSum.txt
Question Type: KnapSack 01
DSA Question: DSA problem related to: CountOfSubSetSum
----------------------
public class CountOfSubSetSum {
    
    int countOfSubSetSum(int[] arr,int sum){
        return helper(arr,sum,0);
    }

    helper(int[] arr,int sum,int index){
        if(index>=arr.length || sum<0) return 0;
        if(sum==0) return 1;
        int count=0;
        if(arr[index]<=sum){
            count=helper(arr,sum-arr[index],index+1);
        }
        return count+helper(arr,sum,index+1);
    }
}

public class CountOfSubSetSum {
    
    int countOfSubSetSum(int[] arr,int sum){
        if(sum==0 || arr.length==0) return 0;
        Integer[][] memo=new Integer[arr.length][sum+1];
        for(int i=0;i<arr.length;++i){
            memo[i][0]=1;
        }
        for(int w=1;w<sum+1;++w){
            if(arr[i]==sum)
            memo[0][w]=1;
        }
        for(int i=1;i<arr.length;++i){
            for(int w=1;w<sum+1;++w){
                int count=0;
                if(arr[i]<=w){
                    count=memo[i-1][w-arr[i]];
                }
                count=count+memo[i-1][w];
                memo[i][w]=count;
            }
        }
        return memo[arr.length-1][sum];
    }
}

File: WordBreak.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: WordBreak
----------------------
class Solution { //Faulty Code first attempt
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set=new HashSet<>();
        wordDict.forEach(word->{
          set.add(word);  
        });
        int l=0,h=0;
        int lastFoundindex=-1;
        while(h<s.length()){
            String subString=s.substring(l,h+1);
            if(set.contains(subString)){
                lastFoundindex=h;
                l=h+1;
                ++h;
            }else{
                ++h;
            }
        }
        return lastFoundindex==s.length()-1;
    }
}

class Solution {
    Boolean[] memo;
    public boolean wordBreak(String s, List<String> wordDict) {
        memo=new Boolean[s.length()+1];
        return helper(new HashSet(wordDict),s,0);
    }
    
    boolean helper(Set<String> set,String s,int start){
        if(memo[start]!=null) return memo[start];
        if(start==s.length()) return true;
        for(int end=start;end<s.length();++end){
            if(set.contains(s.substring(start,end+1)) && helper(set,s,end+1)){
                return true;
            }
        }
        return memo[start]=false;
    }
}

class Solution {
    HashMap<String,Boolean> map=new HashMap<>();
    public boolean wordBreak(String s, List<String> wordDict) {
        if(map.containsKey(s)) return map.get(s);
        if(s.length()==0){
            map.put(s,true);
            return true; 
        }
        Set<String> set=new HashSet(wordDict);
        for(int h=0;h<s.length();++h){
            if(set.contains(s.substring(0,h+1)) && wordBreak(s.substring(h+1,s.length()),wordDict)){
                map.put(s,true);
                return true;
            }            
        }
        map.put(s,false);
        return false;
    }
}


File: LIS.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: LIS
----------------------
class Solution {
    public int lengthOfLIS(int[] nums) {
        int LIS[]=new int[nums.length];
        if(nums.length==0) return 0;
        LIS[0]=1;
        for(int i=1;i<nums.length;++i){
            LIS[i]=1;
            for(int j=0;j<i;++j){
                if(nums[j]<nums[i]){
                   LIS[i]=Math.max(LIS[i],LIS[j]+1); 
                }
            }
        }
        int result=Integer.MIN_VALUE;
        for(int i=0;i<LIS.length;++i){
            result=Math.max(result,LIS[i]);
        }
        return result;
    }
}

class Solution {
    int[] LIS;
    public int lengthOfLIS(int[] nums) {
        LIS=new int[nums.length+1];
        for(int j=0;j<nums.length;++j){
            LIS[j]=1;
        }
        for(int i=1;i<nums.length;++i){
            helper(nums,i);
        }
        int lis=Integer.MIN_VALUE;
        for(int j=0;j<LIS.length;++j){
            lis=Math.max(lis,LIS[j]);
        }
        return lis;
    }
    
    void helper(int[] nums,int i){
        for(int j=0;j<i;++j){
           if(nums[i]>nums[j]){
               LIS[i]=Math.max(LIS[i],1+LIS[j]);
           } 
        }
    }
}

File: MinimumCoinChange.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MinimumCoinChange
----------------------
class Solution {
   
    public int coinChange(int[] coins, int amount) {
         Integer [] arr=new Integer[amount+1];
        int result=  helper(coins,amount,arr);
        if(result==Integer.MAX_VALUE) return -1;
        return result;
    }
    
    int helper(int[] coins,int amount,Integer [] arr){
        if (amount < 0) return -1;
        if(arr[amount]!=null) return arr[amount];
        if(amount==0) return arr[amount]=0; 
        arr[amount]= Integer.MAX_VALUE;
        for(int i=0;i<coins.length;++i){
            if(coins[i]>amount) continue;
            arr[amount]=Math.min(arr[amount],helper(coins,amount-coins[i],arr));
        }
        arr[amount]=(arr[amount]==Integer.MAX_VALUE)?arr[amount]:arr[amount]+1;
        return arr[amount];
    }
}

File: JumpGameII.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: JumpGameII
----------------------
class Solution {   //Jump Games2              
    public int jump(int[] nums) {
        int jump=0;
        int maxPos=0;
        int nextIndex=0;
        for(int i=0;i<nums.length-1;++i){
            maxPos=Math.max(maxPos,i+nums[i]);
            if(i==nextIndex){
                nextIndex=maxPos;
                ++jump;
            }
        }
        return jump;
    }
}

class Solution {//Not optimal
    Integer memo[];
    public int jump(int[] nums) {
        memo=new Integer[nums.length+1];
        return helper(nums,0);
    }
    int helper(int[] nums,int index){
        if(index>=nums.length) return nums.length+1;
        if(memo[index]!=null) return memo[index];
        if(index==nums.length-1) return 0;
        int ans=nums.length+1;
        for(int i=nums[index];i>=1;--i){
            ans=Math.min(ans,1+helper(nums,index+i));
        }
        return memo[index]=ans;
    }
}



File: LongestPalindromeSubString.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: LongestPalindromeSubString
----------------------
/*
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
*/
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()<1 || s==null) return "";
        int left=0,right=0;
        for(int i=0;i<s.length();++i){
            int len1=lengthOfPalindromeExpandingFromCentreIndex(i,i,s);
            int len2=lengthOfPalindromeExpandingFromCentreIndex(i,i+1,s);
            int len=Math.max(len1,len2);
            if(right-left+1<len){
                left=i-(len-1)/2;
                right=i+len/2;
            }
        }
        return s.substring(left,right+1);
    }
    
    int lengthOfPalindromeExpandingFromCentreIndex(int center1,int center2,String s){
        if(center1>center2 || s==null) return 0;
        while(center1>=0 && center2<s.length() && s.charAt(center1)==s.charAt(center2)){
            --center1;
            ++center2;
        }
        return center2-center1-1;
    }
}


File: MaximumSubSequenceArrayRobber.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MaximumSubSequenceArrayRobber
----------------------
class Solution {
    public int rob(int[] nums) {
        if(nums.length==0) return 0;
        int A[]=new int[nums.length+1];
        A[0]=nums[0];
        if(nums.length==1) return A[nums.length-1];
        A[1]=Math.max(nums[0],nums[1]);
        for(int i=2;i<nums.length;++i){
            A[i]=Math.max(nums[i]+A[i-2],A[i-1]);
        }
        return A[nums.length-1];
    }
}

File: KnapSackUnlimtited.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: KnapSackUnlimtited
----------------------
class Solution {
    static int knapSack(int val[], int wt[], int capacity) {
      Integer[][] memo=new Integer[capacity+1][val.length];
      return helper(val,wt,capacity,0,memo);
    }
    static int helper(int[] val,int wt[],int capacity,int index,Integer[][] memo){
      if(capacity<0) return Integer.MIN_VALUE;
      if(index>=val.length || capacity==0) return 0;
      if(memo[capacity][index]!=null) return memo[capacity][index];
      int include=Integer.MIN_VALUE;
      if(capacity>=wt[index]){
          include=val[index]+helper(val,wt,capacity-wt[index],index,memo);
      }
      int exclude=helper(val,wt,capacity,index+1,memo);
      return memo[capacity][index]=Math.max(include,exclude);
    }
}

int maxProfit(int[] W,int[] P,int C){

	helper(W,P,C,0);
}

int helper(int[] W,int[] P,int C,int index){
	if(C<=0 || index>=W.length) return 0;
	if(memo[index][C]!=null) return memo[index][C];
	int profit1=0;
	if(C>=W[index]){
		profit1=P[index]+helper(W,P,C-W[index],index);
	}
	int profit2=helper(W,P,C,index+1);
	return Math.max(profit1,profit2);
}

int maxProfit(int[] W,int[] P,int C){
	if(C<=0 || W.length==0 || W.length!=P.length) return 0;
	Integer memo[][]=new Integer[W.length][C+1];
        for(int i=0;i<P.length;++i){
		memo[i][0]=0;
	}
	for(int i=0;i<P.length;++i){
		for(int w=1;w<C+1;++w){
			int profit1=0;
			if(W[i]<=w){
				profit1=P[i]+memo[i][w-W[i]];
			}
			int profit2=0;
			if(i>0){
				profit2=memo[i-1][w];
			}
			memo[i][w]=Math.max(profit1,profit2);
		}
	}
	return memo[W.length-1][C];
}


File: CoinChangeWays.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: CoinChangeWays
----------------------
/*
Denominations: {1,2,3}
Total amount: 5
Output: 5
Explanation: There are five ways to make the change for '5', here are those ways:
  1. {1,1,1,1,1} 
  2. {1,1,1,2} 
  3. {1,2,2}
  4. {1,1,3}
  5. {2,3}
  */
public class CoinChangeWays {
    Integer[][] memo;
    int coinChangeWays(int[] coins,int total){
        memo=new Integer[coins.length][total+1];
        return helper(coins,total,coins.length-1);
    }

    int helper(int[] coins,int total,int index){
        if(total==0) return 1;
        if(index==-1 || total<0) return 0;
        if(memo[index][total]!=null) return memo[index][total];
        int ways=0;
        if(coins[index]<=total){
            ways=helper(coins,total-coins[index],index);
        }
        return memo[index][total]=ways+helper(coins,total,index-1);
    }
}


File: CoinChangeMinCount.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: CoinChangeMinCount
----------------------
public class CoinChangeMinCount {
    Integer[][] memo;
    Integer max;
    int minCoinChangeCount(int[] coins,int total){
        memo=new Integer[coins.length][total+1];
        max=total+1;
        int ans=helper(coins,total,coins.length-1);
        if(ans>=max) return -1;
        return ans;
    }

    int helper(int[] coins,int total,int index){
        if(total==0) return 0;
        if(index==-1 || total<0) return max;
        if(memo[index][total]!=null) return memo[index][total];
        int count1=max;
        if(coins[index]<=total){
            int local=1+helper(coins,total-coins[index],index);
            count1=Math.min(count1,local);
        }
        int count2=helper(coins,total,index-1);
        return memo[index][total]=Math.min(count1,count2);
    }
}

File: MaximumRibbonCutCount.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: MaximumRibbonCutCount
----------------------
/*
n: 7
Ribbon Lengths: {2,3}
Output: 3
Explanation: Ribbon pieces will be {2,2,3}.
*/


int maxRibbonPieceCutCount(int[] valid,int length){
    int count=helper(valid,length,valid.length-1);
    if(count<0) return -1;
    return count;
}

int helper(int[] valid,int length,int index){
     if(length==0) return 0; 
     if(index==-1 || length<0) return -1;
     int count1=-1;
     if(valid[index]<=length){
         int temp=1+helper(valid,length-valid[index],index);
         if(temp>=0){
             count1=1+temp;
         }
     }
     int count2=helper(valid,length,index-1);
     return Math.max(count1,count2);
}

                            


File: RodCutting.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: RodCutting
----------------------
int maxProfit(int[] L,int[] P,int length){
	helper(L,P,length,0);
}

int helper(int[] L,int[] P,int length,int index){
	if(length<=0 || index>=L.length) return 0;
	if(memo[index][length]!=null) return memo[index][length];
	int profit1=0;
	if(length>=L[index]){
		profit1=P[index]+helper(L,P,length-L[index],index);
	}
	int profit2=helper(L,P,length,index+1);
	return Math.max(profit1,profit2);
}


File: SetMatrixZeroes.txt
Question Type: Matrix
DSA Question: DSA problem related to: SetMatrixZeroes
----------------------
//Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.
class Solution {
    public void setZeroes(int[][] matrix) {
        boolean row=false,col=false;
        for(int i=0;i<matrix.length;++i){
            if(matrix[i][0]==0){
                col=true;
                break;
            }
        }
        for(int j=0;j<matrix[0].length;++j){
            if(matrix[0][j]==0){
                row=true;
                break;
            }
        }
            
        for(int i=0;i<matrix.length;++i){
            for(int j=0;j<matrix[0].length;++j){
              if(matrix[i][j]==0){
                    matrix[i][0]=0;
                    matrix[0][j]=0;
              }  
            }
        }
        for(int i=1;i<matrix.length;++i){
            for(int j=1;j<matrix[0].length;++j){
                  if(matrix[i][0]==0 || matrix[0][j]==0){
                      matrix[i][j]=0;
                  }  
            }
        }
        if(col){
            for(int i=0;i<matrix.length;++i){
                matrix[i][0]=0;
            }            
        }

        if(row){
            for(int j=0;j<matrix[0].length;++j){
                matrix[0][j]=0;
            }            
        }

    }  
}


class Solution {//Wrong Approach
    public void setZeroes(int[][] matrix) {
        for(int i=0;i<matrix.length;++i){
            for(int j=0;j<matrix[0].length;++j){
                if(matrix[i][j]==0){
                    Line(matrix,i,j);
                }
            }
        }
        
        for(int i=0;i<matrix.length;++i){
            for(int j=0;j<matrix[0].length;++j){
                if(matrix[i][j]==-1000000){
                    matrix[i][j]=0;
                }
            }
        }
    }
    
    void Line(int[][] matrix,int i,int j){
        for(int m=0;m<matrix.length;++m){
            if(m!=i && matrix[m][j]!=0){
                matrix[m][j]=-1000000;
            }
        }
        for(int m=0;m<matrix[0].length;++m){
            if(m!=j && matrix[i][m]!=0){
                matrix[i][m]=-1000000;
            }
        }
    }
}


File: TheGameOfLife.txt
Question Type: Matrix
DSA Question: DSA problem related to: TheGameOfLife
----------------------
/*
According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."

Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

Any live cell with fewer than two live neighbors dies, as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population..
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.
*/
class Solution {
    Boolean visited[][];
    int x[]={0,0,1,-1,-1,1,1,-1};
    int y[]={1,-1,0,0,1,-1,1,-1};
    public void gameOfLife(int[][] board) {
        visited=new Boolean[board.length][board[0].length];
        helper(board);
        restoreUpdateValues(board);
    }
    
    void restoreUpdateValues(int[][] board){
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]==-1){board[i][j]=0;}
                if(board[i][j]==2){board[i][j]=1;}
            }
        }        
    }
    
    void helper(int[][] board){
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(visited[i][j]==null){
                    DFS(board,i,j);      
                }
            }
        }
    }
    
    void DFS(int[][] board,int i,int j){
        visited[i][j]=true;
        int count=sourroundingOneCount(board,i,j);
        if(board[i][j]==1&&count<2){
            board[i][j]=-1;
        }else if(board[i][j]==1&&(count==2 || count==3)){
            board[i][j]=board[i][j];
        }else if(board[i][j]==1 && count>3){
            board[i][j]=-1;
        }else if(board[i][j]==0 && count==3){
            board[i][j]=2;
        }
        for(int m=0;m<x.length;++m){
            if(isSafe(board,i+x[m],j+y[m])){
                DFS(board,i+x[m],j+y[m]);
            }
        }
    }
    
    int sourroundingOneCount(int[][] board,int i,int j){
        int count=0;
        for(int m=0;m<x.length;++m){
            int currI=i+x[m]; int currJ=j+y[m];
            if(isSafeW(board,currI,currJ)){
                if(board[currI][currJ]==1 || board[currI][currJ]==-1) ++count;
            }
        }
        return count; 
    }
    
    boolean isSafeW(int[][] board,int i,int j){
        return (i>=0 && i<board.length) && (j>=0 && j<board[0].length);
    }
    boolean isSafe(int[][] board,int i,int j){
        return (i>=0 && i<board.length) && (j>=0 && j<board[0].length) && visited[i][j]==null;
    }
    
    
}

File: SearchMatrix.txt
Question Type: Matrix
DSA Question: DSA problem related to: SearchMatrix
----------------------
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix.length==0) return false;
        int i=0;
        int j=matrix[0].length-1;
        while(i<=matrix.length-1 && j>=0){
            if(matrix[i][j]==target) return true;
            else if(matrix[i][j]>target) j--;
            else if(matrix[i][j]<target) i++;
        }
        return false;
    }
}

File: CaptureRegions.txt
Question Type: Matrix
DSA Question: DSA problem related to: CaptureRegions
----------------------
/*
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.
*/
class Pair{
    public int i;
    public int j;
    
    public Pair(int i,int j){
        this.i=i;
        this.j=j;
    }
}
class Solution {
    public void solve(char[][] board) {
        if(board.length==0) return;
        List<Pair> list=new ArrayList<>();
        for(int i=0;i<board.length;++i){
            list.add(new Pair(i,0));
            list.add(new Pair(i,board[0].length-1));
        }
        for(int i=0;i<board[0].length;++i){
            list.add(new Pair(0,i));
            list.add(new Pair(board.length-1,i));
        }
        for(Pair pair:list){
            DFS(board,pair.i,pair.j);
        }
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]=='O'){
                 board[i][j]='X';                    
                }else if(board[i][j]=='#'){
                 board[i][j]='O';
                }
            }
        }
    }
    
    void DFS(char[][] board,int i,int j){
        if(board[i][j]!='O') return;
        int []x={0,0,1,-1};
        int []y={1,-1,0,0};
        board[i][j]='#';
        for(int m=0;m<x.length;++m){
            if(isSafe(board,i+x[m],j+y[m])){
                DFS(board,i+x[m],j+y[m]);
            }
        }
    }
    
    boolean isSafe(char[][] board,int i,int j){
        return i>=0 && i<board.length && j>=0 && j<board[0].length && board[i][j]=='O';
    }
}

File: RobotPathWithoutObstructuion.txt
Question Type: Matrix
DSA Question: DSA problem related to: RobotPathWithoutObstructuion
----------------------
/*
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
*/
class Solution {
    Integer memo[][];
    public int uniquePaths(int m, int n) {
        memo=new Integer[m][n];
        return helper(m,n,0,0);
    }
    
    int helper(int m,int n,int i,int j){
        if(i>=m || j>=n) return 0;
        if(i==m-1 && j==n-1) return 1;
        if(memo[i][j]!=null) return memo[i][j];
        int possibleWays=0;
        possibleWays=possibleWays+helper(m,n,i+1,j)+helper(m,n,i,j+1);
        return memo[i][j]=possibleWays;
    }
}

File: Flood Fill.txt
Question Type: Matrix
DSA Question: DSA problem related to: Flood Fill
----------------------
class Solution {
    /*
An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).

Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.

To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.

At the end, return the modified image.
    */
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        boolean visited[][] =new boolean[image.length][image[0].length];
        dfs(image,visited,sr,sc,image[sr][sc],newColor);
        return image;
    }
    
    void dfs(int[][] image,boolean visited[][], int x, int y, int colorToReplace,int newColor){
        image[x][y]=newColor;
        visited[x][y]=true;
        int[] xx={0,0,1,-1};
        int[] yy={1,-1,0,0};
        for(int i=0;i<xx.length;++i){
            if(!isSafe(image,visited,x+xx[i],y+yy[i],colorToReplace)) continue;
            dfs(image,visited,x+xx[i],y+yy[i],colorToReplace,newColor);
        }
        visited[x][y]=false;
    }
    
    boolean isSafe(int[][] image,boolean visited[][], int x, int y, int colorToReplace){
        return x>=0 && x<image.length && y>=0 && y<image[0].length && !visited[x][y] && 
            image[x][y]==colorToReplace;
    }
}

File: UniquePathRobot.txt
Question Type: Matrix
DSA Question: DSA problem related to: UniquePathRobot
----------------------
/*
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?
*/
class Solution {
    Integer memo[][];
    public int uniquePathsWithObstacles(int[][] arr) {
        memo=new Integer[arr.length+1][arr[0].length+1];
        return helper(arr,0,0);
    }
    
    int helper(int[][] arr,int i,int j){
        if(arr[i][j]==1){ return 0;} 
        else if(i==arr.length-1 && j==arr[0].length-1) {return 1;}
        else if (memo[i][j]!=null) return memo[i][j];
        int way=0;
        if(i+1<arr.length){
            way=way+helper(arr,i+1,j);
        }
        if(j+1<arr[0].length){
            way=way+helper(arr,i,j+1);     
        }
        memo[i][j]=way;
        return memo[i][j];
        
    }
}

File: WordSearch2.txt
Question Type: Matrix
DSA Question: DSA problem related to: WordSearch2
----------------------
/*
Given a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally 
or vertically neighboring. The same letter cell may not be used more than once in a word.
*/
class Solution {

    public List<String> findWords(char[][] board, String[] words) {
        List<String> ans=new ArrayList<>();
        if(words.length==0) return ans;
        for(String word:words){
            if(exist(board,word)){
                ans.add(word);
            }
        }
        return ans;
    }
    Boolean visited[][];
    private boolean exist(char[][] board, String word) {
        boolean visited[][] =new boolean[board.length][board[0].length];
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]==word.charAt(0)){
                    if(dfs(board,visited,i,j,word,0)){
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    boolean dfs(char[][] board,boolean visited[][],int x,int y,String word,int index){
        if(index==word.length()-1) return true;
        visited[x][y]=true;
        int[] xx={0,0,1,-1};
        int[] yy={1,-1,0,0};
        for(int i=0;i<xx.length;++i){
            if(!isSafe(board,visited,x+xx[i],y+yy[i],word,index+1)) continue;
            if(dfs(board,visited,x+xx[i],y+yy[i],word,index+1)){
                return true;
            }
        }
        visited[x][y]=false;
        return false;
    }
    
    boolean isSafe(char[][] board,boolean visited[][], int x, int y,String word,int index){
        return x>=0 && x<board.length && y>=0 && y<board[0].length && !visited[x][y] && 
            board[x][y]==word.charAt(index);
    }
    
}


class Solution {
    Boolean[][] visited;
    public List<String> findWords(char[][] board, String[] words) {
        List<String> list=new LinkedList<>();
        for(int i=0;i<words.length;++i){
            if(wordSearch(board,words[i].toCharArray())){
                list.add(words[i]);
            }
        }
        return list;
    }
    
    Boolean wordSearch(char[][] board, char[] words){
        visited=new Boolean[board.length][board[0].length];
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(visited[i][j]==null && words[0]==board[i][j]){
                    visited[i][j]=true;
                    if(DFS(board,i,j,words,0)){return true;}
                    visited[i][j]=null;                    
                }
            }
        }
        return false;
    }
    
    Boolean DFS(char[][] board,int i,int j,char[] words,int n){
        int[] x={0,0,-1,1};
        int[] y={1,-1,0,0};
        if(n==words.length-1) return true;
        for(int m=0;m<x.length;++m){
            if(isSafe(board,i+x[m],j+y[m],words,n+1)){
                visited[i+x[m]][j+y[m]]=true;
                if(DFS(board,i+x[m],j+y[m],words,n+1)){return true;}
                visited[i+x[m]][j+y[m]]=null;
            }
        }
        return false;
    }
    
    Boolean isSafe(char[][] board,int i,int j,char[] words,int n){
        return (i>=0 && i<board.length && j>=0 && j<board[0].length && visited[i][j]==null 
                && n<words.length && words[n]==board[i][j]);
    }
    
}

File: RottingOrangeTime.txt
Question Type: Matrix
DSA Question: DSA problem related to: RottingOrangeTime
----------------------
class Solution {
    public int orangesRotting(int[][] grid) {
        Integer[][] time=new Integer[grid.length][grid[0].length];
        boolean[][] visited=new boolean[grid.length][grid[0].length];
        for(int i=0;i<grid.length;++i){
            for(int j=0;j<grid[0].length;++j){
                if(grid[i][j]==2){
                    time[i][j]=0;
                }else if(grid[i][j]==1){
                    time[i][j]=Integer.MAX_VALUE;
                }
            }
        }
        for(int i=0;i<grid.length;++i){
            for(int j=0;j<grid[0].length;++j){
                if(grid[i][j]==2 && visited[i][j]==false){
                    visited[i][j]=true;
                    DFS(i,j,grid,visited,time,0);
                }
            }
        }
        int maxTime=0;
        for(int i=0;i<grid.length;++i){
            for(int j=0;j<grid[0].length;++j){
                if(grid[i][j]==3){
                    if(time[i][j]==null) return -1;
                    maxTime=Math.max(maxTime,time[i][j]);
                }else if(grid[i][j]==1){
                    return -1;
                }
            }
        }
        return maxTime;
    }
    
    boolean isSafe(int i,int j,boolean[][] visited,Integer[][] time,int t,int[][] grid){
        return i>=0 && i<visited.length && j>=0 && j<visited[0].length 
            && (time[i][j]!=null && t<time[i][j]) && visited[i][j]==false && (grid[i][j]==1||grid[i][j]==3);
    }
    void DFS(int i,int j,int[][] grid,boolean[][] visited,Integer[][] time,int t){
        time[i][j]=Math.min(t,time[i][j]);
        int[] x={1,-1,0,0};
        int[] y={0,0,1,-1};
        for(int m=0;m<x.length;++m){
            if(isSafe(i+x[m],j+y[m],visited,time,t+1,grid)){
                grid[i+x[m]][j+y[m]]=3;
                visited[i+x[m]][j+y[m]]= true;
                DFS(i+x[m],j+y[m],grid,visited,time,t+1);
                visited[i+x[m]][j+y[m]]= false;
            }
        }
    }
}

File: RotateMatrix.txt
Question Type: Matrix
DSA Question: DSA problem related to: RotateMatrix
----------------------
class Solution {
  public void rotate(int[][] matrix) {
    int n = matrix.length;

    // transpose matrix
    for (int i = 0; i < n; i++) {
      for (int j = i; j < n; j++) {
        int tmp = matrix[j][i];
        matrix[j][i] = matrix[i][j];
        matrix[i][j] = tmp;
      }
    }
    // reverse each row
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n / 2; j++) {
        int tmp = matrix[i][j];
        matrix[i][j] = matrix[i][n - j - 1];
        matrix[i][n - j - 1] = tmp;
      }
    }
  }
}


File: FindTheJudge.txt
Question Type: Matrix
DSA Question: DSA problem related to: FindTheJudge
----------------------
/*
In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.
*/
class Solution {
    public int findJudge(int N, int[][] trust) {
        if(trust.length==0 && N==1){
            return 1;
        }    
        List<List<Integer>> graph=new LinkedList<>();
        List<Integer> possibleJudges=new LinkedList<>();
        Integer count[] =new Integer[N+1];
        for(int i=0;i<N;++i){
            graph.add(new LinkedList<Integer>());
        }
        
        for(int i=0;i<trust.length;++i){
            count[trust[i][1]]=count[trust[i][1]]==null?1:count[trust[i][1]]+1;
            if(count[trust[i][1]]==N-1){possibleJudges.add(trust[i][1]);}
            graph.get(trust[i][0]-1).add(trust[i][1]);
        }
        for(int i=0;i<possibleJudges.size();++i){
            if(graph.get(possibleJudges.get(i)-1).size()==0) return possibleJudges.get(i); 
        }
        return -1;
    }
}

File: MaxAreaOfIsland.txt
Question Type: Matrix
DSA Question: DSA problem related to: MaxAreaOfIsland
----------------------
/*
Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected
 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)
*/
class Solution {
    Boolean visited[][];
    int maxCount=0;
    int currCount=0;
    public int maxAreaOfIsland(int[][] grid) {
        if(grid.length==0) return 0;
        visited=new Boolean[grid.length][grid[0].length];
        islandHelper(grid);
        return maxCount;
    }
    
    void islandHelper(int[][] arr){
        for(int i=0;i<arr.length;++i){
            for(int j=0;j<arr[0].length;++j){
                currCount=0;
                if(visited[i][j]==null && arr[i][j]==1){
                    DFS(i,j,arr);
                }
                maxCount=Math.max(maxCount,currCount);
            }
        }
    }
    
    void DFS(int i,int j,int[][] arr){
        visited[i][j]=true; ++currCount;
        int [] x={0,0,-1,1};
        int [] y={1,-1,0,0};
        for(int m=0;m<x.length;++m){
            if(isValid(i+x[m],j+y[m],arr)){
                DFS(i+x[m],j+y[m],arr);
            }
        }
    }
    
    Boolean isValid(int i,int j,int[][] arr){
        return (i>=0 && i<arr.length) && (j>=0 && j<arr[0].length) 
            && visited[i][j]==null && arr[i][j]==1;
    }
}

//******************************
class Solution { //revised
    Boolean visited[][]; int maxArea=0,islandSize=0;
    public int maxAreaOfIsland(int[][] matrix) {
        if(matrix.length==0) return 0;
        visited =new Boolean[matrix.length][matrix[0].length];
        for(int i=0;i<matrix.length;++i){
            for(int j=0;j<matrix[0].length;++j){
                islandSize=0;
                if(visited[i][j]==null && matrix[i][j]==1){
                    DFS(matrix,i,j);
                }
                maxArea=Math.max(maxArea,islandSize);
            }
        }
        return maxArea;
    }
    
    private void DFS(int[][] matrix,int i,int j){
        int[] x={0,0,-1,1};
        int[] y={1,-1,0,0};
        ++islandSize;
        visited[i][j]=true;
        for(int m=0;m<x.length;++m){
            if(isSafe(matrix,i+x[m],j+y[m])){
                DFS(matrix,i+x[m],j+y[m]);
            }
        }
    }
    
    Boolean isSafe(int[][] matrix,int i,int j){
        return i<matrix.length && i>=0 && j<matrix[0].length && j>=0 && visited[i][j]==null && matrix[i][j]==1;
    }
}

File: WordSearch.txt
Question Type: Matrix
DSA Question: DSA problem related to: WordSearch
----------------------
/*
Share
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or 
vertically neighboring. The same letter cell may not be used more than once.
*/
class Solution {
    Boolean visited[][];
    public boolean exist(char[][] board, String word) {
        boolean visited[][] =new boolean[board.length][board[0].length];
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]==word.charAt(0)){
                    if(dfs(board,visited,i,j,word,0)){
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    boolean dfs(char[][] board,boolean visited[][],int x,int y,String word,int index){
        if(index==word.length()-1) return true;
        visited[x][y]=true;
        int[] xx={0,0,1,-1};
        int[] yy={1,-1,0,0};
        for(int i=0;i<xx.length;++i){
            if(!isSafe(board,visited,x+xx[i],y+yy[i],word,index+1)) continue;
            if(dfs(board,visited,x+xx[i],y+yy[i],word,index+1)){
                return true;
            }
        }
        visited[x][y]=false;
        return false;
    }
    
    boolean isSafe(char[][] board,boolean visited[][], int x, int y,String word,int index){
        return x>=0 && x<board.length && y>=0 && y<board[0].length && !visited[x][y] && 
            board[x][y]==word.charAt(index);
    }
}

class Solution {
    Boolean visited[][];
    public boolean exist(char[][] board, String word) {
       visited=new Boolean[board.length][board[0].length]; 
       for(int i=0;i<board.length;++i){
           for(int j=0;j<board[0].length;++j){
               if(word.charAt(0)!=board[i][j]) continue;
               visited[i][j]=true;
               if(helper(board,word,i,j,""))  return true;
               visited[i][j]=null;
           }
       } 
       return false; 
    }
    
    Boolean helper(char[][] board, String word,int i,int j,String s){
        if(!word.contains(s+board[i][j])) return false;
        if(word.equals(s+board[i][j])) return true;
        int []x={0,0,-1,1};
        int []y={1,-1,0,0};
        for(int m=0;m<x.length;++m){
            if(!(i+x[m]<0 || j+y[m]<0 || i+x[m]>=board.length || j+y[m]>=board[0].length 
						|| visited[i+x[m]][j+y[m]]!=null)){
                visited[i+x[m]][j+y[m]]=true;
                if(helper(board,word,i+x[m],j+y[m],s+board[i][j])) return true;
                visited[i+x[m]][j+y[m]]=null; 
            } 
        }
        return false;
    }
}

File: KnightTour.txt
Question Type: Matrix
DSA Question: DSA problem related to: KnightTour
----------------------
class Solution {
    boolean visited[][] = new boolean[8][8];
    public void knightTour(int[] nums, int target) {
        solveKT();
        for(int i=0;i<visited.length;++i){
            for(int j=0;j<visited[0].length;++j){
                if(visited[i][j]==false){
                    System.out.println("False");
                    return null;
                }
            }
        }
        System.out.println("True");
    }
    
    void solveKT(){
		int xMove[] = { 2, 1, -1, -2, -2, -1, 1, 2 };
		int yMove[] = { 1, 2, 2, 1, -1, -2, -2, -1 };
		solveKTUtil(0, 0, xMove, yMove);
	}
    
	boolean isSafe(int x, int y)
	{
		return (x >= 0 && x < visited.length && y >= 0 && y < visited[0].length	&& visited[x][y] == false);
	}


	void solveKTUtil(int x, int y, int xMove[],int yMove[]){
		visited[x][y] = true;
        for (int k = 0; k < 8; k++) {
			int next_x = x + xMove[k];
			int next_y = y + yMove[k];
			if (isSafe(next_x, next_y)) {
				solveKTUtil(next_x, next_y, xMove, yMove);
			}
		}
	}
}

File: NumberOfIslands.txt
Question Type: Matrix
DSA Question: DSA problem related to: NumberOfIslands
----------------------
/*
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by 
connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water
*/
class Solution {
    Boolean visited[][];
    public int numIslands(char[][] grid) {
        if(grid.length==0) return 0;
        visited=new Boolean[grid.length][grid[0].length];
        return countHelper(grid);
    }
    
    int countHelper(char[][] arr){
        int count=0;
        for(int i=0;i<arr.length;++i){
            for(int j=0;j<arr[0].length;++j){
                if(visited[i][j]==null && arr[i][j]=='1'){
                    DFS(i,j,arr);
                    count++;
                }

            }
        }
        return count;
    }
    
    void DFS(int i,int j,char[][] arr){
        visited[i][j]=true;
        int [] x={-1,1,0,0};
        int [] y={0,0,-1,1};
        for(int m=0;m<x.length;++m){
            if(isSafe(i+x[m],j+y[m],arr)){
                DFS(i+x[m],j+y[m],arr);
            }
        }
    }
    
    boolean isSafe(int i,int j,char[][] arr){
        return (i>=0 && i<arr.length)&&(j>=0 && j<arr[0].length)&&visited[i][j]==null && arr[i][j]=='1';
    }
    
}

File: MinPathSum.txt
Question Type: Matrix
DSA Question: DSA problem related to: MinPathSum
----------------------
class Solution {
    Integer[][] memo;
    public int minPathSum(int[][] grid) {
        memo=new Integer[grid.length][grid[0].length];
        return helper(grid,0,0);
    }
    
    int helper(int[][] grid,int i, int j){
        if(i==grid.length || j==grid[0].length) return Integer.MAX_VALUE;
        if(memo[i][j]!=null) return memo[i][j];
        if(i==grid.length-1 && j==grid[0].length-1) return memo[i][j]=grid[i][j];
        int down=helper(grid,i+1,j);
        int right=helper(grid,i,j+1);
        return memo[i][j]=grid[i][j]+Math.min(down,right);
    }
}


File: output.txt
Question Type: Data-Structures-and-Algorithms-II
DSA Question: DSA problem related to: output
----------------------
File: kthSmallestBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    int count=0;
    public int kthSmallest(TreeNode root, int k) {
        return inorderHelper(root,k).val;
    }
    TreeNode inorderHelper(TreeNode root,int k){
        if(root==null) return null;
        TreeNode left=inorderHelper(root.left,k);
        if(left!=null) return left;
        count++;
        if(k==count) return root;
        return inorderHelper(root.right,k);    
    }
}

File: Validate BST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        TreeNode[] prev=new TreeNode[1];
        return helper(root,prev); 
    }

    boolean helper(TreeNode node,TreeNode[] prev){
        if(node==null) return true;
        if(!helper(node.left,prev)) return false;
        if(prev[0]!=null && node.val<=prev[0].val) return false;
        prev[0]=node;
        if(!helper(node.right,prev)) return false;
        return true;
    }
}


class Solution {
    Integer prev=null;
    public boolean isValidBST(TreeNode root) {
           if(root==null) return true;
           if(!isValidBST(root.left)) return false;
           if(prev!=null && prev>=root.val) return false;
           prev=root.val;
           if(!isValidBST(root.right)) return false;
           return true; 
            
    }    
}


File: SortedListToBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return helper(head);
    }
    
    TreeNode helper(ListNode node){
        if(node==null) return null;
        if(node.next==null) return new TreeNode(node.val);
        ListNode prev=findMiddle(node);
        ListNode middle=prev.next;
        prev.next=null;
        ListNode next=middle.next;
        middle.next=null;
        TreeNode root=new TreeNode(middle.val);
        root.left=helper(node);
        root.right=helper(next);
        return root;
    }
    
    ListNode findMiddle(ListNode node){
        ListNode f=node,s=node,prev=null;
        while(f!=null && f.next!=null){
            f=f.next.next;
            prev=s;
            s=s.next;
        }
        return prev;
    }
}


File: BSTtoGST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    int sum=0;
    public TreeNode bstToGst(TreeNode root) {
        DFS(root);
        return root;
    }
    
    void DFS(TreeNode root){
        if(root==null) return ;
        DFS(root.right);
        root.val=root.val+sum;
        sum=root.val;
        DFS(root.left);
    }
}

File: CloneABT.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class GfG{
    static Map<Integer,Tree> map=new HashMap<>();
    public static Tree cloneTree(Tree root){
        
       DFS(root);
       helper(root);
       return map.get(root.data);
     }
     
     static void DFS(Tree node){
         if(node==null) return;
         map.put(node.data,new Tree(node.data));
         helper(node.left);
         helper(node.right);
     }
     
     static void helper(Tree node){
         if(node==null) return ;
         helper(node.left);
         Tree curr=map.get(node.data);
         if(curr!=null){
             curr.random=node.random==null?null:map.get(node.random.data);
             curr.left=node.left==null?null:map.get(node.left.data);
             curr.right=node.right==null?null:map.get(node.right.data);             
         }
         helper(node.right);
     }
}

File: ListFromTwoBST_Inorder_Flatten.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*
Given two binary search trees(BST) root1 and root2.
Return a list containing all the integers from both trees sorted in ascending order.
*/
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        root1=flatten(root1);
        root2=flatten(root2);
        List<Integer> list=new LinkedList<>();
        while(root1!=null && root2!=null){
            if(root1.val>=root2.val){
                list.add(root2.val);
                root2=root2.right;
            }else{
                list.add(root1.val);
                root1=root1.right;                
            }
        }
        while(root1!=null){
                list.add(root1.val);
                root1=root1.right;
        }
        while(root2!=null){
                list.add(root2.val);
                root2=root2.right;
        }
        return list;
    }
    
    TreeNode dummy=null,prev;
    TreeNode flatten(TreeNode root){
       if(root==null) return null;
        dummy=new TreeNode(-1);
        prev=dummy;
        inorder(root);
        return dummy.right;
    }
    
    void inorder(TreeNode root){
       if(root==null) return; 
       inorder(root.left);
       prev.left=null;
       prev.right=root;
       prev=prev.right; 
       inorder(root.right);
    }
}

File: TwoSum.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*
Given two binary search trees, return True if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer target.
 */
class Solution {
    Boolean ans=false;
    public boolean twoSumBSTs(TreeNode root1, TreeNode root2, int target) {
        dfs(root1,root2,target);
        return ans;
    }
    void dfs(TreeNode root1, TreeNode root2,int target){
        if(root1==null || ans) return;
        dfs(root1.left,root2,target);
        BFSSearch(root2,target-root1.val);
        dfs(root1.right,root2,target);
    }
    
    void BFSSearch(TreeNode root2,int target){
        if(root2==null) return ;
        if(root2.val==target) {
            ans=true;
            return;
        }else if(target<root2.val){
            BFSSearch(root2.left,target);
        }else{
            BFSSearch(root2.right,target);
        }
    }
}

File: IncreasingBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    TreeNode curr;
    public TreeNode increasingBST(TreeNode root) {
        curr=new TreeNode();
        TreeNode dummy=curr;
        helper(root);
        return dummy.right;
    }
    
    void helper(TreeNode node){
        if(node==null) return ;
        helper(node.left);
        node.left=null;
        curr.right=node;
        curr=node;
        helper(node.right);        
    }
}

File: RangeSumBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    int sum=0;
    public int rangeSumBST(TreeNode root, int L, int R) {
        if(root==null) return 0;
        if(root.left!=null && root.val>=L)rangeSumBST(root.left,L,R);
        if(root.val>=L && root.val<=R) sum=sum+root.val;
        if(root.right!=null && root.val<=R)rangeSumBST(root.right,L,R);
        return sum;
    }
}

File: InvertTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode invertTree(TreeNode root) {//100
        if(root==null){
            return root;
        }
        return invert(root);
        
    }
    
    TreeNode invert(TreeNode node){
        if(node==null) return null;
        TreeNode left=invert(node.left);
        TreeNode right=invert(node.right);
        node.left=right;
        node.right=left;
        return node;
    }
}

class Solution {
    public TreeNode invertTree(TreeNode root) {//20
        helper(root);
        return root;
    }
    
    void helper(TreeNode root){
        if(root==null) return ;
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        helper(root.left);
        helper(root.right);
    }
}

File: BTMaximumPathSum.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes 
from some starting node to any node in the tree along the parent-child connections.
 The path must contain at least one node and does not need to go through the root.
 */
class Solution {
    int maxPathSum=Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
       helper(root);  
       return maxPathSum; 
    }
    
    int helper(TreeNode root){
        if(root==null) return 0;
        int left=helper(root.left);
        if(left<0){left=0;}
        int right=helper(root.right);
        if(right<0){right=0;}
        maxPathSum=Math.max(maxPathSum,root.val+left+right);
        return root.val+Math.max(left,right);
    }
        
}

class Solution {
    Integer result=Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return result;
    }
    
    int dfs(TreeNode node){
        if(node==null) return 0;
        int leftGain=Math.max(0,dfs(node.left));
        int rightGain=Math.max(0,dfs(node.right));
        result=Math.max(result,node.val+leftGain+rightGain);
        return node.val+Math.max(leftGain,rightGain);
    }
}


File: BoundaryOfBinaryTreeAnticlockwise.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.  (The values of the nodes may still be duplicates.)
Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn't have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.
The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.
The right-most node is also defined by the same way with left and right exchanged.
 */
class Solution {
    List<Integer> result=new ArrayList<>();
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        if(root==null) return result;
        result.add(root.val);
        addLeftBoundary(root.left);
        if(root.left!=null || root.right!=null){
            addLeaves(root);
        }
        addRightBoundary(root.right);
        return result;
    }
    
    void addRightBoundary(TreeNode root){
        if(root==null)return ;
        if(root.right!=null){
            addRightBoundary(root.right);
            result.add(root.val); 
        }else if(root.left!=null){
            addRightBoundary(root.left);
            result.add(root.val); 
        }     
    }
    
    void addLeftBoundary(TreeNode root){
        if(root==null)return ;
        if(root.left!=null){
            result.add(root.val);     
            addLeftBoundary(root.left);
        }else if(root.right!=null){
            result.add(root.val);     
            addLeftBoundary(root.right);
        }     
    }
    
    void addLeaves(TreeNode root){
        if(root==null)return ;
        addLeaves(root.left);
        if(root.left==null && root.right==null){
            result.add(root.val);
        }
        addLeaves(root.right);
    }
}

File: BinaryTreeAllTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
import java.util.Queue;
import java.util.LinkedList;
//		1
//	      2	  3
//         4  5   6  7
public class BinaryTreeAllTraversal{

	static void inOrderTraversal(BTNode root){
		if(root==null) return;
		inOrderTraversal(root.left);
		System.out.print(root.data+"--");
		inOrderTraversal(root.right);
	}
	
	static void preOrderTraversal(BTNode root){
		if(root==null) return;
		System.out.print(root.data+"--");
		inOrderTraversal(root.left);
		inOrderTraversal(root.right);
	}
	static void postOrderTraversal(BTNode root){
		if(root==null) return;
		inOrderTraversal(root.left);
		inOrderTraversal(root.right);
		System.out.print(root.data+"--");
	}

	static void levelOrderTraversal(BTNode root){
		Queue<BTNode> queue=new LinkedList<BTNode>();
		queue.offer(root);
		BTNode currentNode=null;
		while(!queue.isEmpty()){
			currentNode=queue.poll();
			System.out.print(currentNode.data+"--");
			if(currentNode.left!=null){
				queue.offer(currentNode.left);
			}
			if(currentNode.right!=null){
				queue.offer(currentNode.right);
			}
		}
	}

	public static void main(String args[]){
		BTNode root=new BTNode(1);
		root.left=new BTNode(2);
		root.right=new BTNode(3);
		root.left.left=new BTNode(4);
		root.left.right=new BTNode(5);
		root.right.left=new BTNode(6);
		root.right.right=new BTNode(7);

		//DFS traversals
		System.out.print("Inorder Traversal :-");inOrderTraversal(root);
		System.out.print("\nPreorder Traversal :-");preOrderTraversal(root);
		System.out.print("\nPostOrder Traversal :-");postOrderTraversal(root);
		//BFS traversals
		System.out.print("\nlevelOrder Traversal :-");levelOrderTraversal(root);
	}
}


File: NaryTreePreorderAndPostOrderTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    List<Integer> traverse=new ArrayList<>();
    public List<Integer> preorder(Node root) {
        helperPreorder(root);
        return traverse;
    }
    
    void helperPreorder(Node root){
        if(root==null) return;
        traverse.add(root.val);
        for(Node child:root.children){
            helperPreorder(child);
        }
    }
}

class Solution {
    List<Integer> traverse=new ArrayList<>();
    public List<Integer> postorder(Node root) {
        helperPostorder(root);
        return traverse;
    }
    
    void helperPostorder(Node root){
        if(root==null) return;
        for(Node child:root.children){
            helperPostorder(child);
        }
        traverse.add(root.val);
    }
}

File: isBalanceTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
public class isBalanceTree {

    static Boolean isBalanced = true;

    static boolean checkBalancedTree(Node root) {
        if (root == null)
            return true;
        postOrder(root);
        return isBalanced;
    }

    static int postOrder(Node root){
        if(isBalanced==false) return -1;
        if(root==null) return -1;
        int left=postOrder(root.left);
        int right=postOrder(root.right);
        if(Math.abs(left-right)>1){
            isBalanced=false;
        }
        return 1+Math.max(left,right);
    }
    public static void main(String[] args) {
        /* Constructed binary tree is 
                   1 
                 /   \ 
                2      3 
              /  \    / 
            4     5  6 
            / 
           7         */
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
       // root.right.right = new Node(6);
        root.left.left.left = new Node(7);

        System.out.println(checkBalancedTree(root));
    }
}

class Node {

    int data;
    Node left, right;

    Node(int d) {
        data = d;
        left = right = null;
    }
}


File: BTNode.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class BTNode{
	public int data;
	public BTNode left;
	public BTNode right;

	public BTNode(){
	}

	public BTNode(int data,	BTNode left,BTNode right){
		this.data=data;
		this.left=left;
		this.right=right;
	}

	public BTNode(int data){
		this.data=data;
	}
}

File: SerializeAndDeserializeBT.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory
 buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization
 algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized
 to the original tree structure.
 */
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null) return "";
        return helperS(root);
    }
    
    String helperS(TreeNode root){
        String s="";
        if(root==null){
            s=s+"null,";
        }else{
            s=s+root.val+",";
            s=s+helperS(root.left);
            s=s+helperS(root.right);
        }
        return s;
    }

    // Decodes your encoded data to tree.
    int i=0;
    public TreeNode deserialize(String data) {
        if(data.length()==0) return null;
        String [] arr=data.split(",");
        return helperD(arr);
    }
    
    TreeNode helperD(String[] arr){
        if(i==arr.length) return null;
        Integer val=Integer.parseInt(arr[i]);
        TreeNode root=new TreeNode(val);
        ++i;
        root.left=arr[i].equals("null")?null:helperD(arr);
        ++i;
        root.right=arr[i].equals("null")?null:helperD(arr);
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));

File: Mergetrees.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        return inorder(t1,t2);
    }
    
    TreeNode inorder(TreeNode t1,TreeNode t2){
        if(t1==null && t2==null) return null;
        if(t2==null) return t1;
        if(t1==null) return t2;
        t1.left=inorder(t1.left,t2.left);
        t1.right=inorder(t1.right,t2.right);
        t1.val=t1.val+t2.val;
        return t1;
    }
}

File: VerticalOrderTraversalOfTreeII.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*//987. Vertical Order Traversal of a Binary Tree
Given a binary tree, return the vertical order traversal of its nodes values.
For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).
Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).
If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.
Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.
*/
class Solution {
    int leftMostOrder=Integer.MAX_VALUE,rightMostOrder=Integer.MIN_VALUE;
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        List<List<Integer>> result=new LinkedList<>();
        if(root==null) return result;
        HashMap<Integer,List<Pair<Integer,Integer>>> map=new HashMap<>();
        helper(map,root,0,0);
        
        return getListFromMap(map,result);
    }
    
    List<List<Integer>> getListFromMap(HashMap<Integer,List<Pair<Integer,Integer>>> map,List<List<Integer>> result){
        for(int i=leftMostOrder;i<=rightMostOrder;++i){
            Collections.sort(map.get(i),new Comparator<Pair<Integer,Integer>>(){
                @Override
                public int compare(Pair<Integer,Integer> ob1,Pair<Integer,Integer> ob2){
                    if(ob1.getKey().equals(ob2.getKey())){
                        return ob1.getValue()-ob2.getValue();
                    }
                    return ob1.getKey()-ob2.getKey();
                }
            });
            List<Integer> sortedListByLevel=new LinkedList<>();
            for(Pair<Integer,Integer> p:map.get(i)){
                sortedListByLevel.add(p.getValue());
            }
            result.add(sortedListByLevel);
        }
        return result;
    }
    
    void helper(HashMap<Integer,List<Pair<Integer,Integer>>> map,TreeNode root,int order,int level){
        if(root==null) return;
        leftMostOrder=Math.min(leftMostOrder,order);
        rightMostOrder=Math.max(rightMostOrder,order);
        if(map.containsKey(order)){
            map.get(order).add(new Pair<Integer,Integer>(level,root.val));
        }else{
            LinkedList<Pair<Integer,Integer>> newList=new LinkedList<>();
            newList.add(new Pair<Integer,Integer>(level,root.val));
            map.put(order,newList);
        }
        helper(map,root.left,order-1,level+1);
        helper(map,root.right,order+1,level+1);
    }
}

File: ConstructBinaryTreeFromPreorderAndInorderTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    int preOrderIndex=0;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return helper(preorder,inorder,inorder.length);
    }
    
    TreeNode helper(int [] pre,int[] in,int len){
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<len;++i){
            map.put(in[i],i);
        }
        return buildTree(pre,0,len-1,map);
    }
    
    TreeNode buildTree(int [] pre,int inStartIndex,int inEndIndex,HashMap<Integer,Integer> map){
        if(preOrderIndex==pre.length) return null;
        if(inStartIndex>inEndIndex) return null;
        TreeNode root=new TreeNode(pre[preOrderIndex++]);
        root.left=buildTree(pre,inStartIndex,map.get(root.val)-1,map);
        root.right=buildTree(pre,map.get(root.val)+1,inEndIndex,map);
        return root;
    }
}

File: SumOfPathNumbers.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class SumOfPathNumbers {
    static int sum=0;
    public static int findSumOfPathNumbers(TreeNode root) {
      helper(root,0);
      return sum;
    }
  
    static void helper(TreeNode node,int bSum){
      if(node==null) return;
      bSum=bSum*10+node.val;
      if(node.left==null && node.right==null){
        sum=sum+bSum;
      }
      helper(node.left,bSum);
      helper(node.right,bSum);
    }

File: BinaryTreeRightSideView.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/**
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered
 from top to bottom.
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list=new LinkedList<>();
        if(root==null) return list;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            TreeNode curr=null;
            for(int i=0;i<size;++i){
                curr=q.poll();
                if(i==size-1){list.add(curr.val);}
                if(curr.left!=null){q.add(curr.left);}
                if(curr.right!=null){q.add(curr.right);}
            }
        }
        return list;
    }
}

File: BinaryTreeVerticalOrderTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*
Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
*/
class Solution { //61%
    Integer MIN_ORDER=Integer.MAX_VALUE,MAX_ORDER=Integer.MIN_VALUE;
    public List<List<Integer>> verticalOrder(TreeNode root) {
        Map<Integer,ArrayList<Pair<Integer,Integer>>> map=new HashMap<>();
        helper(map,root,0,0);
        List<List<Integer>> ans=new ArrayList<>();
        for(int key=MIN_ORDER;key<=MAX_ORDER;++key){
            Collections.sort(map.get(key),new Comparator<>(){
               public int compare(Pair<Integer,Integer> ob1,Pair<Integer,Integer> ob2){
                   return ob1.getKey()-ob2.getKey();
               } 
            });
            List<Integer> temp=new ArrayList<>();
            for(Pair<Integer,Integer> pair:map.get(key)){
                temp.add(pair.getValue());
            }
            ans.add(temp);
        }
        return ans;
    }
    
    void helper(Map<Integer,ArrayList<Pair<Integer,Integer>>> map,TreeNode root,int order,int level){
        if(root==null) return;
        ArrayList<Pair<Integer,Integer>> list=new ArrayList<>();
        if(map.containsKey(order)){
            list=map.get(order);
        }
        list.add(new Pair(level,root.val));
        map.put(order,list);
        MIN_ORDER=Math.min(MIN_ORDER,order);
        MAX_ORDER=Math.max(MAX_ORDER,order);
        helper(map,root.left,order-1,level+1);
        helper(map,root.right,order+1,level+1);
    }
}

class Solution { //5 %
    int leftMostOrder=Integer.MAX_VALUE,rightMostOrder=Integer.MIN_VALUE;
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> result=new LinkedList<>();
        if(root==null) return result;
        HashMap<Integer,List<Pair<Integer,Integer>>> map=new HashMap<>();
        helper(map,root,0,0);
        
        return getListFromMap(map,result);
    }
    
    List<List<Integer>> getListFromMap(HashMap<Integer,List<Pair<Integer,Integer>>> map,List<List<Integer>> result){
        for(int i=leftMostOrder;i<=rightMostOrder;++i){
            Collections.sort(map.get(i),new Comparator<Pair<Integer,Integer>>(){
                @Override
                public int compare(Pair<Integer,Integer> ob1,Pair<Integer,Integer> ob2){
                    return ob1.getKey()-ob2.getKey();
                }
            });
            List<Integer> sortedListByLevel=new LinkedList<>();
            for(Pair<Integer,Integer> p:map.get(i)){
                sortedListByLevel.add(p.getValue());
            }
            result.add(sortedListByLevel);
        }
        return result;
    }
    
    void helper(HashMap<Integer,List<Pair<Integer,Integer>>> map,TreeNode root,int order,int level){
        if(root==null) return;
        leftMostOrder=Math.min(leftMostOrder,order);
        rightMostOrder=Math.max(rightMostOrder,order);
        if(map.containsKey(order)){
            map.get(order).add(new Pair<Integer,Integer>(level,root.val));
        }else{
            LinkedList<Pair<Integer,Integer>> newList=new LinkedList<>();
            newList.add(new Pair<Integer,Integer>(level,root.val));
            map.put(order,newList);
        }
        helper(map,root.left,order-1,level+1);
        helper(map,root.right,order+1,level+1);
    }
}


File: SumPathExist.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
public static boolean hasPath(TreeNode root, int sum) {
    if(root==null && sum==0) return true;
    if(root==null) return false;
    if(hasPath(root.left,sum-root.val)) return true;
    if(hasPath(root.right,sum-root.val)) return true;
    return false;
  }

File: ConstructBinaryTreeFromPostorderAndInorderTraversal.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------

class Solution {
    Integer postOrderIndex=null;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        postOrderIndex=inorder.length-1;
        return helper(postorder,inorder,inorder.length);
    }
    
    TreeNode helper(int [] post,int[] in,int len){
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<len;++i){
            map.put(in[i],i);
        }
        return buildTree(post,0,len-1,map);
    }
    
    TreeNode buildTree(int [] post,int inStartIndex,int inEndIndex,HashMap<Integer,Integer> map){
        if(postOrderIndex==-1) return null;
        if(inStartIndex>inEndIndex) return null;
        TreeNode root=new TreeNode(post[postOrderIndex--]);
        if(inStartIndex==inEndIndex) return root;
        root.right=buildTree(post,map.get(root.val)+1,inEndIndex,map);
        root.left=buildTree(post,inStartIndex,map.get(root.val)-1,map);
       
        return root;
    }
}

File: LevelOrderDataInReverseOrderBottomToUp.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
import java.util.Queue;
import java.util.LinkedList;
import java.util.Stack;
//		1
//	      2	  3
//         4  5   6  7
public class LevelOrderDataInReverseOrderBottomToUp{
	static Stack<BTNode> stack=new Stack();
	static void levelOrderTraversal(BTNode root){
		Queue<BTNode> queue=new LinkedList<BTNode>();
		queue.offer(root);
		BTNode currentNode=null;
		while(!queue.isEmpty()){
			currentNode=queue.poll();
			stack.push(currentNode);
			if(currentNode.left!=null){
				queue.offer(currentNode.left);
			}
			if(currentNode.right!=null){
				queue.offer(currentNode.right);
			}
		}
		
		while(!stack.isEmpty()){
			System.out.println(""+stack.pop().data);
		}	
	}

	public static void main(String args[]){
		BTNode root=new BTNode(1);
		root.left=new BTNode(2);
		root.right=new BTNode(3);
		root.left.left=new BTNode(4);
		root.left.right=new BTNode(5);
		root.right.left=new BTNode(6);
		root.right.right=new BTNode(7);

		System.out.print("levelOrder Traversal in reverse order:-\n");levelOrderTraversal(root);
	}
}


File: isSymmetric.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return helper(root.left,root.right);
    }    
    
    boolean helper(TreeNode left,TreeNode right){
        if(left==null && right==null) return true;
        if(left==null || right==null) return false;
        if(left.val!=right.val) return false;
        if(!helper(left.left,right.right)) return false;
        if(!helper(left.right,right.left)) return false;    
        return true;
    }
 
}

class Solution {
    public boolean isSymmetric(TreeNode root) {
        return helper(root,root);
    }
    
    boolean helper(TreeNode root1,TreeNode root2){
        if(root1==null && root2==null) return true;
        if((root1==null && root2!=null)||(root2==null && root1!=null)) return false;
        if(root1.val!=root2.val) return false;
        if(!helper(root1.left,root2.right)) return false;
        if(!helper(root1.right,root2.left)) return false;
        return true;
    }
}

File: printAllPath.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
import java.util.Stack;

public class printAllPath {
	public static void main(String args[]) 
	{ 
		TNode root = new TNode(10); 
		root.left = new TNode(8); 
		root.right = new TNode(2); 
		root.left.left = new TNode(3); 
		root.left.right = new TNode(5); 
		root.right.left = new TNode(2); 
		
		printPaths(root); 
	}

    private static void printPaths(TNode root) {
        Stack<Integer> s=new Stack<>();
        inorder(root,s);
    }

    private static void inorder(TNode root, Stack<Integer> s) {
        if(root==null) return;
        s.push(root.data);
        inorder(root.left, s);
        if(root.left==null && root.right==null){
            printStack(s);
        }
        inorder(root.right, s);
        s.pop();
    }

    private static void printStack(Stack<Integer> s) {
        if(s.isEmpty()){
            System.out.println("");
            return;
        }
        int top=s.pop();
        System.out.print(top+" ");
        printStack(s);
        s.push(top);
    }
} 

 class TNode{
    int data;
    TNode left;
    TNode right;

    TNode(int data){
        this.data=data;
    }
}

File: diameterOfBinaryTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {//100%
    int ans=Integer.MIN_VALUE;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        depth(root);
        return ans;
    }  
    
    int depth(TreeNode root){
        if(root==null) return 0;
        int left=depth(root.left);
        int right=depth(root.right);
        ans=Math.max(ans,left+right);
        int depth=1+ Math.max(left,right);
        return depth;
    }
} 

class Solution { //Slow
    int ans=Integer.MIN_VALUE;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        helper(root);
        return ans;
    }  
    
    void helper(TreeNode root){
        if(root==null) return ;
        helper(root.left);
        ans=Math.max(ans,depth(root.left)+depth(root.right));
        helper(root.right);
    }
    
    int depth(TreeNode root){
        if(root==null) return 0;
        int depth=1+Math.max(depth(root.left),depth(root.right));
        return depth;
    }
}

class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        //return 0 if root have no child
        return Math.max(height(root.left)+height(root.right),Math.max(diameterOfBinaryTree(root.left),
                                          diameterOfBinaryTree(root.right)));
    }
    
    public int height(TreeNode root){
        if(root==null) return 0;
        return Math.max(height(root.left),height(root.right))+1;
    }  
}

File: FlattenBinaryTreeToSkewTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public void flatten(TreeNode root) {
        if(root==null) return ;
        TreeNode right=root.right;
        flatten(root.left);
        root.right=root.left;
        root.left=null;
        flatten(right);
        TreeNode temp=root;
        while(temp.right!=null){
            temp=temp.right;
        }
        temp.right=right;
    }
}

File: AllNodesDistanceKInBinaryTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
/*
We are given a binary tree (with root node root), a target node, and an integer value K.
Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.
*/
class Solution {
    HashMap<TreeNode,TreeNode> map=new HashMap<>();
    HashSet<TreeNode> visited=new HashSet<>();
    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
        List<Integer> result=new LinkedList<>();
        if(root==null) return result;
        inorder(root,null);
        Queue<TreeNode> queue=new LinkedList<>();
        visited.add(target);
        queue.add(target); int level=0;
        while(!queue.isEmpty()){
            int size=queue.size();
            if(level==K){
                for(int i=0;i<size;++i){
                    TreeNode curr=queue.poll();
                    result.add(curr.val);
                }
                 return result;
            }
            for(int i=0;i<size;++i){
                TreeNode curr=queue.poll();
                visited.add(curr);
                if(curr.left!=null && !visited.contains(curr.left)){queue.add(curr.left);}
                if(curr.right!=null && !visited.contains(curr.right)){queue.add(curr.right);}
                if(map.get(curr)!=null &&!visited.contains(map.get(curr))){queue.add(map.get(curr));}
            }
             ++level;
        }
        return result;
        
    }
    void inorder(TreeNode root,TreeNode prev){
        if(root==null) return ;
        if(prev!=null){
            map.put(root,prev);
        }
        inorder(root.left,root);
        inorder(root.right,root);
    }
}

File: LCABinaryTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
        if(root==p || root==q) return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left!=null && right!=null) return root;
        if(left!=null) return left;
        if(right!=null) return right;
        return null;
    }
}

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return root;
        if(root==p|| root==q) return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left!=null && right!=null) return root;
        if(left==null) return right;
        if(right==null) return left;
        return null;
    }
}

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return root;
        if(root==p|| root==q) return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left==null && right==null) return right;
        if(left!=null && right!=null) return root;
        if(left==null)return right; 
        else return left;  
    }

File: PopulateNextRightPointerInTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {//100 Intutuion Based
    public Node connect(Node root) {
        dfs(root,null);
        return root;
    }
    
    void dfs(Node root,Node par){
        if(root==null) return ;
        if(par!=null){
            if(par.right!=null && par.right!=root){
                root.next=par.right;
            }else if(par.next!=null){
                root.next=par.next.left;
            }
        }
        dfs(root.left,root);
        dfs(root.right,root);
    }
}

class Solution { //100
    public Node connect(Node root) {
        Node left=root;
        while(left!=null && left.left!=null){
            connectPointerLevelWise(left);
            left=left.left;
        }
        return root;
    }
    
    void connectPointerLevelWise(Node node){
        Node itr=node;
        while(itr!=null){
            itr.left.next=itr.right;
            if(itr.next!=null){
                itr.right.next=itr.next.left;
            }
            itr=itr.next;
        }
    }
}

class Solution {
    public Node connect(Node root) {
        if(root==null) return null;
        Queue<Node> q=new LinkedList<Node>();
        q.add(root);
        Node curr=null;
        while(!q.isEmpty()){
            int n=q.size();
            for(int i=0;i<n;++i){
            Node prev=curr;    
            curr=q.poll();
            if(i>0){  //to skip first element of for loop from setting as next of last element of previous loop.
                prev.next=curr;                
            }    
            if(curr.left!=null) q.add(curr.left);
            if(curr.right!=null) q.add(curr.right);  
            }
          
        }
        return root;
    }
}

class Solution { //45
  public Node connect(Node root) {
      if(root==null) return root;
      helper(root.left,root.right);
      return root;
  }
    
  void helper(Node left,Node right){
      if(left==null) return;
      left.next=right;
      helper(left.right,right.left);
      connect(left);
      connect(right);
  }

}

class Solution { //55
    public Node connect(Node root) {
        if(root==null) return null;
        Queue<Node> q=new LinkedList<Node>();
        q.add(root);
        Node curr=null;
        while(!q.isEmpty()){
            int n=q.size();
            for(int i=0;i<n;++i){
            Node prev=curr;    
            curr=q.poll();
            if(i>0){  //to skip first element of for loop from setting as next of last element of previous loop.
                prev.next=curr;                
            }    
            if(curr.left!=null) q.add(curr.left);
            if(curr.right!=null) q.add(curr.right);  
            }
          
        }
        return root;
    }
}


File: IsUnivaluedTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    Integer val=null;
    public boolean isUnivalTree(TreeNode root) {
        return inorder(root);
    }
    
    boolean inorder(TreeNode root){
        if(root==null) return true;
        if(!inorder(root.left)) return false;
        if(!inorder(root.right)) return false;
        if(val==null){
            val=root.val;
        }
        return val==root.val;
    }
}

File: MinDepthOfBinaryTree.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        if(root.left==null) return 1+minDepth(root.right);
        if(root.right==null) return 1+minDepth(root.left);
        return 1+ Math.min(minDepth(root.left),minDepth(root.right));
    }
}

File: FindAllTreePath.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class FindAllTreePaths {
    static List<List<Integer>> allPaths = new ArrayList<>();
    public static List<List<Integer>> findPaths(TreeNode root, int sum) {
      
      helper(root,sum,new LinkedList());
      return allPaths;
    }
  
    static void helper(TreeNode node,int sum,LinkedList<Integer> list){
      if(node==null){
        return;
      }
      if(node.val==sum){
        list.add(node.val);
        allPaths.add(new ArrayList<>(list));
        list.remove(list.size()-1);
        return;
      }
      list.add(node.val);
      helper(node.left,sum-node.val,list);
      helper(node.right,sum-node.val,list);
      list.remove(list.size()-1);
    }

File: PathWithGivenSequence.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class PathWithGivenSequence {
    public static boolean findPath(TreeNode root, int[] sequence) {
      return helper(root,0,sequence);
    }
  
    static boolean helper(TreeNode root, int index, int[] arr){
      if(root==null) return false;
      if(root.val!=arr[index]) return false;
      if(index==arr.length-1) return true;
      if(helper(root.left,index+1,arr)) return true;
      if(helper(root.right,index+1,arr)) return true;
      return false;
    }

File: BinaryTreeHeight.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
import java.lang.Math;

//		1
//	      2	  3
//         4  5   6  7
public class BinaryTreeHeight{

static int getHeightOfTree(BTNode root){
	if(root==null) return 0;
	return (1+Math.max(getHeightOfTree(root.left),getHeightOfTree(root.right)));	
}

public static void main(String args[]){
	BTNode root=new BTNode(1);
	root.left=new BTNode(2);
	root.right=new BTNode(3);
	root.left.left=new BTNode(4);
	root.left.right=new BTNode(5);
	root.right.left=new BTNode(6);
	root.right.right=new BTNode(7);

	System.out.println("height of the tree is :--  "+getHeightOfTree(root));
}

}

class Solution {
    int maxDepth=Integer.MIN_VALUE;
    public int maxDepth(TreeNode root) {
        if (root==null) return 0;
        DFS(root,1);
        return maxDepth;
    }
    
    void DFS(TreeNode node,int depth){
        if(node == null) return ;
        maxDepth=Math.max(maxDepth,depth);
        DFS(node.left,depth+1);
        DFS(node.right,depth+1);
    }
}

File: ZigZagLevel.txt
Question Type: BinaryTree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        if(root==null) return ans;
        Stack<TreeNode> s1=new Stack<>();
        Stack<TreeNode> s2=new Stack<>();
        s1.push(root);
        while(!s1.isEmpty() || !s2.isEmpty()){
            Stack<TreeNode> curr=!s1.isEmpty()?s1:s2;
            boolean leftToRight=!s1.isEmpty();
            Stack<TreeNode> currEmpty=s1.isEmpty()?s1:s2;
            int size=curr.size();
            List<Integer> list=new ArrayList<>();
            for(int i=0;i<size;++i){
                TreeNode currNode=curr.pop();
                list.add(currNode.val);
                if(leftToRight){
                    if(currNode.left!=null) currEmpty.push(currNode.left);
                    if(currNode.right!=null) currEmpty.push(currNode.right);
                }else{
                    if(currNode.right!=null) currEmpty.push(currNode.right);  
                    if(currNode.left!=null) currEmpty.push(currNode.left);
                }

            }
            ans.add(list);
        }
        return ans;
    }
}

class ZigZagLevel{
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result=new LinkedList<>();
        if(root ==null) return result;
        Stack<TreeNode> LtR = new Stack<>();
        Stack<TreeNode> RtL = new Stack<>();
        LtR.push(root);
        Boolean leftToRight=true;
        TreeNode curr=null;
        while(!LtR.isEmpty() || !RtL.isEmpty()){
            if(leftToRight){
               LinkedList<Integer> level=new LinkedList<>();
               while(!LtR.isEmpty()){
                  curr= LtR.pop();
                  if(curr!=null){
                      level.add(curr.val);
                      if(curr.left!=null) RtL.add(curr.left);
                      if(curr.right!=null) RtL.add(curr.right); 
                  } 
               }     
               result.add(level); 
            }else{
                LinkedList<Integer> level=new LinkedList<>();
                while(!RtL.isEmpty()){
                  curr= RtL.pop();
                  if(curr!=null){
                      level.add(curr.val);
                      if(curr.right!=null) LtR.add(curr.right);
                      if(curr.left!=null) LtR.add(curr.left); 
                  }    
               }
                result.add(level);
            }
            leftToRight=!leftToRight;
        }
        return result;
    }
}

File: lowestCommonAncestorBST.txt
Question Type: Tree
DSA Question: Implement tree operations like traversal or insertion.
----------------------
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
        if(root.val>p.val && root.val>q.val) return lowestCommonAncestor(root.left,p,q);
        if(root.val<p.val && root.val<q.val) return lowestCommonAncestor(root.right,p,q);
        return root;
    }
    
}

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return root;
        if(p.val<root.val && q.val<root.val){
          return lowestCommonAncestor(root.left,p,q);  
        }
        if(p.val>root.val && q.val>root.val){
          return lowestCommonAncestor(root.right,p,q);  
        }
        return root;
    }
}

File: CheatBook.txt
Question Type: Data-Structures-and-Algorithms-II
DSA Question: DSA problem related to: CheatBook
----------------------
1)Greedy -  JumpGame(M,goodPosition),
            meetingRoom(SortArray,pQ),
            mergeIntervals(sortArray,PQ),
            bestTimeToBuyAndSellStock(minStock,and maxProfit),
            Most Common Word(forLoop,split by space or check for empty spaces,HashMap),
            ContainerWithMostWater(most Distance,Contract the lowest one,Two Pointer),
            TrappingRainWater(2 array)
2)DP- JumpGame(M,forLoop),
      maximumSubarray(S[i]=max(S[i-1]+arr[i],arr[i]))
      WordBreak(slidingWindow wont work,recursion+for Loop to check all posibility,memo to reduce time complexity)
      CoinChange(recursion+forLoop,maximum value is amount+1,memo),
      MinpathSum(DP)
      ClimbingStairs(DP no recursion solution),
      UniquePaths(DP solution),
      Edit Distance(DP Math.min 3 times)
      fact(n)=n*fact(n-1); (n=0 || n=1)->1
      fibonaci(n)=fibonaci(n-1)+fibonaci(n-2); 
      LCS(char[] arr1,char[] arr2,arr1.length-1,arr2.length-1)=
                          arr1[i1]==arr[i2] -->1+LCS(arr1,arr2,i1-1,i2-1);
                          else
                          Max(LCS(arr1,arr2,i1-1,i2),LCS(arr1,arr2,i1,i2-1));                            
      Maximum continuous Sub Array - MCS(int [] arr,arr.length-1) = max(arr[i],MCS(arr,i-1));
      Longest Increasing SubArray  - Max(LIS[])  -> where -> LIS[i]=1+max(LIS[j]) where  (0>=j<i)
      Coin Change ------------------ minCoinChange(int [] coins,amount) ->
                                                        for(j=0->coins.length){
                                                        result[amount] = Math.min( result[amount] , minCoinChange( coins,amount-coins[j])
                                                        }	
                                                //here we are repeating this for different amount leift
      KnapSAck --------------------- take one item or not - total two decisions required
                                                //here we are repeating for different weight left
                                                //also we are pickig one item only once
6)SubString - longestPalindromincSubString(each index as center,func(index,index),func(index,index))
              Find All Anagrams in a String(backtracking)
              longestPalindromicSubSequence(i+1,j-1)
              longestCommonSubSequence(0 if i or j grater than length,1+lcs(i+1,j+1),max(lcs(i+1,j),lcs(i,j+1)))
              longestIncreasingSubSequence(LIS[i]=Math.max(1+LIS[j])  , 0<=j<i)
              longestConsecutiveSequence(************)
              longestNonRepeatingSubString(********)
              longestProductInArray(***********)
3)Permutation/Combination-letterCombinationsOfPhoneLetter(forLoop,order maintained),
                          Permutations(forLoop,OrderNeed to be changed,swap)
                          GenerateParenthesis(forLoop)
4)String - removeAllAdjacentDuplicates(E,StringBuilder),
           ReverseString(Two Pointer) ,
           FirstUniqueCharaterInAString(2 for loop) ,
           ATOI('0' && '9' numbers between these character including these two)
           Implement strStr() KMP(*******)
           Reverse String(two pointer)
           Reverse Words in a String(two pointer)
5)SlidingWindow- longestSubStringWithoutRepeatingCharacter(HashMap) ,
                 MinimumWindowSubString(HashMap,patCount,dict),
                 SlidingWindowMax(***********)
7)Tree- BTMaximumPathSum(DFS),
        SerializeAndDeserializeBT(DFS),
        Diameter(Depth modified,global variable),
        LCA(left and right not null return node),
        SpiralTrraverse(2 Stack),
        SymetricTree(DFS,left,right pass as arguments),
        validateBST(inOrder),
        BTRightSideVeiw(LevelOrderTraversal),
        DepthOfBT(max of left ,right),
        ConstructBTFromPreOrderInOrderTraversal(map of inorder values and index, global variable for preorder, range of l and h for inorder , return null l>h and preorderVariable==n)
        Flatten Binary Tree to Linked List(Inorder Traversal)
        Convert Sorted List to Binary Search Tree(middle of linked list,newnode=midle.data and  middle.next=null;)
        Construct Binary Tree from Inorder and Postorder Traversal(Same as preOrder and inorder, just start from right side)
        Kth Smallest Element in a BST(counter inorder traversal)
        Populating Next Right Pointers in Each Node(Intutive Approach, left pointer, using previously set next pointer)
        Range Sum of BST(Inorder traversal)
        All Elements in Two Binary Search Trees(flatten two tree and merge two linkd list)
        Invert Binary Tree(Inorder Traversal temp variable swap)
        Binary Tree Vertical Order Traversal(order,level,pre order traversal,map of int,Pair getKey getValue new Pair)
        All Nodes Distance K in Binary Tree(Level Order Traversal, covert tree into graph)
        Boundary of Binary Tree(add left,leaves,right boundary seperately)
        Two Sum BSTs(inorder traversal, BST search)
        Binary Search Tree to Greater Sum Tree(right to left reverse of inorder)
8)Heap- medianFromStreamOfData(minHeap,MaxHeap),
        mergeKSortedList(pq),
        MergeSortedArray(pq,Custom Class)
9)Stack-minStack(2 stack,linkedList) ,
        VaildParenthesis(Stack,hashMap),
        LargestRectangleInHistogram(**************),
        Span(*************)
10)List-addTwoNumber(while Loop),
        ReverseNodeInKGroup(ReverSe Function with limit K,calculate total element first,dummy),
        CloneWithRandomPointer(HashMap or changeStructureoFOriginal List),
        reverseLinkedList(prev) ,
        middleOfALinkedList(2 pointer),
        RemoveNthNodeFromEndOfList(2Pointer),
        Intersection of Two Linked Lists(two pointer)
        Sort List(find middle,get single entity,merge them in order)
        Linked List Cycle(two pointer)
11)Design-     lRU(Map,doublyLinkedList),
               InsertDeleteGetRandomO1Time(Map,LinkedList),
               Design HashMap(*******)
               Design HashSet(******)
12)selection - MedianOfTwoSortedArray(Binary Searching,Ypos=(X+Y+1)/2-XPos,XPosmin,XPosmax,YPosmin,YPosmax),
               TopKFrequentElement(HashMap,partiton method),
               KthLargestElement(partition)  
               KClosestPointsToOrigin
               KthLargestElementInAStreamOfData(partiition,MINHeap)
13)Searching - modifiedBinarySearch(search is sorted parst first)
               kadane(********)
14)Array-TwoSum(HashMap or Sort),
         ThreeSum(TwoSum),
         FloodFill(2 array),
         ProductOfArrayAcceptSelf(2 array left and right),
         RemoveDuplicatesFromSortedArray(index++ if not equal to prev)
         Find First and Last Position of Element in Sorted Array(2 variable approach)
         Maximum Product of Two Elements in an Array(2 variable )
         Move Zeroes(count number of zeroes)
15)Hashing-GroupAnagram
16)Matrix- numberOfIslands(DFS,visitedFirstTimeCount),
           WordSearch(DFS,reach index n-1 of pattern to search),
           FloodFill(DFS),
           MaxAreaOfIsland,
           Rotting Orange,
           GameOfLife,
           MinimumPathSum(DP),
           RotateMatrix(transponse and suffle columns),
           SearchAMatrix(binary search)
           Set Matrix Zeroes(if arr[i][j]==0  arr[i][0]=0  arr[0][j]=0 trick)
           Surrounded Regions(start from end with 0)
17)Math-CountPrimes(visited,multiplication) ,
        FirstMissingNumber(n)(n+1)/2),
        ReverseInteger(/10 %10 until 0),
        SquareRoot(binary Search),
        FirstMissingPositiveNumber(negate by index,range is limited),
        FindDuplicateElement(negate by index,range is limited)
19)BitManupilation - BinaryNumberToDcimalNumber(s^index)
20)Graph- Course Schedule(*******)
          Find the Town Judge(*********)
          Critical Connections in a Network(*******)
          Graph Valid Tree(**********)
21)Trie- **********
22)Divide and Concur *********
23)Greedy Algo ********
24)System Design Questions

*********** Pending Cheats


File: LRUCache.txt
Question Type: Design
DSA Question: DSA problem related to: LRUCache
----------------------
public class Node{
    int val;
    int key;
    Node next;
    Node prev;
    
    Node(){
        
    }
    
    Node(int val,int key){
        this.val=val;
        this.key=key;
    }
}
class LRUCache {
    int capacity;
    Map<Integer,Node> map=new HashMap<>();
    Node head;
    Node tail;
    int size;
    public LRUCache(int capacity) {
        this.capacity=capacity;
            head=new Node();
            tail=new Node();
            head.next=tail;
            tail.prev=head;
            size=0;
    }
    
    public int get(int key) {
        if(!map.containsKey(key)) return -1;
        int toReturn=this.map.get(key).val;
        deleteNode(this.map.get(key));
        addNodeToHead(map.get(key));
        return toReturn;
    }
    
      void addNodeToHead(Node node){
        node.prev=head;
        node.next=head.next;
        node.next.prev=node;
        head.next=node;
    }
    
    void deleteNode(Node node){
        Node prev = node.prev;
        Node next = node.next;
        prev.next = next;
        next.prev = prev;
    }
    
    public void put(int key, int value) {
        Node node=new Node(value,key);
        if(map.containsKey(key)){
             deleteNode(map.get(key));
             --size;
        }
        ++size;
        addNodeToHead(node);
        map.put(key,node);
        if(size>capacity && size!=0){
            Node toRemove=tail.prev;
            deleteNode(toRemove);
            map.remove(toRemove.key);
            --size;
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */


File: DesignHashMap.txt
Question Type: Design
DSA Question: DSA problem related to: DesignHashMap
----------------------
/*
Design a HashMap without using any built-in hash table libraries.

To be specific, your design should include these functions:

put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.
get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.
*/
class MyPair<T,Y>{
    public T key;
    public Y value;
    
    public MyPair(){
        
    }
    
    public MyPair(T key,Y value){
        this.key=key;
        this.value=value;
    }
    
    @Override
    public String toString(){
        return "key: "+key+" Value: "+value;  
    } 
}
class MyHashMap {
    int CAPACITY;
    List<MyPair<Integer,Integer>>[] hashTable;
    public MyHashMap() {
        CAPACITY=2069;
        hashTable = new LinkedList[CAPACITY];
        for (int i = 0; i < this.CAPACITY; ++i) {
            this.hashTable[i]=new LinkedList<>();
        }
    }
    
    int getHash(int key){
       return key%CAPACITY; 
    }
    
    public void put(int key, int value) {
        int hashKey= getHash(key);
            boolean found=false;
            for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
                if(bucket.key==key){
                    hashTable[hashKey].remove(bucket);
                    break;
                 }
            }
            MyPair<Integer,Integer> newPair=new MyPair<>(key,value);
            hashTable[hashKey].add(newPair); 
    }
    
    public int get(int key) {
        int hashKey= getHash(key);
        if(null==hashTable[hashKey]){
            return -1;
        }
        for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
            if(bucket.key==key){
                return bucket.value;
            }
        }
        return -1;
    }
    
    public void remove(int key) {
        int hashKey= getHash(key);
        if(null==hashTable[hashKey]){
            return;
        }
        for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
            if(bucket.key==key){
                hashTable[hashKey].remove(bucket); break;
            }
        }
    }
}



File: FindMedianFromStream.txt
Question Type: Design
DSA Question: DSA problem related to: FindMedianFromStream
----------------------
class MedianFinder {
    PriorityQueue<Integer> minPq=new PriorityQueue<>();
    PriorityQueue<Integer> maxPq=new PriorityQueue<>(new Comparator<Integer>(){
        public int compare(Integer a,Integer b){
            return b-a;
        }
    });
    public MedianFinder() {
        
    }
    
    public void addNum(int num) {
        if(maxPq.isEmpty()){
            maxPq.add(num);
        }
        else if(maxPq.size()==minPq.size()){
            if(minPq.peek()<num){
                maxPq.add(minPq.poll());
                minPq.add(num);
            }else{
                maxPq.add(num);
            }
        }else{
            if( maxPq.peek()>num){
                minPq.add(maxPq.poll());
                maxPq.add(num);
            }else{
                minPq.add(num);
            }
        }
    }
    
    public double findMedian() {
        if(maxPq.size()==minPq.size()){
            return ((double)minPq.peek()+(double)maxPq.peek())/2;
        }else{
            return (double)maxPq.peek();
        }
    }

}


File: LRUCacheUsingDoublyLinkedListHashMap.txt
Question Type: Design
DSA Question: DSA problem related to: LRUCacheUsingDoublyLinkedListHashMap
----------------------

class LRUCache {
    class Node{
        Node next;
        Node prev;
        int key;
        int val;
        
        public Node(){         
        }
        public Node(int key,int value){
            this.key=key; this.val=value;
        }
    }
    Node head ;
    Node tail ;
    HashMap<Integer,Node> map;
    
    int capacity=0;
    
    int size;
    public LRUCache(int capacity) {
        this.capacity=capacity;
        this.map=new HashMap<>();
        this.size=0;
        head=new Node();tail=new Node();
        tail.prev=head; head.next=tail;
    }
    
    void deleteNode(Node node){
    Node prev = node.prev;
    Node next = node.next;

    prev.next = next;
    next.prev = prev;
        
    }
    
    void addNodeToHead(Node node){
        node.prev=head;
        node.next=head.next;
        node.next.prev=node;
        head.next=node;
    }
    
    public int get(int key) {
        Node fetchedNode= map.get(key);
        if(fetchedNode==null) return -1;
        deleteNode(fetchedNode);
        addNodeToHead(fetchedNode);
        return fetchedNode.val;
    }
    
    public void put(int key, int value) {
        Node node = map.get(key);
        if(node==null){
            Node newNode=new Node(key,value);
            map.put(key,newNode);
            addNodeToHead(newNode);
            ++size;
            if(size>capacity){Node toDelete=tail.prev;deleteNode(toDelete); map.remove(toDelete.key);--size;}
        }else{
            node.val=value;
            deleteNode(node);
            addNodeToHead(node);
        }
    }
}


File: MinStack.txt
Question Type: Design
DSA Question: DSA problem related to: MinStack
----------------------
class MinStack {

    /** initialize your data structure here. */
    Stack<Integer> stack=new Stack<>();
    Stack<Integer> minStack=new Stack<>();
    
    public MinStack() {
        stack.push(Integer.MAX_VALUE);
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        stack.push(x);
        if(stack.peek()!= Integer.MAX_VALUE && stack.peek()<=x){
            minStack.push(stack.peek());
        }else{
            minStack.push(x);
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */


File: SerializeAndDeserialize.txt
Question Type: Design
DSA Question: DSA problem related to: SerializeAndDeserialize
----------------------
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null ) return "";
        StringBuilder sb=new StringBuilder();
        helper(sb,root);
        return sb.toString().trim();
    }
    
    void helper(StringBuilder sb,TreeNode root){
        if(root==null){
            sb.append("null ");
            return;
        }
        sb.append(root.val+" ");
        helper(sb,root.left);
        helper(sb,root.right);
    }
    
    

    // Decodes your encoded data to tree.
    //1 2 null null 3 4 null null 5 null null
    int i=-1;
    public TreeNode deserialize(String data) {
        if(data.length()==0) return null;
        String[] dataS=data.split(" ");
        for(String str:dataS){
            System.out.print(str+" ");    
        }
        TreeNode head=null;
        head=helperC(head,dataS);
        return head;
    }
    
    TreeNode helperC(TreeNode head,String[] dataS){
        ++i;
        if(i==dataS.length) return null;
        if(dataS[i].equals("null")){
            head=null;
            return null;
        }else{
            head=new TreeNode(Integer.parseInt(dataS[i]));
        }
        head.left=helperC(head.left,dataS);
        head.right=helperC(head.right,dataS);
        return head;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));


File: MyHashSet.txt
Question Type: Design
DSA Question: DSA problem related to: MyHashSet
----------------------
class MyHashSet {

    int CAPACITY;
    
    List<Integer>[] hashTable;
    
    public MyHashSet() {
        CAPACITY=2069;
        hashTable = new LinkedList[CAPACITY];
        for (int i = 0; i < this.CAPACITY; ++i) {
            this.hashTable[i]=new LinkedList<>();
        }
    }
    
    int getHash(int key){
       return key%CAPACITY; 
    }
    
    public void add(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                hashTable[hashKey].remove(bucket);
                break;
             }
        }
        hashTable[hashKey].add(key); 
    }
    
    public void remove(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                hashTable[hashKey].remove(bucket); break;
            }
        }  
    }
    
    public boolean contains(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                return true;
            }
        }
        return false;
    }
}


File: InsertDeleteGetRandom.txt
Question Type: Design
DSA Question: DSA problem related to: InsertDeleteGetRandom
----------------------
/*
Design a data structure that supports all following operations in average O(1) time.

insert(val): Inserts an item val to the set if not already present.
remove(val): Removes an item val from the set if present.
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
*/
class RandomizedSet {
    HashMap<Integer,Integer> map;
    List<Integer> list;
    Random rad;
    /** Initialize your data structure here. */
    public RandomizedSet() {
        map=new HashMap<>();
        list=new LinkedList<>();
        rad=new Random();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(map.containsKey(val)) return false;
        map.put(val,list.size());
        list.add(list.size(),val);
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if(!map.containsKey(val)) return false;
        int lastElement=list.get(list.size()-1);
        int pos=map.get(val);
        map.put(lastElement,pos);
        list.set(pos,lastElement);
        map.remove(val);
        list.remove(list.size()-1);
        return true;
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        return list.get(rad.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */

File: LRUCacheUsingLinkedHashMap.txt
Question Type: Design
DSA Question: DSA problem related to: LRUCacheUsingLinkedHashMap
----------------------
/*
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

The cache is initialized with a positive capacity.

Follow up:
Could you do both operations in O(1) time complexity?
*/
class LRUCache {
    LinkedHashMap<Integer,Integer> map;
    public LRUCache(int capacity) {
        map=new LinkedHashMap<>(capacity, 0.75F, true){
                protected boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest) {
                return size() > capacity;
            }
        };
    }
    
    public int get(int key) {
        return map.getOrDefault(key,-1);
    }
    
    public void put(int key, int value) {
        map.put(key,value);
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

File: RemoveAllAdjacentDuplicatesInString.txt
Question Type: Strings
DSA Question: DSA problem related to: RemoveAllAdjacentDuplicatesInString
----------------------
/*
Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.

We repeatedly make duplicate removals on S until we no longer can.

Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.
*/
class Solution {
    public String removeDuplicates(String s) {
        StringBuilder sb=new StringBuilder();
        for(char character:s.toCharArray()){
            if(sb.length()!=0 && character==sb.charAt(sb.length()-1)){
                sb.deleteCharAt(sb.length()-1);
            }else{
                sb.append(character);
            }
        }
        return sb.toString();
    }
}

class Solution {
    public String removeDuplicates(String s) {
        StringBuilder sb=new StringBuilder();
        int index=-1,i=0;
        while(i<s.length()){
            if(index!=-1 && s.charAt(i)==sb.charAt(index)){
                sb.deleteCharAt(index);
                --index;
            }else{
                sb.append(s.charAt(i));
                ++index;
            }
            ++i;
        }
        return sb.toString();
    }
}

class Solution {
    public String removeDuplicates(String S) {
         char [] chars=S.toCharArray();
         for(int i=1;i<chars.length;++i){
             int prevIndexToCheck=getPrevIndex(chars,i);
             if(chars[prevIndexToCheck]==chars[i]){
                 chars[prevIndexToCheck]=chars[i]='#';
             }
         }
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<chars.length;++i){
            if(chars[i]!='#'){
                sb.append(chars[i]);
            }
        }
        return sb.toString();
    }
    
    int getPrevIndex(char[] chars,int currIndex){
        int i=currIndex-1;
        while(i>=0 && chars[i]=='#'){
            --i;            
        }
        return i<0?0:i;
    }
    
}


File: PermutationsOrAnagaramsOfAString.txt
Question Type: Strings
DSA Question: DSA problem related to: PermutationsOrAnagaramsOfAString
----------------------
/*
//All possible anagrams or permutation of a string
void helper(String txt,String str,int l,int h){
        if(l==h){
            if(txt.indexOf(str)>=0){
                System.out.println(str);
            }
        }else{
            for(int i=l;i<=h;++i){
                str=swap(str,l,i);
                helper(txt,str,l+1,h);
                str=swap(str,l,i);
            }
        }
    }
    
    public String swap(String a, int i, int j){ 
		char temp; 
		char[] charArray = a.toCharArray(); 
		temp = charArray[i] ; 
		charArray[i] = charArray[j]; 
		charArray[j] = temp; 
		return String.valueOf(charArray); 
	}*/


File: CaptureRegions.txt
Question Type: Strings
DSA Question: DSA problem related to: CaptureRegions
----------------------
/*
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.
*/
class Pair{
    public int i;
    public int j;
    
    public Pair(int i,int j){
        this.i=i;
        this.j=j;
    }
}
class Solution {
    public void solve(char[][] board) {
        if(board.length==0) return;
        List<Pair> list=new ArrayList<>();
        for(int i=0;i<board.length;++i){
            list.add(new Pair(i,0));
            list.add(new Pair(i,board[0].length-1));
        }
        for(int i=0;i<board[0].length;++i){
            list.add(new Pair(0,i));
            list.add(new Pair(board.length-1,i));
        }
        for(Pair pair:list){
            DFS(board,pair.i,pair.j);
        }
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]=='O'){
                 board[i][j]='X';                    
                }else if(board[i][j]=='#'){
                 board[i][j]='O';
                }
            }
        }
    }
    
    void DFS(char[][] board,int i,int j){
        if(board[i][j]!='O') return;
        int []x={0,0,1,-1};
        int []y={1,-1,0,0};
        board[i][j]='#';
        for(int m=0;m<x.length;++m){
            if(isSafe(board,i+x[m],j+y[m])){
                DFS(board,i+x[m],j+y[m]);
            }
        }
    }
    
    boolean isSafe(char[][] board,int i,int j){
        return i>=0 && i<board.length && j>=0 && j<board[0].length && board[i][j]=='O';
    }
}

File: KMP.txt
Question Type: Strings
DSA Question: DSA problem related to: KMP
----------------------
//KMP Algorithm
class Solution {
    public int strStr(String txt, String pat) {
        int N=txt.length(),M=pat.length();
        if(N<M)return -1;
        if(M==0 || N==0) return 0;
        int [] LPS=new int[M];
        fillLPS(pat,LPS);
        int i=0,j=0;
        while(i<N){
            if(txt.charAt(i)==pat.charAt(j)){++i;++j;}
            if(j==M){return i-j;}
            else if(i<N && txt.charAt(i)!=pat.charAt(j)){
                if(j==0) {i++;}
                else{
                    j=LPS[j-1];
                }
            }
        }
        return -1;
    }
    
    void fillLPS(String str,int [] LPS){
        int i=1,j=0;
        LPS[0]=0;
        while(i<str.length()){
            if(str.charAt(i)==str.charAt(j)){++j; LPS[i]=j; ++i;}
            else{
                if(j==0) {LPS[i]=0;i++;}
                else{
                    j=LPS[j-1];
                }
            } 
        }
    }
}

File: Most Common Word.txt
Question Type: Strings
DSA Question: DSA problem related to: Most Common Word
----------------------
class Solution {
    public String mostCommonWord(String p, String[] banned) {
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<banned.length;++i){
            set.add(banned[i]);
        }
        String ans=null;int count=0;
        HashMap<String,Integer> map=new HashMap<>();
        StringBuilder temp=null;
        for(int i=0;i<p.length();++i){
            char c=p.charAt(i);
            if((c>='A'&& c<='Z')||(c>='a'&& c<='z')){
                if(temp==null){
                    temp=new StringBuilder();
                }
                temp.append(c);
            }else{
                if(temp!=null && temp.length()!=0){
                    String sTemp= temp.toString();
                    sTemp=sTemp.toLowerCase();
                    if(set.contains(sTemp)){
                        temp=null;
                        continue;
                    }
                    map.put(sTemp,map.getOrDefault(sTemp,0)+1);
                    if(count<map.get(sTemp)){
                        count=map.get(sTemp);
                        ans=sTemp;
                    }
                    temp=null;
                }
            }
        }
        if(temp!=null && temp.length()!=0){
            String sTemp= temp.toString();
            sTemp=sTemp.toLowerCase();
            if(!set.contains(sTemp)){
                map.put(sTemp,map.getOrDefault(sTemp,0)+1);
                if(count<map.get(sTemp)){
                    count=map.get(sTemp);
                    ans=sTemp;
                }
            }
            temp=null;
        }
        return ans;
    }
}

File: Group Anagram.txt
Question Type: Strings
DSA Question: DSA problem related to: Group Anagram
----------------------
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map=new HashMap<>();
        for(String str:strs){
            String hashCode=getHashCode(str);
            List<String> list=map.getOrDefault(hashCode,new ArrayList<>());
            list.add(str);
            map.put(hashCode,list);
        }
        return new ArrayList(map.values());
    }
    
    private String getHashCode(String str){
        int[] memo=new int[256];
        for(int i=0;i<str.length();++i){
            memo[str.charAt(i)]++;
        }
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<memo.length;++i){
            sb.append(memo[i]+"#");
        }
        return sb.toString();
    }
}

File: CombinationOfString.txt
Question Type: Strings
DSA Question: DSA problem related to: CombinationOfString
----------------------
public class CombinationOfString {
    static void combination(String s){
        if(s.length()==0) return;
        System.out.println(" ");
        for(int i=0;i<s.length();++i){
            DFS(i,s.substring(i,i+1),s.toCharArray());
        }
   
    }
    
    private static void DFS(int index,String ans, char[] cs) {
        System.out.println(ans);
        if(index==cs.length-1) return;
        for (int i = index+1; i < cs.length; ++i) {
            DFS(i,ans +cs[i],cs);
        }
    }


    public static void main(String[] args) {
        combination("ABC");
    }
}


File: ITOA.txt
Question Type: Strings
DSA Question: DSA problem related to: ITOA
----------------------
package main.java.String;

import java.util.Stack;

public class ITOA {//Integer to Alphabet
    public static void main(String args[]){
        String alphabetNumber=getStringFromNumber(12345);
        System.out.println(alphabetNumber);
    }

    private static String getStringFromNumber(int i) {
        if(i==0) return "0";
        StringBuilder sb=new StringBuilder();
        while (i!=0){
            int x=i%10;
            sb.append(x);
            i=i/10;
        }
        return reverse(sb.toString());
    }

    private static String reverse(String str) {
        char[] arr=str.toCharArray();
        int l=0,h=str.length()-1;
        while(l<h){
            char temp=arr[l];
            arr[l]=arr[h];
            arr[h]=temp;
            ++l;
            --h;
        }
        return String.copyValueOf(arr);
    }
}


File: MinimumWindowSubstring.txt
Question Type: Strings
DSA Question: DSA problem related to: MinimumWindowSubstring
----------------------
/*
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

Example:

Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"
Note:

If there is no such window in S that covers all characters in T, return the empty string "".
If there is such window, you are guaranteed that there will always be only one unique minimum window in S.
*/
class Solution {
    public String minWindow(String txt, String pat) {
        int textLen=txt.length();
        int patLen=pat.length();
        int[] needToFind=new int[256];
        for(int i=0;i<patLen;++i){
            needToFind[pat.charAt(i)]++;
        }
        int[] hasFound=new int[256];
        int minWindLen=Integer.MAX_VALUE;
        int minWinBegin=0;
        int minWinEnd=0;
        int count=0;
        for(int begin=0,end=0;end<textLen;end++){  //Expansion
            if(needToFind[txt.charAt(end)]==0) continue;
            hasFound[txt.charAt(end)]++;
            if(hasFound[txt.charAt(end)]<=needToFind[txt.charAt(end)]){
                ++count;
            }
            if(count==patLen){
                while(needToFind[txt.charAt(begin)]==0 || 
                      hasFound[txt.charAt(begin)]>needToFind[txt.charAt(begin)]){
                    if(hasFound[txt.charAt(begin)]>needToFind[txt.charAt(begin)]){
                      hasFound[txt.charAt(begin)]--;  
                    }
                    begin++;//compresing
                }
                int windowLen = end - begin +1;
                if(windowLen<minWindLen){
                    minWinBegin=begin;
                    minWinEnd=end;
                    minWindLen=windowLen;
                }
            }
        }
        return  count==patLen?txt.substring(minWinBegin,minWinEnd+1):"";
    }
}

File: GenerateAllStringOfNBits.txt
Question Type: Strings
DSA Question: DSA problem related to: GenerateAllStringOfNBits
----------------------
public class GenerateAllStringOfNBits {
    static void allStrings(int n){
        int[] ans=new int[n];
        DFS(0,ans);
    }
    
    private static void DFS(int index,int[] ans) {
        if(index==ans.length){
            for(int i=0;i<ans.length;++i){
                System.out.print(ans[i]);
            }
            System.out.println("");
            return;
        } 
        ans[index]=1;
        DFS(index+1, ans);
        ans[index]=0;
        DFS(index+1, ans);
    }


    public static void main(String[] args) {
        allStrings(3);
    }
}


File: RabinKarp.txt
Question Type: Strings
DSA Question: DSA problem related to: RabinKarp
----------------------
/*
Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2
Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
*/
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length()==0) return 0;
        if(haystack.length()==0) return -1;
        if(haystack.length()<needle.length()) return -1;
        int q=101,d=256;
        //h=d^m-1/q
        int h=1;
        for(int i=0;i<needle.length()-1;++i){
            h=(h*d)%q;
        }
        //to and p calculation 
        int t=0,p=0;
        for(int i=0;i<needle.length();++i){
            p=(p*d+needle.charAt(i))%q;
            t=(t*d+haystack.charAt(i))%q;
        }
        
        //comparing t and p and on matching compare the internal characters
        for(int i=0;i<haystack.length()-needle.length()+1;++i){
            if(t==p){
                boolean flag=true;
                for(int j=0;j<needle.length();++j){
                    if(haystack.charAt(i+j)!=needle.charAt(j)){flag=false;break;}
                }
                if(flag) return i;
            }
            if(i<haystack.length()-needle.length()){
                t=(haystack.charAt(i+needle.length())+d*(t-h*haystack.charAt(i)))%q;//calculating t(i+1)
                if(t<0) t=t+q;
            }
        }
        return -1;
    }
}

File: Rank OfString Lexicographic Rank.txt
Question Type: Strings
DSA Question: DSA problem related to: Rank OfString Lexicographic Rank
----------------------

	static int fact(int n){
     	if(n==1 || n==0) return 1; 
      	return n*fact(n-1);
    	}  
  
	// A function to find rank of a string in 
	// all permutations of characters 
	static int findRank(String str) 
	{ 	int rank=1;
     	int len=str.length();
     	int fact=fact(len);
     	int count[] =new int[256];
     	for(int i=0;i<256;i++){
           count[i]=0;
        }
     	for(int i=0;i<str.length();++i){
         	count[str.charAt(i)]++; 
        }
    	for(int i=1;i<256;++i){
         	count[i]=count[i]+count[i-1]; 
        }
     	for(int i=0;i<str.length();++i){
         	fact=fact/(len-i);
          	rank=rank+fact*count[str.charAt(i)-1];
          	for(int j=str.charAt(i);j<256;++j){
             	--count[j]; 
            }
        }     
     	return rank;
	} 

File: PermutationsOrAnagaramsOfAIntegerArray.txt
Question Type: Strings
DSA Question: DSA problem related to: PermutationsOrAnagaramsOfAIntegerArray
----------------------
class Solution {
    List<List<Integer>> list;
    public List<List<Integer>> permute(int[] nums) {
        list=new LinkedList<>();
        if(nums.length==0) return list;
        helper(nums,0,nums.length-1);
        return list;
    }
    
    void helper(int[] nums,int l,int h){
        if(l==h){
            List<Integer> newList=new ArrayList<>();
            for(int i=0;i<nums.length;++i){
                newList.add(nums[i]);
            }
            list.add(newList);
        }else{
            for(int i=l;i<=h;++i){
                swap(nums,i,l);
                helper(nums,l+1,h);
                swap(nums,i,l);
            }
        }
    }
    
    void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}

File: PermutationOfString.txt
Question Type: Strings
DSA Question: DSA problem related to: PermutationOfString
----------------------
public class PermutationOfString {

    static void permutation(String s){
        if(s.length()==0) return;
        DFS(0,s.toCharArray());
    }
    
    private static void DFS(int index, char[] cs) {
        if (index == cs.length-1) {
            System.out.println(cs);
            return;
        }
        for (int i = index; i < cs.length; ++i) {
            swap(cs,index,i);
            DFS(index+1, cs);
            swap(cs,index,i);
        }
    }

    private static void swap(char[] cs, int index, int i) {
        char temp=cs[i];
        cs[i]=cs[index];
        cs[index]=temp;
    }

    public static void main(String[] args) {
        permutation("ABC");
    }
}


File: BackSpaceCompare.txt
Question Type: Strings
DSA Question: DSA problem related to: BackSpaceCompare
----------------------
class BackspaceCompare {

    public static boolean compare(String str1, String str2) {
      char[] s1=str1.toCharArray();
      char[] s2=str2.toCharArray();
      int l1=0;
      for(int h=0;h<s1.length;++h){
         if(s1[h]=='#'){
           --l1;
         }else{
           s1[l1]=s1[h];
           ++l1;
         }
      }
      int l2=0;
      for(int h=0;h<s2.length;++h){
         if(s2[h]=='#'){
           --l2;
         }else{
           s2[l2]=s2[h];
           ++l2;
         }
      }
      if(l1!=l2) return false; 
      for(int i=0;i<l2;++i){
        if(s1[i]!=s2[i]) return false;
      }
      return true;
    }
  }

File: ReverseStringUsingTwoPointer.txt
Question Type: Strings
DSA Question: DSA problem related to: ReverseStringUsingTwoPointer
----------------------
class Solution {
    public void reverseString(char[] s) {
        int l=0,h=s.length-1;
        while(l<h){
            char temp=s[l];
            s[l]=s[h];
            s[h]=temp;
            ++l;
            --h;
        }
    }

}

File: StringCompression.txt
Question Type: Strings
DSA Question: DSA problem related to: StringCompression
----------------------
class Solution {
    public int compress(char[] chars) {
        char currChar=chars[0];
        int currCharCount=1;
        if(chars.length==1){
            return 1;
        }
        int size=0;
        for(int i=1;i<chars.length;++i){
            char temp=chars[i];
            if(temp==currChar){
                currCharCount++;
            }else{
                String number=(currCharCount==1)?"":currCharCount+"";
                chars[size++]=currChar;
                if(number.length()>0){
                    for(int m=0;m<number.length();++m){
                        chars[size++]=number.charAt(m);
                    }
                }
                currChar=temp;
                currCharCount=1;
            }
        }
        String number=(currCharCount==1)?"":currCharCount+"";
        chars[size++]=currChar;
        if(number.length()>0){
            for(int m=0;m<number.length();++m){
                chars[size++]=number.charAt(m);
            }
        }
        return size;
    }
}

File: FirstUniqueCharacterInAString.txt
Question Type: Strings
DSA Question: DSA problem related to: FirstUniqueCharacterInAString
----------------------
//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.
class Solution {
    public int firstUniqChar(String s) {
        Integer[] count=new Integer[256];
        for(int i=0;i<s.length();++i){
            if(count[s.charAt(i)]==null){
                count[s.charAt(i)]=i;
            }else{
                count[s.charAt(i)]=-1;
            }
        }
        
        Integer res=Integer.MAX_VALUE;
        for(int i=0;i<256;++i){
            if(count[i]!=null && count[i]>=0){
                res=Math.min(res,count[i]);
            }
        }
        
        return res==Integer.MAX_VALUE?-1:res;
    }
}

File: ReverseWordsInAString.txt
Question Type: Strings
DSA Question: DSA problem related to: ReverseWordsInAString
----------------------
//Given an input string, reverse the string word by word.
class Solution {
    public String reverseWords(String s) {
        if(s==null || s.length()==0) return "";
        s=reverse(s.toCharArray());
        int curr=0,start=0;
        StringBuilder sb=new StringBuilder();
        while(curr<s.length()){
            if(s.charAt(curr)!=' '){
                ++curr;
            }else{
                if(start!=curr){
                    sb.append(reverse(s.substring(start,curr).toCharArray())+" ");
                    start=curr;
                }else{
                    ++curr;
                    ++start;
                }
            }
        }
        if(start!=curr){
            sb.append(reverse(s.substring(start,curr).toCharArray())+" ");
        }
        return sb.length()==0?"":sb.toString().substring(0,sb.length()-1);
    }
    
    String reverse(char[] arr){
        int l=0,h=arr.length-1;
        while(l<h){
            char temp=arr[l];
            arr[l]=arr[h];
            arr[h]=temp;
            l++;--h;
        }
        return String.valueOf(arr);
    }
}

File: ReverseStringUsingRecursion.txt
Question Type: Strings
DSA Question: DSA problem related to: ReverseStringUsingRecursion
----------------------
/*
Write a function that reverses a string. The input string is given as an array of characters char[].

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

You may assume all the characters consist of printable ascii characters.
*/
class Solution {
    public void reverseString(char[] s) {
        helper(s,0,s.length-1);
    }
    void helper(char[] s,int l,int h){
        if(l<h){
            char temp=s[l];
            s[l]=s[h];
            s[h]=temp;
            helper(s,++l,--h);
        }
    }
}

File: CombinationsOfArray.txt
Question Type: Strings
DSA Question: DSA problem related to: CombinationsOfArray
----------------------
//Combinations Combinations of a Array
class Solution {
    List<List<Integer>> list;
    public List<List<Integer>> subsets(int[] nums) {
        list=new LinkedList<>();
        List<Integer> newList=new LinkedList<>();
        list.add(newList);
        helper(nums,newList,0);
        return list;
    }
    
    void helper(int[] nums,List<Integer> newList,int l){
        for(int i=l;i<nums.length;++i){
            newList.add(nums[i]);
            list.add(new LinkedList(newList));
            if(i+1!=nums.length) {
                helper(nums,newList,i+1);                
            }
            newList.remove(newList.size()-1);
        }
        
    }
    
}

File: ATOI.txt
Question Type: Strings
DSA Question: DSA problem related to: ATOI
----------------------
class Solution {
    public int myAtoi(String str) {//"123"
        if(str.length()==0) return 0;
        str.trim();
        char [] chars=str.toCharArray();
        int result=0;
        int start=0;
        while(start<chars.length && chars[start]==' '){
            ++start;
        }
        boolean isNegative=false;
        if(start<chars.length && chars[start]=='-'){
            ++start;
            isNegative=true;
        }else if(start<chars.length && chars[start]=='+'){
            ++start;
        }
        for(int i=start;i<chars.length;++i){
            if(chars[i]>='0' && chars[i]<='9'){
                int d=chars[i]-'0';
                if(result>(Integer.MAX_VALUE-d)/10){
                    result=isNegative?Integer.MIN_VALUE:Integer.MAX_VALUE;
                    return result;
                }
                result=result*10+(d);
            }else{
                break;
            }
        }
        if(isNegative){
            result=-1*result;
        }
        if(result>Integer.MAX_VALUE){
            return Integer.MAX_VALUE;
        }else if(result<Integer.MIN_VALUE){
            return Integer.MIN_VALUE;
        }
        return result;
    }
}

class Solution {//Revision
    public int myAtoi(String str) {//"123" "4193 with words" "words and 987" "-91283472332"
        str=str.trim();
        if(str.length()==0) return 0;
        int start=-1;
        int startWords=Integer.MAX_VALUE; 
        boolean signEncounterd=false ;
        boolean zeroEncounterd=false;
        for(int i=0;i<str.length();++i){
            char c=str.charAt(i);
            if(c>='1' && c<='9'){
                start=i;
                break;
            }else if(c=='-' || c=='+'){
                if(signEncounterd==true || zeroEncounterd==true){
                    return 0;
                }
                signEncounterd=true;
                continue;
            }else if(c=='0'){
                zeroEncounterd=true;
                continue;
            }else{
                startWords=i;
            }
        }
        if(startWords<start || start==-1){
            return 0;
        }
        int negativeMultiplier=1;
        if(str.charAt(0)=='-'){
            negativeMultiplier=-1;
        }
        double resultF=0.0;
        for(int i=start;i<str.length();++i){
            char c=str.charAt(i);
            if(c<'0' || c>'9') break;
            resultF=resultF*10+(c-'0');
        }
        int ans=0;
        if(resultF>Integer.MAX_VALUE && negativeMultiplier==1){
            ans=Integer.MAX_VALUE;
        }
        else if(resultF>Integer.MAX_VALUE && negativeMultiplier==-1){
            ans=Integer.MIN_VALUE;
        }else{
           ans=(int)resultF;
           ans=ans*negativeMultiplier;
        }
        return ans;
    }
}

File: LongestSubstringWithoutRepeatingCharacters.txt
Question Type: Strings
DSA Question: DSA problem related to: LongestSubstringWithoutRepeatingCharacters
----------------------
//Given a string, find the length of the longest substring without repeating characters.
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int N=s.length();
        int [] memo=new int[128];
        Arrays.fill(memo,-1);
        int maxLen=0;
        for(int j=0,i=0;j<N;++j){
            i=Math.max(i,memo[s.charAt(j)]+1);
            maxLen=Math.max(maxLen,j-i+1);
            memo[s.charAt(j)]=j;
        }
        return maxLen;
    }
}

// Longest Substring Without Repeating Characters
class Solution {//Revision
    public int lengthOfLongestSubstring(String s) {
        int maxSoFar=0;
        int l=0,h;
        Integer memo[]=new Integer[256];
        for(h=0;h<s.length();++h){
            if(memo[s.charAt(h)]!=null){
                l=Math.max(l,1+memo[s.charAt(h)]);    
            }
            maxSoFar=Math.max(maxSoFar,h-l+1);
            memo[s.charAt(h)]=h;
        }
        return maxSoFar;
    }
}   
    

File: DesignHashMap.txt
Question Type: Hashing and HashTable
DSA Question: DSA problem related to: DesignHashMap
----------------------
/*
Design a HashMap without using any built-in hash table libraries.

To be specific, your design should include these functions:

put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.
get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.
*/
class MyPair<T,Y>{
    public T key;
    public Y value;
    
    public MyPair(){
        
    }
    
    public MyPair(T key,Y value){
        this.key=key;
        this.value=value;
    }
    
    @Override
    public String toString(){
        return "key: "+key+" Value: "+value;  
    } 
}
class MyHashMap {
    int CAPACITY;
    List<MyPair<Integer,Integer>>[] hashTable;
    public MyHashMap() {
        CAPACITY=2069;
        hashTable = new LinkedList[CAPACITY];
        for (int i = 0; i < this.CAPACITY; ++i) {
            this.hashTable[i]=new LinkedList<>();
        }
    }
    
    int getHash(int key){
       return key%CAPACITY; 
    }
    
    public void put(int key, int value) {
        int hashKey= getHash(key);
            boolean found=false;
            for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
                if(bucket.key==key){
                    hashTable[hashKey].remove(bucket);
                    break;
                 }
            }
            MyPair<Integer,Integer> newPair=new MyPair<>(key,value);
            hashTable[hashKey].add(newPair); 
    }
    
    public int get(int key) {
        int hashKey= getHash(key);
        if(null==hashTable[hashKey]){
            return -1;
        }
        for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
            if(bucket.key==key){
                return bucket.value;
            }
        }
        return -1;
    }
    
    public void remove(int key) {
        int hashKey= getHash(key);
        if(null==hashTable[hashKey]){
            return;
        }
        for(MyPair<Integer,Integer> bucket:hashTable[hashKey]){
            if(bucket.key==key){
                hashTable[hashKey].remove(bucket); break;
            }
        }
    }
}



File: MyHashSet.txt
Question Type: Hashing and HashTable
DSA Question: DSA problem related to: MyHashSet
----------------------
class MyHashSet {

    int CAPACITY;
    
    List<Integer>[] hashTable;
    
    public MyHashSet() {
        CAPACITY=2069;
        hashTable = new LinkedList[CAPACITY];
        for (int i = 0; i < this.CAPACITY; ++i) {
            this.hashTable[i]=new LinkedList<>();
        }
    }
    
    int getHash(int key){
       return key%CAPACITY; 
    }
    
    public void add(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                hashTable[hashKey].remove(bucket);
                break;
             }
        }
        hashTable[hashKey].add(key); 
    }
    
    public void remove(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                hashTable[hashKey].remove(bucket); break;
            }
        }  
    }
    
    public boolean contains(int key) {
        int hashKey= getHash(key);
        for(Integer bucket:hashTable[hashKey]){
            if(bucket==key){
                return true;
            }
        }
        return false;
    }
}


File: RemoveDuplicatesInAnArray.txt
Question Type: Hashing and HashTable
DSA Question: DSA problem related to: RemoveDuplicatesInAnArray
----------------------
class Solution {
    public int removeDuplicates(int[] arr) {
       int index=0; 
       HashSet<Integer> set=new HashSet<>(); 
       for(int i=0;i<arr.length;++i){
            if(!set.contains(arr[i])){
                set.add(arr[i]); 
                arr[index]=arr[i];
                ++index;
            }
       }
        return index; 
    }
}

File: MinOperationToReduceXToZero.txt
Question Type: TwoPointer
DSA Question: DSA problem related to: MinOperationToReduceXToZero
----------------------
/*
You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.

Return the minimum number of operations to reduce x to exactly 0 if it's possible, otherwise, return -1.
*/
class Solution {//Not Efficent
    
    public int minOperations(int[] arr, int x) {
        int moves=dfs(arr,x,0,arr.length-1);
        System.out.println(moves);
        return moves>arr.length?-1:moves;
    }
    
    int dfs(int[] arr,int target,int l,int h){
        if(target==0) return 0;
        if(l>h || l>arr.length-1 || h<0 || target<0)  return arr.length+1;
        return 1+Math.min(dfs(arr,target-arr[h],l,h-1),dfs(arr,target-arr[l],l+1,h));
    }
}

class Solution {
    public int minOperations(int[] nums, int x) {
        int sum=0;
        for(int num:nums){
            sum+=num;
        }
        int target=sum-x;
        int l=0,max=-1,sumW=0;
        for(int h=0;h<nums.length;++h){
            sumW+=nums[h];
            while(l<=h && sumW>target){
                sumW-=nums[l];
                ++l;
            }
            if(sumW==target){
                max=Math.max(max,h-l+1);
            }
        }
        if(max==-1) return -1;
        return nums.length-max;
    }
}

File: MaxNumberKSumPairs.txt
Question Type: TwoPointer
DSA Question: DSA problem related to: MaxNumberKSumPairs
----------------------
//Max Number of K-Sum Pairs
class Solution {
    public int maxOperations(int[] arr, int k) {
        Arrays.sort(arr);
        int l=0,h=arr.length-1;
        int count=0;
        while(l<h){
            int sum=arr[l]+arr[h];
            if(sum==k){
                ++count;
                ++l;
                --h;
            }else if(sum>k){
                --h;
            }else{
                ++l;
            }
        }
        return count;
    }
}

File: MinSwapsToSortAnDistinctArray.txt
Question Type: CyclicSort
DSA Question: Write an algorithm to sort an array.
----------------------
int minSwapCount(int[] arr){
    int count=0;
    boolean[] visited=new boolean[arr.length];
    for(int i=0;i<arr.length;++i){
        if(visited[i] || arr[i]==i) continue;
        visited[i]=true;
        int cycleCount=0;
        int c=i;
        while(!visited[c]){
            c=arr[c];
            visited[c]=true;
            ++cycleCount;
        }
        count=count+cycleCount-1;
    }
    return count;
}

File: DucthInternationalFlag.txt
Question Type: Array
DSA Question: DSA problem related to: DucthInternationalFlag
----------------------
class Solution {
    public void sortColors(int[] arr) {
        int l=0,m=0,h=arr.length-1;
        while(m<=h){
            if(arr[m]==0){
                swap(arr,l,m);
                l++;
                ++m;
            }else if(arr[m]==1){
                ++m;
            }else if(arr[m]==2){
                swap(arr,m,h);
                --h;
            }
        }
    }
    
    void swap(int[] arr,int m,int h){
        int temp=arr[m];
        arr[m]=arr[h];
        arr[h]=temp;
    }
}

File: TripletSumToZero.txt
Question Type: Array
DSA Question: DSA problem related to: TripletSumToZero
----------------------
import java.util.*;

class TripletSumToZero {

  public static List<List<Integer>> searchTriplets(int[] arr) {
    List<List<Integer>> triplets = new ArrayList<>();
    Arrays.sort(arr);
    for(int i=0;i<arr.length;++i){
      int l=i+1,h=arr.length-1;
      while(l<h){
        int tSum=arr[i]+arr[l]+arr[h];
        if(tSum==0){
          List<Integer> list=new ArrayList<>();
          list.add(arr[i]);list.add(arr[l]);list.add(arr[h]);
          triplets.add(list);
          l++;h--;
        }else if(tSum>0){
          h--;
        }else{
          l++;
        }
      }
    }
    return triplets;
  }
}

class Solution {
  public List<List<Integer>> threeSumDistinctTriplets(int[] arr) {
      List<List<Integer>> triplets = new ArrayList<>();
      Arrays.sort(arr);
      for(int i=0;i<arr.length;++i){
         if(i>0 && arr[i]==arr[i-1]) continue;
        int l=i+1,h=arr.length-1;
        while(l<h){
          int tSum=arr[i]+arr[l]+arr[h];
          if(l>i+1 && arr[l]==arr[l-1]){
              ++l;
          }else if(h<arr.length-1 && arr[h]==arr[h+1]){
              --h;
          }else if(tSum==0){
            List<Integer> list=new ArrayList<>();
            list.add(arr[i]);list.add(arr[l]);list.add(arr[h]);
            triplets.add(list);
            l++;h--;
          }else if(tSum>0){
            h--;
          }else{
            l++;
          }
        }
      }
      return triplets;
  }
}

File: RotateArray.txt
Question Type: Array
DSA Question: DSA problem related to: RotateArray
----------------------
class Solution {
    //1 2 3 4 5 6   //2
    //6 5 4 3 2 1
    //5 6  1 2 3 4 
    public void rotate(int[] nums, int k) {
        k=k%nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    
    void reverse(int[] nums,int l,int h){
        int i=l,j=h;
        while(i<j){
            nums[i]=nums[i]^nums[j];
            nums[j]=nums[i]^nums[j];
            nums[i]=nums[i]^nums[j];
            ++i;
            j--;
        }
    }
}

File: EuclideanDistanceKClosetPointsToOrigin.txt
Question Type: Array
DSA Question: DSA problem related to: EuclideanDistanceKClosetPointsToOrigin
----------------------
/*
We have a list of points on the plane.  Find the K closest points to the origin (0, 0).

(Here, the distance between two points on a plane is the Euclidean distance.)

You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)
*/
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        Arrays.sort(points,new Comparator<int[]>(){
            public int compare(int[] ob1,int[] ob2){
                return getEuclideanDistance(ob1).compareTo(getEuclideanDistance(ob2));
            }
        });
        int[][] result=new int[K][2];
        for(int i=0;i<K;++i){
            result[i][0]=points[i][0];
            result[i][1]=points[i][1];
        }
        return result;
    }
    

    Double getEuclideanDistance(int ob[]){
        int x=ob[0],y=ob[1];
        int compute=x*x+y*y;
        return Math.sqrt(compute);
    }

}


File: MergeIntervals.txt
Question Type: Array
DSA Question: DSA problem related to: MergeIntervals
----------------------
//Given a collection of intervals, merge all overlapping intervals.
class PairComparator implements Comparator<int[]>{ 
    public int compare(int[] p1, int[] p2) { 
        return p1[0]-p2[0];
    } 
} 
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length==0) return intervals;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] ob1,int[] ob2){
                return ob1[0]-ob2[0];
            }
        });
        LinkedList<int[]> list=new LinkedList<>();
        list.add(intervals[0]);
        for(int i=1;i<intervals.length;++i){
            if(list.get(list.size()-1)[1]>=intervals[i][0]){
                list.get(list.size()-1)[1]=Math.max(intervals[i][1],list.get(list.size()-1)[1]);
            }else{
                list.add(intervals[i]);    
            }
        }
        return list.toArray(new int[list.size()][]);
    }
}

File: TwoSum.txt
Question Type: Array
DSA Question: DSA problem related to: TwoSum
----------------------
int twoSumDistinctPairs(int[] arr,int target){
    int count=0;
    int l=0,h=arr.length-1;
    while(l<h){
        int sum=arr[l]+arr[h];
        if(l>0 && arr[l-1]==arr[l]){
            ++l;
        }else if(h<arr.length-1 && arr[h]==arr[h+1]){
            --h;
        }else if(sum==target){
            ++count;
            ++l;
            --h;
        }else if(sum>target){
            h--;
        }else{
            l++;
        }
        return count;
    }
}

{1,1,2,4,5,4} 5
{1,1,2,4,4,5}

l          h 
l         h       +1
  l     h
    l   h
    l h
    h l

File: MinimumSizeSubArraySum.txt
Question Type: Array
DSA Question: DSA problem related to: MinimumSizeSubArraySum
----------------------
class Solution {
    //minimum number of people required for meeting the criteria
    public int minSubArrayLen(int s, int[] nums) {
        if(nums.length==0) return 0;
        int minLengthRequired=Integer.MAX_VALUE;
        int currSumInWindow=0;
        int l=0;
        for(int h=0;h<nums.length;++h){//expansion
            currSumInWindow=currSumInWindow+nums[h];
            while(currSumInWindow>=s){//contraction
                minLengthRequired=Math.min(h-l+1,minLengthRequired);
                currSumInWindow=currSumInWindow-nums[l];
                l++;
            }
        }
        if(minLengthRequired==Integer.MAX_VALUE){
            return 0;
        }
        return minLengthRequired;
        
    }
}

File: MoveZeroes.txt
Question Type: Array
DSA Question: DSA problem related to: MoveZeroes
----------------------
/*
Given an array nums, write a function to move all 0's to the end of it while maintaining the 
relative order of the non-zero elements.
Example:
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.
*/
class Solution {
    public void moveZeroes(int[] nums) {
        int index=0,zeroCount=0;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==0){
                zeroCount++;
            }
            else if(nums[i]!=0){
                nums[index]=nums[i];index++;
            }
        }
        index=nums.length-1;
        for(int i=zeroCount;i>0;--i){
            nums[index]=0; --index;
        }
    }
}

File: TripletWithSmallerSum.txt
Question Type: Array
DSA Question: DSA problem related to: TripletWithSmallerSum
----------------------
import java.util.*;

class TripletWithSmallerSum {

  public static int searchTriplets(int[] arr, int target) {
    int count=0;
    Arrays.sort(arr);
    for(int i=0;i<arr.length;++i){
      int l=i+1,h=arr.length-1;
      while(l<h){
        int sum=arr[i]+arr[l]+arr[h];
        if(sum<target){
          count=count+h-l;
          l++;
        }
        else if(sum>=target){
          --h;
        }
      }
    }
    return count;
  }
}

File: Container with most water.txt
Question Type: Array
DSA Question: DSA problem related to: Container with most water
----------------------
class Solution {
    public int maxArea(int[] height) {
        int maxWater=0;
        int l=0,h=height.length-1;
        while(l<h){
            int water=Math.min(height[l],height[h])*(h-l);
            maxWater=Math.max(maxWater,water);
            if(height[l]<height[h]){
                ++l;
            }else{
                --h;
            }
        }
        return maxWater;
    }
}

File: LongestConsecutiveSequence.txt
Question Type: Array
DSA Question: DSA problem related to: LongestConsecutiveSequence
----------------------
/*
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
*/
class Solution {  //0(nlogn)
    public int longestConsecutive(int[] nums) {
        if(nums.length==0) return 0;
        Arrays.sort(nums);
        int maxCount=1,count=1;
        for(int i=1;i<nums.length;++i){
            if(nums[i]!=nums[i-1]){
                if(nums[i]==nums[i-1]+1){ ++count;}
                else{
                    maxCount=Math.max(count,maxCount);
                    count=1;
                }   
            }
        }
        return Math.max(count,maxCount);
    }
}

File: TwoDifference.txt
Question Type: Array
DSA Question: DSA problem related to: TwoDifference
----------------------
public class TwoDifference {
    int count=0;
    int countDiffPair(int[] arr,int target){
        if(arr.length==0) return 0;
        for(int i=0;i<arr.length;++i){
            binarySearch(i,arr,target-arr[i],true);
            binarySearch(i,arr,target-arr[i],false);
            if(target-arr[i]==0) continue;
            binarySearch(i,arr,arr[i]-target,true);
            binarySearch(i,arr,arr[i]-target,false);
        }
        return count;
    }

    void binarySearch(int l,int[] arr,int key,boolean leftSearch){
        int h=arr.length-1;
        while(l<h){
            int mid=l+(h-l)/2;
            if(arr[mid]==key){
                ++count;
                if(leftSearch){
                    h=mid-1;
                }else{
                    l=mid+1;
                }
            }else if(arr[mid]>key){
                --l;
            }else{
                ++h;
            }
        }
    }
}


File: MergeSortedArray.txt
Question Type: Array
DSA Question: DSA problem related to: MergeSortedArray
----------------------
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index=nums1.length-1;
        int m1=nums1.length;
        while(n>0){
            if(m==0 || nums1[m-1]<nums2[n-1]){
               nums1[index]=nums2[n-1];
               n--; 
            }else{
               nums1[index]=nums1[m-1]; 
               m--; 
            }
            index--;
        }
    }
}

File: Duplicates.txt
Question Type: Array
DSA Question: DSA problem related to: Duplicates
----------------------
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> ans=new ArrayList<>();
        if(nums.length==0) return ans;
        for(int num:nums){
            if(nums[Math.abs(num)-1]<0){
                ans.add(Math.abs(num));
            }else{
                nums[Math.abs(num)-1]=-nums[Math.abs(num)-1];
            }
        }
        return ans;
    }
}

File: RemoveElement.txt
Question Type: Array
DSA Question: DSA problem related to: RemoveElement
----------------------
/*
Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.
*/
class Solution {
    public int removeElement(int[] nums, int val) {
        int index=0;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==val){continue;}
            else{
                nums[index]=nums[i];
                ++index;
            }
        }
        return index;
    }
}

File: Trapping Rain Water.txt
Question Type: Array
DSA Question: DSA problem related to: Trapping Rain Water
----------------------
class Solution {
    public int trap(int[] height) {
        if(height.length==0) return 0;
        int left[]=new int[height.length];
        left[0]=height[0];
        int right[]=new int[height.length];
        right[height.length-1]=height[height.length-1];
        for(int i=1;i<height.length;++i){
            left[i]=Math.max(height[i],left[i-1]);
        }
        for(int i=height.length-2;i>=0;--i){
            right[i]=Math.max(height[i],right[i+1]);
        }
        int maxWater=0;
        for(int i=0;i<height.length;++i){
            maxWater=maxWater+(Math.min(left[i],right[i])-height[i]);
        }
        return maxWater;
    }
}

File: FindFirstMissingNumber.txt
Question Type: Array
DSA Question: DSA problem related to: FindFirstMissingNumber
----------------------
/*
Given an unsorted integer array, find the smallest missing positive integer.
*/
class Solution {
    public int firstMissingPositive(int[] nums) {
        Arrays.sort(nums);
        int number=1;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==number){++number;}
            else if(nums[i]>number){
                break;
            }
        }
        return number;
    }
}

class Solution {
    public int solution(int[] A) {
        for(int i=0;i<A.length;++i){
            if(A[i]<0){
                A[i]=0;
            }
        }
        for(int i=0;i<A.length;++i){
            if(A[i]==0 || A[Math.abs(A[i])-1]<0) continue;
            A[Math.abs(A[i])-1]=-1*A[Math.abs(A[i])-1];
        }
       
        int i=0;
        for(i=0;i<A.length;++i){
            if(A[i]>=0) return i+1;
        }
        return i+1;
    }
}

File: BestTimeToBuyAndSellStock.txt
Question Type: Array
DSA Question: DSA problem related to: BestTimeToBuyAndSellStock
----------------------
/*
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.
*/
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice=Integer.MAX_VALUE,maxProfit=0;
        for(int i=0;i<prices.length;++i){
            if(minPrice>prices[i]){
                minPrice=prices[i];
            }else if(maxProfit<prices[i]-minPrice){
                maxProfit=prices[i]-minPrice;
            }
        }
        return maxProfit;
    }
}

class Solution {//Revision
    public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        int lowest=0;
        int maxProfit=Integer.MIN_VALUE;
        for(int i=1;i<prices.length;++i){
            if(prices[lowest]>prices[i]){
                lowest=i;
            }else{
                int profit=prices[i]-prices[lowest];
                maxProfit=Math.max(maxProfit,profit);
            }
        }
        if(maxProfit==Integer.MIN_VALUE) return 0;
        return maxProfit;
    }
}

File: TripletSumClosestToTarget.txt
Question Type: Array
DSA Question: DSA problem related to: TripletSumClosestToTarget
----------------------
import java.util.*;

class TripletSumCloseToTarget {

  public static int searchTriplet(int[] arr, int targetSum) {
    int sDiff=Integer.MAX_VALUE;
    Arrays.sort(arr);
    for(int i=0;i<arr.length;++i){
      int l=i+1,h=arr.length-1;
      while(l<h){
        int cDiff=arr[i]+arr[l]+arr[h]-targetSum;
        if(Math.abs(cDiff)<Math.abs(sDiff)){
          sDiff=cDiff;
        }
        if(cDiff==0) return 0;
        if(cDiff>0){
          --h;
        }else{
          ++l;
        }
      }
    }
    return targetSum+sDiff;
  }
}

File: ArraySumPartition.txt
Question Type: Array
DSA Question: DSA problem related to: ArraySumPartition
----------------------
/*Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.
*/
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int maxSum=0;
        for(int i=0;i<nums.length;i=i+2){
            maxSum=maxSum+Math.min(nums[i],nums[i+1]);
        }
        return maxSum;
    }
}

File: ProductOfNumbersExceptSelf.txt
Question Type: Array
DSA Question: DSA problem related to: ProductOfNumbersExceptSelf
----------------------
/*
Given an array nums of n integers where n > 1,  return an array output such that output[i] 
is equal to the product of all the elements of nums except nums[i].
*/
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] answer = new int[length];
        answer[0] = 1;
        for (int i = 1; i < length; i++) {
            answer[i] = nums[i - 1] * answer[i - 1];
        }
        int R = 1;
        for (int i = length - 1; i >= 0; i--) {
            answer[i] = answer[i] * R;
            R *= nums[i];
        }
        return answer;
    }
}

class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] left=new int[nums.length];
        int[] right=new int[nums.length];
        left[0]=1;
        for(int i=1;i<left.length;++i){
            left[i]=nums[i-1]*left[i-1];
        }
        right[nums.length-1]=1;
        for(int i=nums.length-2;i>=0;--i){
            right[i]=nums[i+1]*right[i+1];
        }
        for(int i=0;i<nums.length;++i){
            nums[i]=left[i]*right[i];
        }
        return nums;
    }
}

File: MaxConsecutiveOnes.txt
Question Type: Array
DSA Question: DSA problem related to: MaxConsecutiveOnes
----------------------
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int maxSeqLen=0;
        int currSeqLength=0;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==1){
                ++currSeqLength;
            }else{
                maxSeqLen=Math.max(currSeqLength,maxSeqLen);
                currSeqLength=0;
            }
        }
        return maxSeqLen=Math.max(currSeqLength,maxSeqLen);
    }
}

File: GetMaximumInGenereatedArray.txt
Question Type: Array
DSA Question: DSA problem related to: GetMaximumInGenereatedArray
----------------------
/*
You are given an integer n. An array nums of length n + 1 is generated in the following way:

nums[0] = 0
nums[1] = 1
nums[2 * i] = nums[i] when 2 <= 2 * i <= n
nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n
Return the maximum integer in the array nums​​​.
*/
class Solution {
    public int getMaximumGenerated(int n) {
        if(n<=0) return 0;
        int[] memo=new int[n+1];
        memo[0]=0;
        memo[1]=1;
        int max=1;
        for(int i=2;i<memo.length;++i){
            if(i%2==0){
                memo[i]=memo[i/2];
            }else{
                memo[i]=memo[i/2]+memo[i/2+1];
            }
            max=Math.max(max,memo[i]);
        }
        return max;
    }
}

File: NestedlistWeightSum.txt
Question Type: Recursion
DSA Question: DSA problem related to: NestedlistWeightSum
----------------------
/**
 * 
 * You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.

The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.

Return the sum of each integer in nestedList multiplied by its depth.

 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *     // Constructor initializes an empty nested list.
 *     public NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     public NestedInteger(int value);
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // Set this NestedInteger to hold a single integer.
 *     public void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     public void add(NestedInteger ni);
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List<NestedInteger> getList();
 * }
 */
class Solution {
    int sum=0;
    public int depthSum(List<NestedInteger> nestedList) {
        dfs(nestedList,1,0);
        return sum;
    }
    
    void dfs(List<NestedInteger> list,int depth,int index){
        if(index==list.size()) return;
        NestedInteger curr=list.get(index);
        if(curr.isInteger()){
            sum=sum+depth*curr.getInteger();
            dfs(list,depth,index+1);
        }else{
            dfs(curr.getList(),depth+1,0);
            dfs(list,depth,index+1);
        }
    }
}

File: CountSortedVowelString.txt
Question Type: Recursion
DSA Question: DSA problem related to: CountSortedVowelString
----------------------
class Solution {//Not Efficient
    char[] arr={'a','e','i','o','u'};
    public int countVowelStrings(int n) {
         return helper("",0,n);          
    }
    
    int helper(String str,int index,int n){
        if(str.length()==n) {
            System.out.println(str);
            return 1;
        }
        int count=0;
        for(int i=index;i<arr.length;++i){
            count=count+helper(str+arr[i],i,n);
        }
        return count;
    }
}

class Solution {//Not efficent
    char[] arr={'a','e','i','o','u'};
    HashSet<String> set=new HashSet<>();
    public int countVowelStrings(int n) {
        for(int i=0;i<arr.length;++i){
          helper(""+arr[i],i,n);          
        }
        return set.size();
    }
    
    void helper(String str,int index,int n){
        if(str.length()==n) {
            set.add(str);
            return ;
        }
        if(index==arr.length) return;
        helper(str+arr[index],index,n);
        helper(str,index+1,n);
        if(index+1>=arr.length) return;
        helper(str+arr[index+1],index+1,n);
    }
}

File: LetterCombination.txt
Question Type: Recursion
DSA Question: DSA problem related to: LetterCombination
----------------------
class Solution {
   
    public List<String> letterCombinations(String digits) {
        List<String> ans=new ArrayList<>();
        if(digits.length()==0) return ans;
        Map<Integer,String> map=new HashMap<>();
        map.put(2,"abc");
        map.put(3,"def");
        map.put(4,"ghi");
        map.put(5,"jkl");
        map.put(6,"mno");
        map.put(7,"pqrs");
        map.put(8,"tuv");
        map.put(9,"wxyz");
        helper(map,ans,digits,0,"");        
        return ans;
    }
    
    void helper(Map<Integer,String> map,List<String> ans,String digits,int digit,String s){
        if(digit==digits.length()){
            ans.add(s);
            return;
        }
        for(int i=0;i<map.get(Integer.parseInt(""+digits.charAt(digit))).length();++i){
            helper(map,ans,digits,digit+1,s+map.get(Integer.parseInt(""+digits.charAt(digit))).charAt(i));
        }   
    }

}

File: GenerateParenthesis.txt
Question Type: Recursion
DSA Question: DSA problem related to: GenerateParenthesis
----------------------
class Solution {

    public List<String> generateParenthesis(int n) {
        List<String> ans=new ArrayList<>();
        if(n==0) return ans;
        StringBuilder sb=new StringBuilder();
        helper(ans,n,0,"");
        return ans;
    }
    
    void helper(List<String> ans,int n,int openCount,String s){
        if(s.length()==n*2){
            ans.add(s);
            return;
        }
        if(openCount<n){
            helper(ans,n,openCount+1,s+"(");
        }
        int closeCount=s.length()-openCount;
        if(closeCount<openCount && closeCount<n){
            helper(ans,n,openCount,s+")");
        }
    }

}

File: TowerOfHinoe.txt
Question Type: Recursion
DSA Question: DSA problem related to: TowerOfHinoe
----------------------


File: CombinationSum.txt
Question Type: Recursion
DSA Question: DSA problem related to: CombinationSum
----------------------
/*
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), 
find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
*/
class Solution {
    
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result=new ArrayList<>();
        helper(candidates,0,target,result,new ArrayList<Integer>());
        return result; 
    }
    
    void helper(int[] arr,int index,int target,List<List<Integer>> result,List<Integer> temp){
        if(target<0) return;
        if(target==0){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i]){
                temp.add(arr[i]);
                helper(arr,i,target-arr[i],result,temp);
                temp.remove(temp.size()-1);
            }
        }
    }
}

File: Factorial.txt
Question Type: Recursion
DSA Question: DSA problem related to: Factorial
----------------------
public class Factorial{
	static int factorial(int n){
		if(n==0 || n==1) return 1;
		return n*factorial(n-1);
	}

	public static void main(String args[]){
		System.out.print("factorial of 5 is :  "+factorial(5));
	}
}

File: Fibonacii.txt
Question Type: Recursion
DSA Question: DSA problem related to: Fibonacii
----------------------
public class Fibonacii{
	static int fibonacii(int n){
		if(n==0)return 0;
		if(n==1) return 1;
		return fibonacii(n-1)+fibonacii(n-2);
	}

	public static void main(String args[]){
		System.out.print("fibonacii of 8 is :  "+fibonacii(8));
	}
}

File: PermutationOfNumbersInAnArray.txt
Question Type: Recursion
DSA Question: DSA problem related to: PermutationOfNumbersInAnArray
----------------------
class Solution {
    List<List<Integer>> list;
    public List<List<Integer>> permute(int[] nums) {
        list=new LinkedList<>();
        if(nums.length==0) return list;
        helper(nums,0,nums.length-1);
        return list;
    }
    
    void helper(int[] nums,int l,int h){
        if(l==h){
            List<Integer> newList=new ArrayList<>();
            for(int i=0;i<nums.length;++i){
                newList.add(nums[i]);
            }
            list.add(newList);
        }else{
            for(int i=l;i<=h;++i){
                swap(nums,i,l);
                helper(nums,l+1,h);
                swap(nums,i,l);
            }
        }
    }
    
    void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}


File: CombinationSumII.txt
Question Type: Recursion
DSA Question: DSA problem related to: CombinationSumII
----------------------
/*
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
*/
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> result=new ArrayList<>();
        helper(candidates,0,target,result,new ArrayList<Integer>());
        return result;
    }
    
    void helper(int[] arr,int index,int target,List<List<Integer>> result,List<Integer> selected){
        if(target<0){
          return;   
        }
        if(target==0){
            result.add(new ArrayList<>(selected));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i] && (i==index || arr[i]!=arr[i-1])){
                selected.add(arr[i]);
                helper(arr,i+1,target-arr[i],result,selected);
                selected.remove(selected.size()-1);
            }
        }
    }
}

File: AlteredBinarySearchPivot.txt
Question Type: Searching
DSA Question: Implement a searching algorithm.
----------------------
/*
Search in Rotated Sorted Array*/

class Solution {//[4,5,6,7,0,1,2]
    public int search(int[] nums, int target) {
        return helper(nums,target,0,nums.length-1);
    }
    
    int helper(int[] nums,int target,int l,int h){
        if(l>h) return -1;
        int mid=l+(h-l)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[l]<=nums[mid]){
            int index1= helper(nums,target,l,mid-1);
            if(index1>=0) return index1;
            return helper(nums,target,mid+1,h);
        }
        int index2=helper(nums,target,mid+1,h);
        if(index2>=0) return index2;
        return helper(nums,target,l,mid-1);
    }
    
}

class AlteredBinarySearchPivot { //binary Search Altered
    public int search(int[] arr, int target) {
       return srch(arr,0,arr.length-1,target);
    }
    
    int srch(int[] arr,int l,int h,int target){ // trick: find the sorted half and check if target in it
                                                // if not in sorted half go to unsorted half
        if(h<l){return -1;}
        int mid=(l+h)/2;
        if(arr[mid]==target) return mid;
        if(arr[mid]>=arr[l]){ //is first half sorted
            if(target>=arr[l] && target<=arr[mid]){   //is in first half             
                return srch(arr,l,mid-1,target);
            }else{
                return srch(arr,mid+1,h,target); //in secound half
            }   
        }else{//2nd half sorted
            if(target>=arr[mid] && target<=arr[h]){//in secound half
                return srch(arr,mid+1,h,target);
            } else{ // in first half
                return srch(arr,l,mid-1,target);
            }

        }       
    } 
}

class Solution {  // revision one
    public int search(int[] nums, int target) {
        if(nums.length==0) return -1;
        return binarySearch(nums,0,nums.length-1,target);          
    }
    
    int binarySearch(int[] arr,int l,int h,int target){
        if(l<=h){
            int mid=(l+h)/2;
            if(arr[mid]==target){return mid;}
            else if(l<=mid-1 && arr[l]<=arr[mid-1]){
                int val=binarySearch(arr,l,mid-1,target);
                if(val>=0){return val;}
                else return binarySearch(arr,mid+1,h,target);
            }else{
                int val=binarySearch(arr,mid+1,h,target);
                if(val>=0){return val;}
                else return binarySearch(arr,l,mid-1,target);
            }
        }
        return -1;
    }
    
}

File: Searching.txt
Question Type: Searching
DSA Question: Implement a searching algorithm.
----------------------
Linear Search -> o(n)
Binary Search ->o(logn)  -> calculate mid and check whether the element at mid equals the key if not either
 search on left or right of the mid based on whether the mid element is less than or greate than the key.

File: RangeSearch.txt
Question Type: Searching
DSA Question: Implement a searching algorithm.
----------------------
h
int findCountOfElement(int[] arr,int target){
    if(arr.length==0)return -1;
    int left=getRange(arr,0,arr.length-1,false,target);
    if(left==-1) return -1;
    int right=getRange(arr,0,arr.length-1,true,target);
    return right-left+1;
} 
int getRange(int[] arr,int l,int h,boolean isLeft,int target){
    int range=-1;
    while(l<=h){
        int mid=l+(h-l)/2;
        if(arr[mid]==target){
            range=mid;
            if(!isLeft){
                h=mid-1;
            }else{
                l=mid+1;
            }
        }
        else if(arr[mid]>target){
            h=mid-1;
        }else{
            l=mid+1;
        }
    }
    
    return range;
}

File: StartAndEndOfTragetValueInAnArray.txt
Question Type: Searching
DSA Question: Implement a searching algorithm.
----------------------
/*
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].
*/
class StartAndEndOfTragetValueInAnArray {
    public int[] searchRange(int[] nums, int target) {
        int l=-1,h=-1;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==target){
                if(l==-1){
                    l=i;h=i;
                }else{
                    h=i;
                }
            }
            if(nums[i]!=target && l!=-1){
                break;
            }
        }
        int [] result={l,h};
        return result;
    }
}

File: AddTwoNumberIIUsingStack.txt
Question Type: LinkedList
DSA Question: DSA problem related to: AddTwoNumberIIUsingStack
----------------------
/*
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.
*/
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<Integer> s1=getStack(l1);
        Stack<Integer> s2=getStack(l2);
        ListNode dummy=new ListNode();
        int carry=0;
        while(!s1.isEmpty() || !s2.isEmpty()){
            int x=s1.isEmpty()?0:s1.pop();int y=s2.isEmpty()?0:s2.pop();
            int sum=(x+y+carry)%10;
            carry=(x+y+carry)/10;
            addAfterDummyNode(new ListNode(sum), dummy);
        }
        if(carry!=0){
            addAfterDummyNode(new ListNode(carry), dummy);
        }
        return dummy.next;
    }
    
    void addAfterDummyNode(ListNode node,ListNode dummy){
        node.next=dummy.next;
        dummy.next=node;
    }
    
    Stack getStack(ListNode node){
        Stack<Integer> stack=new Stack<>();
        while(node !=null){
            stack.add(node.val);
            node=node.next;
        }
        return stack;
    }
        
}

File: AddTwoNumberIIUsingReverse.txt
Question Type: LinkedList
DSA Question: DSA problem related to: AddTwoNumberIIUsingReverse
----------------------
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1=reverse(l1);
        l2=reverse(l2);
        int carry=0,sum;
        ListNode current1=l1,current2=l2,prev1=null,prev2=null;
        while(current1 !=null && current2 !=null){
            sum=current1.val+current2.val+carry;
            carry=sum/10;
            current1.val=sum%10;
            prev1=current1; prev2=current2;
            current1=current1.next; current2=current2.next;
        }
        while(current1!=null){
            sum= current1.val+carry;
            current1.val=sum%10;
            carry=sum/10;
            prev1=current1;
            current1=current1.next;
        }
        while(current2!=null){
            sum= current2.val+carry;
            prev1.next=new ListNode(sum%10);
            carry=sum/10;
            prev1=prev1.next;
            current2=current2.next;
        }
        if(carry!=0){
            prev1.next=new ListNode(carry);
        }
       return reverse(l1); 
    }
    
    ListNode reverse(ListNode head){
        ListNode prev=null,next=null,curr=head;
        while(curr!=null){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
    }
}

File: ReverseNodesInKGroup.txt
Question Type: LinkedList
DSA Question: DSA problem related to: ReverseNodesInKGroup
----------------------
/**
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes 
is not a multiple of k then left-out nodes in the end should remain as it is.
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode curr=head;
        int size=0;
        while(curr!=null){
            curr=curr.next;
            ++size;
        }
        ListNode dummy=new ListNode();
        dummy.next=head;
        ListNode last=dummy;
        int i=0;
        while(last!=null && size-i>=k){
            last=reverseKElementsOnly(last,k);
            i=i+k;
        }
        return dummy.next;
        
    }
    
    ListNode reverseKElementsOnly(ListNode last,int k){
        int i=0;
        ListNode head=last.next;
        ListNode curr=head,prev=null,next=null;
        while(i<k && curr!=null){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
            ++i;
        }
        last.next=prev;//prev have become head nad will be attached to last 
        if(head!=null){
            head.next=curr;    
        }
        return head;//head have come to end and will become last for next call
    }
}

class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode curr=head,prevTail=null,newHead=null;
        while(curr!=null){
            int count=0;
            curr=head;
            while(count<k && curr!=null){
                curr=curr.next;
                ++count;
            }
            if(count==k){
                ListNode revHead=reversekNodes(head,k);
                if(prevTail!=null){prevTail.next=revHead;}
                if(newHead==null){newHead=revHead;}
                prevTail=head;
                head=curr;
            }
        }
        if(prevTail!=null){prevTail.next=head;}
        return newHead==null?head:newHead;
    }
    
    ListNode reversekNodes(ListNode node,int k){
        ListNode curr=node,prev=null,next=null;
        while(k>0){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
            --k;
        }
        return prev;
    }
}

File: SortLinkedListusingMergeSort.txt
Question Type: LinkedList
DSA Question: DSA problem related to: SortLinkedListusingMergeSort
----------------------
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode fast=head;
        ListNode half=head;
        ListNode tail=half;
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            tail=half;
            half=half.next;
        }
        tail.next=null;
        ListNode left= sortList(head);
        ListNode right= sortList(half);
        return merge(left,right);
    }
    
    ListNode merge(ListNode left, ListNode right){
        ListNode dummy=new ListNode();
        ListNode current=dummy;
        while(left!=null && right!=null){
            if(left.val>=right.val){
                current.next=right;
                right=right.next;
                current=current.next;
            }else{
                current.next=left;
                left=left.next;
                current=current.next;
            }
        }
        if(left!=null){current.next=left;}
        if(right!=null){current.next=right;}
        return dummy.next;
    }
}

File: ReverseLinkedListBetweenAandB.txt
Question Type: LinkedList
DSA Question: DSA problem related to: ReverseLinkedListBetweenAandB
----------------------
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if (head == null) {
            return null;
        }
        ListNode dummy=new ListNode(-1);
        dummy.next=head;
        ListNode prev=dummy;
        int i=0;
        while(head!=null && m>1){
            m--;
            n--;
            prev=head;
            head=head.next;
        }
        prev.next=reverse(head,n);
        return dummy.next;
    }
    
    ListNode reverse(ListNode head,int n){
        if(head==null) return null;
        ListNode dummy=new ListNode();
        dummy.next=head;
        ListNode next=null,prev=null,curr=head;
        while(curr!=null && n>0){
            --n;
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        head.next=curr;
        return prev;
    }
}

File: ReverseList.txt
Question Type: LinkedList
DSA Question: DSA problem related to: ReverseList
----------------------
public class ReverseList{
	static void printAll(Node head){
		while(head!=null){
			System.out.print(head.data+"->");
			head=head.next;
		}
		System.out.print("\n");
	}
	//prev  current
	//null   //1       2 3 4 5 6
	static Node reverseList(Node head){
		Node current=head;
		Node prev=null;
		Node temp;
		while(current!=null){
			temp=current.next;
			current.next=prev;
			prev=current;
			current=temp;
		}
		head=prev;
		return head;
	}	

	public static void main(String args[]){
		Node head=new Node(1);
		head.next=new Node(2);
		head.next.next=new Node(3);
		head.next.next.next=new Node(4);
		head.next.next.next.next=new Node(5);
		head.next.next.next.next.next=new Node(6);
		head.next.next.next.next.next.next=new Node(7);
		
		printAll(head);		
		printAll(reverseList(head));	
	}
}

class Node{
	public int data;
	public Node next;

	public Node(){
		
	}
	public Node(int data){
		this.data=data;
		
	}
	public Node(int data,Node next){
		this.data=data;
		this.next=next;
	}
}

File: DeepCopyRandomPointer.txt
Question Type: LinkedList
DSA Question: DSA problem related to: DeepCopyRandomPointer
----------------------
//Deep Copy
/*
A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

Return a deep copy of the list.

The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:

val: an integer representing Node.val
random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.
*/
class Solution {
    public Node copyRandomList(Node head) {
        Node current=head;
        HashMap<Node,Node> map=new HashMap<>();
        while(current!=null){
            map.put(current,new Node(current.val));
            current=current.next;
        }
        current=head;
        Node temp=null;
        while(current!=null){
            temp=map.get(current);
            temp.next=map.get(current.next);
            temp.random=map.get(current.random);
            current=current.next;
        }
        return map.get(head);
    }
}

File: LinkedListCycleStartPoint.txt
Question Type: LinkedList
DSA Question: DSA problem related to: LinkedListCycleStartPoint
----------------------
/**
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) 
in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

Note: Do not modify the linked list
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head==null) return null;
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow) break;
        }
        if(fast==null || fast.next==null) return null;
        fast=head;
        while(fast!=slow){
            fast=fast.next;
            slow=slow.next;
            if(fast==slow)
            return fast;
        }
        return fast;
    }
}

File: MergeKSortedLinkedList.txt
Question Type: LinkedList
DSA Question: DSA problem related to: MergeKSortedLinkedList
----------------------
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode dummy=new ListNode();
        if(lists.length==0) return null;
        PriorityQueue<ListNode> pq=new PriorityQueue<>(new Comparator<ListNode>(){
            public int compare(ListNode n1,ListNode n2){
                return n1.val-n2.val;
            }            
        });
        for(ListNode node:lists){
            if(node!=null){
                pq.add(node);    
            }
        }
        ListNode curr=dummy;
        while(!pq.isEmpty()){
            ListNode node=pq.poll();
            curr.next=node;
            curr=curr.next;
            if(node.next!=null){
                pq.add(node.next);
            }
        }
        return dummy.next;
      
    }
}

File: SwapInPair.txt
Question Type: LinkedList
DSA Question: DSA problem related to: SwapInPair
----------------------
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null)return null;
        if(head.next==null)return head;
        ListNode current=head,next;
        head=head.next;
        ListNode prev=null;
        while(current!=null && current.next!=null){
            current = reverse(current,prev);
            prev=current.next;
            current=current.next.next;
        }
        return head;
    }
    
    ListNode reverse(ListNode current,ListNode prev){
        ListNode temp=current.next; 
        current.next=temp.next;
        temp.next=current;
        if(prev!=null)prev.next=temp;
        return temp;
    }
}

File: AddTwoNumber.txt
Question Type: LinkedList
DSA Question: DSA problem related to: AddTwoNumber
----------------------
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Queue<Integer> q1=new LinkedList<>(),q2=new LinkedList<>();
        while(l1!=null){
            q1.add(l1.val);
            l1=l1.next;
        }
        while(l2!=null){
            q2.add(l2.val);
            l2=l2.next;
        }
        ListNode dummy=new ListNode();
        ListNode temp=dummy;
        int carry=0;
        while(!q1.isEmpty() || !q2.isEmpty() || carry!=0){
            int x=q1.isEmpty()?0:q1.poll();
            int y=q2.isEmpty()?0:q2.poll();
            int sum=(x+y+carry)%10;
            carry=(x+y+carry)/10;
            temp.next=new ListNode(sum);
            temp=temp.next;
        }
        return dummy.next;
    }
}

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy=new ListNode();
        ListNode curr=dummy;
        int carry=0;
        while(l1!=null && l2!=null){
            int sum=carry+l1.val+l2.val;
            carry=0;
            curr.next=new ListNode(sum%10);
            carry=sum/10;
            l1=l1.next;
            l2=l2.next;
            curr=curr.next;
        }
        
        while(l1!=null){
            int sum=carry+l1.val;
            carry=0;
            curr.next=new ListNode(sum%10);
            carry=sum/10;
            l1=l1.next;
            curr=curr.next;
        }
        
        while(l2!=null){
            int sum=carry+l2.val;
            carry=0;
            curr.next=new ListNode(sum%10);
            carry=sum/10;
            l2=l2.next; 
            curr=curr.next;
        }
        
        if(carry!=0){
            curr.next=new ListNode(carry);
        }
        
        return dummy.next;
    }
}


File: MergeTwoSortedLinkedList.txt
Question Type: LinkedList
DSA Question: DSA problem related to: MergeTwoSortedLinkedList
----------------------
/*
Merge two sorted linked lists and return it as a new list. 
The new list should be made by splicing together the nodes of the first two lists.
 */
class Solution{
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode[] lists={l1,l2};
        return mergeKLists(lists);
        
    }
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode dummy=new ListNode();
        if(lists.length==0) return null;
        PriorityQueue<ListNode> pq=new PriorityQueue<>(new Comparator<ListNode>(){
            public int compare(ListNode n1,ListNode n2){
                return n1.val-n2.val;
            }            
        });
        for(ListNode node:lists){
            if(node!=null){
                pq.add(node);    
            }
        }
        
        ListNode curr=dummy;
        while(!pq.isEmpty()){
            ListNode node=pq.poll();
            curr.next=node;
            curr=curr.next;
            if(node.next!=null){
                pq.add(node.next);
            }
        }
        return dummy.next;
      
    }
}

class MergeTwoSortedLinkedList{
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode result=new ListNode();
        ListNode current=result;
        while(l1!=null && l2!=null){
            if(l1.val<=l2.val){
              current.next=l1;
              current=current.next;  
              l1=l1.next;   
            }
            else{
              current.next=l2;
              current=current.next;  
              l2=l2.next;   
            } 
        }
         while(l1!=null && l2!=null){
            if(l1.val<=l2.val){
              current.next=l1;
              current=current.next;  
              l1=l1.next;   
            }
            else{
              current.next=l2;
              current=current.next;  
              l2=l2.next;   
            } 
        }
         if(l1!=null){
              current.next=l1;
         }
         if(l2!=null){
              current.next=l2;
         }
        return result.next;
    }
}

File: RemoveNthFromEnd.txt
Question Type: LinkedList
DSA Question: DSA problem related to: RemoveNthFromEnd
----------------------
/*
Given a linked list, remove the n-th node from the end of list and return its head.
 */
class RemoveNthFromEnd{
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy=new ListNode();
        dummy.next=head;
        ListNode pointer1=dummy;
        ListNode pointer2=dummy;
        
        for(int i = 1;i<=n+1;++i){
            pointer1=pointer1.next;
        }
        while(pointer1!=null){
            pointer1=pointer1.next;
            pointer2=pointer2.next;
        }
        pointer2.next=pointer2.next.next;
        return dummy.next;
    }
}

File: SumOfSubset.txt
Question Type: BackTracking
DSA Question: DSA problem related to: SumOfSubset
----------------------
class Solution {
    int[] ans;
    public void SumOfSubset(int[] nums, int target) {
        ans=new int[nums.length];//000000
        int sum=0;
        for(int num:nums){
            sum=sum+num;
        }
        for(int i=0;i<nums.length;++i){
            DFS(sum,nums,i,target,0);            
        }
    }
    
    void DFS(int remainSum,int[] nums,int i,int target,int currSum){
        if(target==currSum){
            for(int z=0;z<ans.length;++z){
                System.out.print(ans[z]);
            }
            System.out.println("");
        }
        if(i==nums.length) return;
        if(remainSum<target-currSum) return;
        if(nums[i]+currSum<=target){
            ans[i]=1;
            DFS(remainSum-nums[i],nums,i+1,target,currSum+nums[i]);//selected
            ans[i]=0;
            DFS(remainSum,nums,i+1,target,currSum);//not selected
        }
    }
    
}

File: CombinationSum.txt
Question Type: BackTracking
DSA Question: DSA problem related to: CombinationSum
----------------------
class Solution {
    List<List<Integer>> combinations=new ArrayList<>();
    public List<List<Integer>> combinationSubSequenceSumEqulasTarget(int[] arr, int target) {
        ArrayList<Integer> list=new ArrayList<>();
        helper(arr,target,list,0);
        return combinations;
    }
    
    void helper(int[] arr,int target,ArrayList<Integer> list,int index){
        if(target<0) return;
        if(target==0){
            combinations.add(new ArrayList<Integer>(list));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i]){
                list.add(arr[i]);
                helper(arr,target-arr[i],list,i);
                list.remove(list.size()-1);                
            }
        }
    }
}

File: permutation.txt
Question Type: BackTracking
DSA Question: DSA problem related to: permutation
----------------------
public class permutation {

    public static void printPermutationShuffle(char[] arr){
        backTracking(arr,0);
    }

    static void backTracking(char[] arr,int index){//String is prepared before this index
        if(index==arr.length-1){
            System.out.println(String.valueOf(arr));
            return;
        }
        for(int i=index;i<arr.length;++i){
            swap(arr,i,index);
            backTracking(arr, index+1);
            swap(arr,i,index);
        }
    }
    
    private static void swap(char[] arr, int i, int index) {
        char temp=arr[i];
        arr[i]=arr[index];
        arr[index]=temp;
    }

    public static void main(String[] args) {
        printPermutation("123".toCharArray());
    }
}


File: combination.txt
Question Type: BackTracking
DSA Question: DSA problem related to: combination
----------------------
public class combination {
    public static void printCombinationSubString(char[] arr){
        System.out.println("");
        for(int i=0;i<arr.length;++i){
            backTracking(arr,i,arr[i]+"");
        }
    }

    static void backTracking(char[] arr,int index,String str){//String is prepared before this index
        System.out.println(str);
        if(index==arr.length-1) return;
        backTracking(arr, index+1, str+arr[index+1]);
    }
    
    public static void main(String[] args) {
        printCombination("123".toCharArray());
    }
}


File: SubArraySumEqualsK.txt
Question Type: BackTracking
DSA Question: DSA problem related to: SubArraySumEqualsK
----------------------
/*
Given an array of integers and an integer k, you need to find the total number of 
continuous subarrays whose sum equals to k.
*/
class Solution {  //Using Cumulative Sum Approcah i.e store sum of all the numbers --- o(n2)
    int count=0;
    public int subarraySum(int[] nums, int k) {
        int count=0;
        int[] sum=new int[nums.length+1];
        sum[0]=0;
        for(int i=1;i<=nums.length;++i){
            sum[i]=sum[i-1]+nums[i-1];
        }
        for(int start=0;start<nums.length;++start){
            for(int end=start+1;end<=nums.length;end++){
                if(sum[end]-sum[start]==k){
                    count++;
                }
            }
        }
        return count;
    }
}

File: AllPathsFromSorceToDst.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Solution {
    List<List<Integer>> ans=new ArrayList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        boolean[] visited=new boolean[graph.length];
        LinkedList<Integer> s=new LinkedList<>();
        s.add(0);
        DFS(graph,0,s,visited);
        return ans;
    }
    
    void DFS(int[][] graph,int u,LinkedList<Integer> s,boolean[] visited){
        visited[u]=true;
        if(u==graph.length-1){
            ans.add(new ArrayList<Integer>(s));
            visited[u]=false;
            return;
        }
        for(int v:graph[u]){
            if(visited[v]==false){
                s.add(v);
                DFS(graph,v,s,visited);
                s.remove(s.size()-1);
            }
        }
        visited[u]=false;
    }
    
}

File: ShortestPathInBinaryMatrix.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        if(grid.length==0) return -1;
        if(grid[0][0]==1) return-1;
        return hasPath(grid,new int[]{0,0},new int[]{grid.length-1,grid[0].length-1},0);
    }
    boolean isSafe(int[] v,int[][] maze){
        return v[0]>=0 && v[0]<maze.length && 
            v[1]>=0 && v[1]<maze[0].length && maze[v[0]][v[1]]==0;
    }
    
    public int hasPath(int[][] maze, int[] start, int[] destination,int level) {
        Queue<int[]> q=new LinkedList<>();
        boolean[][] visited=new boolean[maze.length][maze[0].length];
        q.add(start);
        int[] x={0,0,1,-1,1,-1,1,-1};
        int[] y={1,-1,0,0,1,-1,-1,1};
        while(!q.isEmpty()){
            int size=q.size();
            ++level;
            for(int m=0;m<size;++m){
                int[] u=q.poll();
                visited[u[0]][u[1]]=true;
                if(destination[0]==u[0]&&destination[1]==u[1]){
                    return level;
                }
                for(int i=0;i<x.length;++i){
                    int[] v=new int[]{u[0]+x[i],u[1]+y[i]};
                    if(isSafe(v,maze) && visited[v[0]][v[1]]!=true){
                        q.add(v);
                    }
                }                
            }
        }
        return -1;
    }
}



File: CycleDetectionCourseScheduleTopologicalSortDAG.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
/*
There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, 
which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to 
finish all courses?
*/
class Solution {
    public boolean canFinish(int numCourses, int[][] courses) {
        Integer[] inDegree=new Integer[numCourses];
        for(int i=0;i<numCourses;++i){
            inDegree[i]=0;
        }
        List<List<Integer>> graph=new LinkedList<>();
        for(int i=0;i<numCourses;++i){
            graph.add(new LinkedList<Integer>());
        }
        for(int i=0;i<courses.length;++i){
            graph.get(courses[i][1]).add(courses[i][0]);
            inDegree[courses[i][0]]++;
        }
        Boolean visited[]=new Boolean[numCourses];
        Queue<Integer> queue=new LinkedList<>();
        for(int i=0;i<inDegree.length;++i){
            if(inDegree[i]==0){
                queue.add(i);
                visited[i]=true;
            }
        }
        while(!queue.isEmpty()){
            int curr=queue.poll();
            for(int i=0;i<graph.get(curr).size();++i){
                int j=graph.get(curr).get(i);
                if(visited[j]==null){
                    --inDegree[j];
                    if(inDegree[j]==0){
                        queue.add(j);
                        visited[j]=true;
                    }
                }
            }
        }
        for(int i=0;i<inDegree.length;++i){
            if(inDegree[i]!=0) return false;
        }
        return true;
    }
}

File: CriticalConnections.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
/*
There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.

A critical connection is a connection that, if removed, will make some server unable to reach some other server.

Return all critical connections in the network in any order.
*/
class Solution {
    int time=0;
    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        int[] visitTime=new int[n];
        int[] lowTime=new int[n];
        boolean visited[]=new boolean[n];
        List<List<Integer>> result=new ArrayList<>();
        ArrayList<Integer>[] graph=new ArrayList[n];
        for(int i=0;i<graph.length;++i){
            graph[i]=new ArrayList<Integer>();
        }
        for(List<Integer> connection: connections){
            int a=connection.get(0),b=connection.get(1);
            graph[a].add(b); graph[b].add(a);
        }
        for(int i=0;i<n;i++){
            visited[i]=false;
        }
        DFS(graph,visited,0,-1,lowTime,visitTime,result);
        return result;            
    }
    
    void DFS(ArrayList<Integer>[] graph,boolean visited[],Integer currentNode,Integer parentNode
            ,int[] lowTime,int[] visitTime,List<List<Integer>> result){
        visited[currentNode]=true;
        visitTime[currentNode]=lowTime[currentNode]=time++;
        for(int nhbr:graph[currentNode]){
            if(nhbr==parentNode){continue;}
            else if(!visited[nhbr]){
                DFS(graph,visited,nhbr,currentNode,lowTime,visitTime,result);
                lowTime[currentNode]=Math.min(lowTime[currentNode],lowTime[nhbr]); 
                if(visitTime[currentNode]<lowTime[nhbr]){
                    result.add(Arrays.asList(currentNode,nhbr));
                }
            }else{
               lowTime[currentNode]=Math.min(lowTime[currentNode],lowTime[nhbr]); 
            }
        }
    }
        
}

File: BFSAndDFSTraversal.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;

//1       level 1
//0 3 4   level 2
//4       level 3
//1       level 4
//2 1     level 5
//BFS print level by level
public class BFSAndDFSTraversal{
	
	static void doBFSTraverse(ArrayList<ArrayList<Integer>> matrix,int v,int source,Boolean [] visited){
		System.out.print("BFS traverse");
		Queue<Integer> q=new LinkedList<Integer>();
		q.add(source);
		visited[source]=true;
		while(!q.isEmpty()){
			int u=q.poll();
			System.out.print(u+"-");
			for(int i=0;i<matrix.get(u).size();++i){
				if(visited[matrix.get(u).get(i)]==null || 
					!visited[matrix.get(u).get(i)]){
					q.add(matrix.get(u).get(i));
					visited[matrix.get(u).get(i)]=true;
				}
			}
		}
	}

	
	static void BFSHandleDisconnectedCases(ArrayList<ArrayList<Integer>> matrix,int v){
		Boolean [] visited=new Boolean[v];
		for(int source=0;source<v;++source){
			if(visited[source]==null || visited[source]==false){
			doBFSTraverse(matrix,v,source,visited);
			}
		}
	}

	static void doDFSTraverse(ArrayList<ArrayList<Integer>> matrix,int v,int source,Boolean [] visited){
		System.out.print(source+"-");
		visited[source]=true;
			for(int i=0;i<matrix.get(source).size();++i){
				if(matrix.get(source).size()!=0 &&
				  (visited[matrix.get(source).get(i)]==null || !visited[matrix.get(source).get(i)])){
				doDFSTraverse(matrix,v,matrix.get(source).get(i),visited);
				
			}
		}
	}

	static void DFSHandleDisconnectedCases(ArrayList<ArrayList<Integer>> matrix,int v){
		System.out.print("\nDFS traverse");
		Boolean [] visited=new Boolean[v];
		for(int source=0;source<v;++source){
			if(visited[source]==null || visited[source]==false){
			doDFSTraverse(matrix,v,source,visited);
			}
		}
	}

	public static void main(String args[]){
		int v=4;
		GraphUsingList graphUsingList=new GraphUsingList(v);
		graphUsingList.addEdge(0,1);
		graphUsingList.addEdge(1,2);
		graphUsingList.addEdge(2,0);
		graphUsingList.addEdge(2,3);
		graphUsingList.addEdge(3,3);

		graphUsingList.printMatrix();
		
		ArrayList<ArrayList<Integer>> matrix=graphUsingList.matrix;

		BFSHandleDisconnectedCases(matrix,v);

		DFSHandleDisconnectedCases(matrix,v);

		System.out.println("\nDFS from source 2");
		Boolean [] visited=new Boolean[v];
		doDFSTraverse(matrix,v,2,visited);
		
	}

}

File: GraphUsingMatrix.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
public class GraphUsingMatrix{
	public static Boolean matrix[][];
	public static int v;
	
	public GraphUsingMatrix(int v){
		this.v=v;
		this.matrix=new Boolean[v][v];
	}

	public static void addEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			matrix[i][j]=true;
			matrix[j][i]=true;
		}
	}

	public static void removeEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			matrix[i][j]=true;
			matrix[j][i]=true;
		}
	}
	
	public static Boolean isEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			return matrix[i][j]=true;
		}else{
		return false;
		}
	}
	
	//o(n2)- brute force
	public static void printMatrix(){  
		for(int i=0;i<v;++i){
			for(int j=0;j<v;++j){
			System.out.print((matrix[i][j]!=null&&matrix[i][j]?1:0)+" ");			
			}
			System.out.print("\n");
		}
	}
	
	public static void main(String args[]){
		GraphUsingMatrix graphUsingMatrix=new GraphUsingMatrix(3);
		graphUsingMatrix.addEdge(1,1);
		graphUsingMatrix.printMatrix();
	}

}

File: ShortestPathSourceToDestinationBST.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
public void shortestPath(Integer a, Integer b,List<Integer>[] graph) {
    if (a == null || b == null) return null;
    if (a == b) return null;
        
    Queue<Integer> toVisit = new LinkedList<Integer>();
    HashMap<Integer, Integer> parents = new HashMap<Integer, Integer>();
        
    toVisit.add(a);
    parents.put(a, null);
        
    while (!toVisit.isEmpty()) {
        Integer curr = toVisit.remove();
        if (curr == b) break;
        for (Integer n : curr.children) {
            if (!parents.containsKey(n)) {
                toVisit.add(n);
                parents.put(n, curr);
            }
        }
    }
    if (parents.get(b) == null) return null;
    Integer n = b;
    while (n != null) {
        System.out.print(n+"<-");
        n = parents.get(n);
    }
        
    return ;
}

File: GraphUsingList.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
import java.util.ArrayList;

public class GraphUsingList{
	public static ArrayList<ArrayList<Integer>> matrix;	
	static int v;

	public GraphUsingList(int v){
		this.v=v;
		this.matrix=new ArrayList<> (v);
		for(int i=0;i<v;++i){
			this.matrix.add(new ArrayList<>());
		}
	}

	public static void addEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			if(!matrix.get(i).contains(j)){
				matrix.get(i).add(j);
			}
			if(!matrix.get(j).contains(i)){
				matrix.get(j).add(i);
			}
			
		}
	}

	public static void addDirectedEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			if(!matrix.get(i).contains(j)){
				matrix.get(i).add(j);
			}			
		}
	}
	public static void deleteEdge(int i,int j){
		if(i>=0 && j>=0 && j<v && i<v){
			for(int first=0;first<matrix.get(i).size();++first){
				if(matrix.get(i).get(first)==j){
					matrix.get(i).remove(first);
					break;		
				}
			}
			for(int second=0;second<matrix.get(j).size();++second){
				if(matrix.get(j).get(second)==i){
					matrix.get(j).remove(second);
					break;
				}
			}
		}
	}


	//o(n2)- brute force
	public static void printMatrix(){  
		for(int i=0;i<v;++i){
			System.out.println(matrix.get(i));
		}
	}
	
	public static void main(String args[]){
		GraphUsingList graphUsingList=new GraphUsingList(3);
		graphUsingList.addEdge(0,1);
		graphUsingList.addEdge(1,2);
		graphUsingList.addEdge(1,0);
		graphUsingList.printMatrix();
		graphUsingList.deleteEdge(1,0);
		System.out.println("after deleting");
		graphUsingList.printMatrix();

	}

}

File: FindTheJudge.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
/*
In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.
*/
class Solution {
    public int findJudge(int N, int[][] trust) {
        if(trust.length==0 && N==1){
            return 1;
        }    
        List<List<Integer>> graph=new LinkedList<>();
        List<Integer> possibleJudges=new LinkedList<>();
        Integer count[] =new Integer[N+1];
        for(int i=0;i<N;++i){
            graph.add(new LinkedList<Integer>());
        }
        
        for(int i=0;i<trust.length;++i){
            count[trust[i][1]]=count[trust[i][1]]==null?1:count[trust[i][1]]+1;
            if(count[trust[i][1]]==N-1){possibleJudges.add(trust[i][1]);}
            graph.get(trust[i][0]-1).add(trust[i][1]);
        }
        for(int i=0;i<possibleJudges.size();++i){
            if(graph.get(possibleJudges.get(i)-1).size()==0) return possibleJudges.get(i); 
        }
        return -1;
    }
}

File: Dijkstra.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Dijikstra
public static void main(String[] args){
        int[][] graph= {{0,2,4,0,0,0},  //zero means no edge,+ve value means weight of the edge 
                        {0,0,1,7,0,0},
                        {0,0,0,0,3,0},
                        {0,0,0,0,0,1},
                        {0,0,0,2,0,5},				
                        {0,0,0,0,0,0}};
        Integer[] dist=new Integer[graph.length];
        dist[source]=0;
        PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>(){
                public int compare(Integer ob1,Integer ob2){
                    int d1=	dist[ob1]==null?Integer.MAX_VALUE:dist[ob1];
                    int d2=	dist[ob2]==null?Integer.MAX_VALUE:dist[ob2];
                    return d1-d2;
                }});

        Set<Integer> map=new HashSet<Integer>();
        for(int i=0;i<graph.length;++i){
            map.add(i);
            pq.add(i);			
        }
        while(!pq.isEmpty()){
            int u=pq.peek();
            System.out.print(u);
            map.remove(u);			
            for(int v=0;v<graph.length;++v){
                if(graph[u][v]!=0){
                    dist[v]=Math.min(dist[v]==null? Integer.MAX_VALUE:dist[v],dist[u]+graph[u][v]);					
                }
            }
            int removed=pq.poll();
        }
        System.out.println(dist);
 }


File: AllPathsFromSourceToTarget.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Solution {
    List<List<Integer>> paths=new ArrayList<>();
    boolean visited[] ;
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        if(graph.length==0) return paths;
        visited =new boolean[graph.length];
        int src=0;
        int des=graph.length-1;
        List<Integer> path=new ArrayList<>();
        path.add(src);
        DFS(src,des,graph,path);
        return paths;
    }
    
    void DFS(int currNode,int des,int[][] graph,List<Integer> path){
        visited[currNode]=true;
        if(des==currNode){
            paths.add(new ArrayList<>(path));
        }else{
            for(int neighbour:graph[currNode]){
                if(visited[neighbour]==false){
                    path.add(neighbour);
                    DFS(neighbour,des,graph,path);
                    path.remove(path.size()-1);
                }
            }
        }
        visited[currNode]=false;
    }
}

File: GraphValidTree.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
/*
Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.
*/
class Solution {
    Boolean ans=true;
    public boolean validTree(int n, int[][] edges) {
        List<Integer>[] graph=new ArrayList[n];
        buildGraph(graph,edges);
        boolean[] visited=new boolean[n];
        DFS(graph,0,-1,visited);
        if(ans){
            for(int i=0;i<visited.length;++i){
                if(!visited[i]){
                    return false;
                }
            }
        }
        return ans;
    }
    
    void DFS(List<Integer>[] graph,int currentNode,int parentNode,boolean[] visited){
        visited[currentNode]=true;
        if(ans){
            for(int neighbour:graph[currentNode]){
                if(neighbour==parentNode) continue;
                else if(visited[neighbour]==false){
                    DFS(graph,neighbour,currentNode,visited);
                }else{//Cycle exist
                    ans=false;
                    return;
                }
            }            
        }

    }
    
    void buildGraph(List<Integer>[] graph,int[][] edges){
        for(int i=0;i<graph.length;++i){
            graph[i]=new ArrayList<>();
        }
        for(int[] edge: edges){
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
    }
}

File: FindOrderingOfAlienDictionary.txt
Question Type: TopologicalSorting
DSA Question: Write an algorithm to sort an array.
----------------------
/*
Input: Words: ["ba", "bc", "ac"]
Output: bac

Input: Words: ["cab", "aaa", "aab"]
Output: cab
*/
void printOrderOfAlienDictionary(String[] words){
    Map<Character,Set<Character>> graph=new HashMap<>();
    Map<Character,Integer> inDegree=new HashMap<>();
    for(int i=0;i<words.length-1;++i){
        char[] first=words[i].toCharArray();
        char[] scond=words[i+1].toCharArray();
        for(int j=0;j<Math.min(first.length,scond.length);++i){
             char firstC=first[j];
             char scondC=scond[j];
             if(!graph.containsKey(firstC)){
                graph.put(firstC,new HashSet<Character>());
             } 
             if(!graph.containsKey(scondC)){
                graph.put(scondC,new HashSet<Character>());
             } 
             if(firstC!=scondC){
                graph.get(firstC).add(scondC);
                inDegree.put(scondC.inDegree.getOrDefault(scondC,0)+1);
                break;
             }
        }
    }
    //Do Topological Sorting on the maps
}

File: TopologicalSort.txt
Question Type: TopologicalSorting
DSA Question: Write an algorithm to sort an array.
----------------------
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList;

public class TopologicalSort{

	static void doBFSTraverseTopologicalSort(ArrayList<ArrayList<Integer>> matrix,int v){
		System.out.print("BFS traverse - Topological Sort - Khann Algorithm");
		Integer [] indegree=new Integer [v];
		for(int i=0;i<indegree.length;++i){
			indegree[i]=0;
		}
		for(int i=0;i<indegree.length;++i){
			for(int j=0;j<matrix.get(i).size();++j){
				indegree[matrix.get(i).get(j)]++;	
			}
		}
		Queue<Integer> q=new LinkedList<Integer>();
		for(int i=0;i<v;++i){
			if(indegree[i]==0){
				q.add(i);			
			}
		}

		while(!q.isEmpty()){
			int u=q.poll();
			System.out.print(u+"-> ");
			for(int i=0;i<matrix.get(u).size();++i){
				indegree[matrix.get(u).get(i)]--;
				if(indegree[matrix.get(u).get(i)]==0){
					q.add(matrix.get(u).get(i));
				}
			}
		}
	}

	public static void main(String args[]){
		int v=6;
		GraphUsingList g=new GraphUsingList(v);

 	          g.addDirectedEdge(5, 2); 
      		  g.addDirectedEdge(5, 0); 
      		  g.addDirectedEdge(4, 0); 
      		  g.addDirectedEdge(4, 1); 
      		  g.addDirectedEdge(2, 3); 
      		  g.addDirectedEdge(3, 1);

		g.printMatrix();
		
		ArrayList<ArrayList<Integer>> matrix=g.matrix;

		doBFSTraverseTopologicalSort(matrix,v);
	}

}

File: Maze.txt
Question Type: Graph
DSA Question: Solve a problem using graphs.
----------------------
class Solution {
    boolean isSafe(int[] v,int[][] maze){
        return v[0]>=0 && v[0]<maze.length && 
            v[1]>=0 && v[1]<maze[0].length && maze[v[0]][v[1]]==0;
    }
    
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        Queue<int[]> q=new LinkedList<>();
        boolean[][] visited=new boolean[maze.length][maze[0].length];
        q.add(start);
        int[] x={0,0,1,-1};
        int[] y={1,-1,0,0};
        while(!q.isEmpty()){
            int[] u=q.poll();
            visited[u[0]][u[1]]=true;
            if(destination[0]==u[0]&&destination[1]==u[1]){
                boolean isBlocked=false;
                for(int i=0;i<x.length;++i){
                    int[] m=new int[]{u[0]+x[i],u[1]+y[i]};
                    if(isSafe(m,maze)){
                        if(visited[m[0]][m[1]]==false){
                            return false;
                        }
                    }
                }
                return true;
            }
            for(int i=0;i<x.length;++i){
                int[] v=new int[]{u[0]+x[i],u[1]+y[i]};
                if(isSafe(v,maze) && visited[v[0]][v[1]]!=true){
                    q.add(v);
                }
            }
        }
        return false;
    }
}

File: Maximum Element In Sliding Window.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: Maximum Element In Sliding Window
----------------------
/*
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.
Follow up:
Could you solve it in linear time?
Example:

Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
 */
class Solution {
    //0 1 2// 3 4 5
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans=new int[nums.length-k+1];
        ArrayDeque<Integer> dq=new ArrayDeque<>();
        for(int i=0;i<k;++i){
            while(!dq.isEmpty() && nums[dq.getLast()]<=nums[i]){
                dq.removeLast();
            }
            dq.addLast(i);
        }
        ans[0]=nums[dq.getFirst()];
        for(int i=k;i<nums.length;++i){
            int firstDQ=dq.getFirst();
            while(!dq.isEmpty() && firstDQ<= i-k){
                dq.removeFirst();
                firstDQ=dq.isEmpty()?-1:dq.getFirst();
            }
            while(!dq.isEmpty() && nums[dq.getLast()]<=nums[i]){
                dq.removeLast();
            }
            dq.addLast(i);
            ans[i-k+1]=nums[dq.getFirst()];
        }
        return ans;
    }
}

File: Minimum Window SubString.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: Minimum Window SubString
----------------------
class Pair {
  int l = -1;
  int h = -1;
}

class Solution {
  public String minWindow(String s, String t) {
    if (s == null || t == null || s.length() == 0 || t.length() == 0)
      return "";
    Pair resultIndex = new Pair();
    int charsToCount = t.length();
    HashMap<Character, Integer> map = new HashMap<>();
    for (char c : t.toCharArray()) {
      map.put(c, map.getOrDefault(c, 0) + 1);
    }
    int l = 0;
    for (int h = 0; h < s.length(); ++h) {
      if (charsToCount > 0) {
        if (map.containsKey(s.charAt(h))) {
          int countPending = map.get(s.charAt(h));
          map.put(s.charAt(h), map.get(s.charAt(h)) - 1);
          if (countPending > 0) {
            charsToCount--;
            // map.put(s.charAt(h),map.get(s.charAt(h))-1);
          }
        }
      }
      while (charsToCount == 0) {
        char cl = s.charAt(l);
        if (map.containsKey(cl)) {
          map.put(cl, map.get(cl) + 1);
          int countPending = map.get(cl);
          if (countPending > 0) {

            charsToCount++;
          }
        }
        if ((resultIndex.h == -1 && resultIndex.l == -1) || resultIndex.h - resultIndex.l > h - l) {
          resultIndex.h = h;
          resultIndex.l = l;
        }

        ++l;
      }
    }

    if (resultIndex.l == -1) {
      return "";
    }

    return s.substring(resultIndex.l, resultIndex.h + 1);
  }
}


class Solution {
    public String minWindow(String txt, String pat) {
        int textLen=txt.length();
        int patLen=pat.length();
        int[] needToFind=new int[256];
        for(int i=0;i<patLen;++i){
            needToFind[pat.charAt(i)]++;
        }
        int[] hasFound=new int[256];
        int minWindLen=Integer.MAX_VALUE;
        int minWinBegin=0;
        int minWinEnd=0;
        int count=0;
        for(int begin=0,end=0;end<textLen;end++){
            if(needToFind[txt.charAt(end)]==0) continue;
            hasFound[txt.charAt(end)]++;
            if(hasFound[txt.charAt(end)]<=needToFind[txt.charAt(end)]){
                ++count;
            }
            if(count==patLen){
                while(needToFind[txt.charAt(begin)]==0 || 
                      hasFound[txt.charAt(begin)]>needToFind[txt.charAt(begin)]){
                    if(hasFound[txt.charAt(begin)]>needToFind[txt.charAt(begin)]){
                      hasFound[txt.charAt(begin)]--;  
                    }
                    begin++;
                }
                int windowLen = end - begin +1;
                if(windowLen<minWindLen){
                    minWinBegin=begin;
                    minWinEnd=end;
                    minWindLen=windowLen;
                }
            }
        }
        return  count==patLen?txt.substring(minWinBegin,minWinEnd+1):"";
    }
}

class Solution {
    public String minWindow(String s, String t) {
        Map<Character,Integer> dict=new HashMap<>();
        for(char chr:t.toCharArray()){
            dict.put(chr,dict.getOrDefault(chr,0)+1);
        }
        Map<Character,Integer> map=new HashMap<>();
        int l=0;
        int matchCount=0;
        String ans="";
        int matchSubStringLength=Integer.MAX_VALUE;
        for(int h=0;h<s.length();++h){
            char currChar=s.charAt(h);
            map.put(currChar,map.getOrDefault(currChar,0)+1);
            if(dict.containsKey(currChar) && map.get(currChar)<=dict.get(currChar)){
                matchCount++;
            }
            while(matchCount==t.length()){
                if(matchCount==t.length() && (h-l+1)<matchSubStringLength){
                    ans=s.substring(l,h+1);
                    matchSubStringLength=ans.length();
                }
                char charAtL=s.charAt(l);
                if(map.containsKey(charAtL)){
                    if(dict.containsKey(charAtL) && map.get(charAtL)<=dict.get(charAtL)){
                        --matchCount;                        
                    }
                    map.put(charAtL,map.get(charAtL)-1);
                    if(map.get(charAtL)==0){
                        map.remove(charAtL);
                    }
                }
                ++l;
                while(l<s.length() && !dict.containsKey(s.charAt(l))  && l<h){
                    ++l;
                }
            }
        }
        return ans;
    }
}


File: MinWindowWithSumOrGreater.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: MinWindowWithSumOrGreater
----------------------
class MinSizeSubArraySum {
    public static int findMinSubArray(int S, int[] arr) {
      int wSize=Integer.MAX_VALUE;
      int l=0;
      int sum=0;
      for(int h=0;h<arr.length;++h){
        sum=sum+arr[h];
        while(sum>=S){
            int winL=h-l+1;
            wSize=Math.min(wSize,winL);
            sum=sum-arr[l];
            l++;
        }
      }
      return wSize;
    }
  }

File: LongestSubStringWithAtOnlyKDistictChacaters.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: LongestSubStringWithAtOnlyKDistictChacaters
----------------------
//araaci       1
class LongestSubstringKDistinct {
    public static int findLength(String str, int k) {
      int count=0;
      int l=0;
      int winM=0;  
      HashMap<Character,Integer> map=new HashMap<>();
  
      for(int h=0;h<str.length();++h){
        Character curr=str.charAt(h);
        if(map.containsKey(curr)){
          map.put(curr,map.get(curr)+1);
        }
        else{
          ++count;
            map.put(curr,1);
          while(map.size()>k && l<str.length()){
            char temp=str.charAt(l);
            map.put(temp,map.getOrDefault(temp,0)-1);
            if(map.get(temp)<=0){
              map.remove(temp);
            }
            l++;
          }
        }
        winM=Math.max(winM,h-l+1);
      }
      return winM;
    }
  }

File: LongestSubStringWithoutRepeatingCharacter.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: LongestSubStringWithoutRepeatingCharacter
----------------------
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==0) return 0;
        HashMap<Character,Integer> map=new HashMap<>();
        int l=0;
        int ans=-1;
        int h;
        for(h=0;h<s.length();++h){
            char currChar=s.charAt(h);
            if(map.containsKey(currChar)){
                int oldIndex=map.get(currChar);
                if(oldIndex>=l){
                    ans=Math.max(ans,h-1-l+1);
                    l=oldIndex+1;
                }
            }
            map.put(currChar,h);
        }
        return Math.max(h-1-l+1,ans);
    }   
        
}

public static int findLength(String str) {
    int l=0;
    int winM=0;
    HashMap<Character,Integer> map=new HashMap<>();
    for(int h=0;h<str.length();++h){
      Character curr=str.charAt(h);
      if(!map.containsKey(curr)){
        map.put(curr,h);
        winM=Math.max(winM,h-l+1);
      }else{
        l=Math.max(l,map.get(curr)+1);
        map.put(curr,h);
        winM=Math.max(winM,h-l+1);
      }
    }
    return winM;
  }

  public static int findLength(char[] arr) {
    int max=0; 
    int l=0;
    HashMap<Character,Integer> map=new HashMap<>();
    for(int h=0;h<arr.length;++h){
       if(!map.containsKey(arr[h])){
           map.put(arr[h],h);
       }else{
           l=Math.max(l,map.get(arr[h]))+1;
           map.put(arr[h],h);
       }
       max=Math.max(max,h-l+1);
    }
    return max;
}


File: FruitTwoBasketMaxCount.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: FruitTwoBasketMaxCount
----------------------
public static int findLength(char[] arr) {
    HashMap<Character,Integer> map=new HashMap<>();
       int l=0;
    int max=0;
       for(int h=0;h<arr.length;++h){
             if(map.keySet().size()<2){
               map.put(arr[h],map.getOrDefault(arr[h],0)+1);
             }
             else if(map.keySet().size()==2 && !map.containsKey(arr[h])){
               map.remove(arr[l++]);
                map.put(arr[h],1);
             }else if(map.containsKey(arr[h])){
           map.put(arr[h],map.getOrDefault(arr[h],0)+1);
       }
       int temp=0;
       for(int v:map.values()){
           temp=temp+v;
       }
       max=Math.max(max,temp);
       }
      return max;
 }



File: MinWindowWithExactSum.txt
Question Type: SlidingWindow
DSA Question: DSA problem related to: MinWindowWithExactSum
----------------------
class MinSizeSubArraySum {
    public static int findMinSubArray(int S, int[] arr) {
      int wSize=Integer.MAX_VALUE;
      int l=0;
      int sum=0;
      for(int h=0;h<arr.length;++h){
        sum=sum+arr[h];
        int winL=h-l+1;
        if(sum==S){
          wSize=Math.min(wSize,winL);
          sum=sum-arr[l];
          l++;
        }else if(sum>S){
          while(sum>S){
            sum=sum-arr[l];
            l++;
          }
          if(sum==S){
            winL=h-l+1;
            wSize=Math.min(wSize,winL);
            sum=sum-arr[l];
            l++;
          }
        }
      }
      return wSize;
    }

File: MinMeetingRooms.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: MinMeetingRooms
----------------------
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals.length==0) return 0;
        PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>(){
           public int compare(Integer o1,Integer o2){
               return o1-o2; 
           }
        });
        Arrays.sort(intervals,new Comparator<int[]>(){
           public int compare(int[] o1,int[] o2){
               return o1[0]-o2[0]; 
           }
        });
        pq.add(intervals[0][1]);
        for(int i=1;i<intervals.length;++i){
            if(pq.peek()<=intervals[i][0]){
                pq.poll();
            }
            pq.add(intervals[i][1]);
        }
        return pq.size();
    }
}

File: MergeIntervals.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: MergeIntervals
----------------------
//Given a collection of intervals, merge all overlapping intervals.
class PairComparator implements Comparator<int[]>{ 
    public int compare(int[] p1, int[] p2) { 
        return p1[0]-p2[0];
    } 
} 
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length==0) return intervals;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] ob1,int[] ob2){
                return ob1[0]-ob2[0];
            }
        });
        LinkedList<int[]> list=new LinkedList<>();
        list.add(intervals[0]);
        for(int i=1;i<intervals.length;++i){
            if(list.get(list.size()-1)[1]>=intervals[i][0]){
                list.get(list.size()-1)[1]=Math.max(intervals[i][1],list.get(list.size()-1)[1]);
            }else{
                list.add(intervals[i]);    
            }
        }
        return list.toArray(new int[list.size()][]);
    }
}

File: CanPersonAttenndAllMeetings.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: CanPersonAttenndAllMeetings
----------------------
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        if(intervals.length==0) return true;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int ob1[],int ob2[]){
                return ob1[0]-ob2[0];
            }
        });
         PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer ob1,Integer ob2){
                return ob1-ob2;
            } 
         });
        pq.add(intervals[0][1]);
        for(int i=1;i<intervals.length;++i){
            if(pq.peek()>intervals[i][0]) {return false;}
            else{
                pq.poll(); pq.add(intervals[i][1]);
            }
        }
        return true;
    }
}

File: BoatCountToSavePeople.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: BoatCountToSavePeople
----------------------
/*
The i-th person has weight people[i], and each boat can carry a maximum weight of limit.

Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.

Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)

 */
class Solution {
    public int numRescueBoats(int[] arr, int limit) {
        Arrays.sort(arr);
        int l=0,h=arr.length-1;
        int count=0;
        while(l<=h){
            ++count;
            if(arr[l]+arr[h]<=limit){
                ++l;
            }
            --h;
        }
        return count;
    }
}

File: MeetingRoomsII.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: MeetingRoomsII
----------------------
/*
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.
*/
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals.length==0) return 0;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int [] b){
                return a[0]-b[0];
            }
        });
        PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer a,Integer  b){
                return intervals[a][1]-intervals[b][1];
            }            
        });
        pq.add(0);
        for(int i=1;i<intervals.length;++i){
            if(intervals[pq.peek()][1]<=intervals[i][0]){
                pq.poll();
            } 
            pq.add(i);
        }
        
        return pq.size();
    }
}


File: JumpGame.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: JumpGame
----------------------
/*
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.
*/
class Solution {
    Boolean result[]=null;
    public boolean canJump(int[] nums) {
        result=new Boolean[nums.length+1];
        return helper(nums,0);
    }
    
    boolean helper(int[] nums,int i){
        if(i==nums.length-1) return true;
        if(result[i]!=null) return result[i];
        for(int j=1;j<=nums[i];++j){
            if(helper(nums,i+j)) return result[i]=true;
        }
        return result[i]=false;
    }
}

class Solution {
    boolean memo[];
    public boolean canJump(int[] nums) {
        memo=new boolean[nums.length];
        memo[nums.length-1]=true;
        for(int i=nums.length-2;i>=0;--i){
            for(int j=1;j<=nums[i];++j){
                if(i+j<nums.length && memo[i+j]==true){
                    memo[i]=true;
                    break;
                }
            }
        }
        return memo[0];
    }
}

class Solution {
    public boolean canJump(int[] nums) {
        int lastGood=nums.length-1;
        for(int i=nums.length-1;i>=0;--i){
            if(i+nums[i]>=lastGood){
                lastGood=i;
            }    
        }
        return lastGood==0;
    }
}

class Solution {   //Jump Games2              
    public int jump(int[] nums) {
        int jump=0;
        int maxPos=0;
        int nextIndex=0;
        for(int i=0;i<nums.length-1;++i){
            maxPos=Math.max(maxPos,i+nums[i]);
            if(i==nextIndex){
                nextIndex=maxPos;
                ++jump;
            }
        }
        return jump;
    }
}

File: BestTimeToSleep.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: BestTimeToSleep
----------------------
import java.util.*;
class Solution {
    public int solution(String S) {
        String[] strs=S.split("\n");
        HashMap<String,Integer> priority=new HashMap<>();
        priority.put("Sun",7);
        priority.put("Sat",6);
        priority.put("Fri",5);
        priority.put("Thu",4);
        priority.put("Wed",3);
        priority.put("Tue",2);
        priority.put("Mon",1);
        Arrays.sort(strs,new Comparator<String>(){
            public int compare(String ob1,String ob2){
                String[] s1=ob1.split(" ");
                String[] s2=ob2.split(" ");
                if(priority.get(s1[0])==priority.get(s2[0])){
                    return getMin(s1[1].split("-")[0])-getMin(s2[1].split("-")[0]);
                }
                return priority.get(s1[0])-priority.get(s2[0]);
            }
        });
        int maxBreak=getMin(strs[0].split(" ")[1].split("-")[0]);
        for(int i=0;i<strs.length-1;++i){
            int first=getMin(strs[i].split(" ")[1].split("-")[1]);
            int secound=getMin(strs[i+1].split(" ")[1].split("-")[0]);
            int curr=0;
            if(strs[i].split(" ")[0].equals(strs[i+1].split(" ")[0])){
                curr=secound-first;
            }else{
                curr=getMin("24:00")-first+secound;
            }
            maxBreak=Math.max(maxBreak,curr);
        }
        maxBreak=Math.max(maxBreak,getMin("24:00")-getMin(strs[strs.length-1].split(" ")[1].split("-")[1]));
        return maxBreak;
    }
    
    int getMin(String str){
        String[] arr=str.split(":");
        int min=Integer.parseInt(arr[0])*60;
        min=min+Integer.parseInt(arr[1]);
        return min;
    }
}

File: TrainPlatormCount.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: TrainPlatormCount
----------------------
int platformCount(int[][] rail){
    Arrays.sort(rail,new Comparator<int[]>(){
    public int compare(int[] ob1,int[] ob2){
        return ob1[0]-ob2[0];
    }
     });
     PriorityQueue<int[]> pq=new PriorityQueue<>(new Comparator<int[]>(){
    public int compare(int[] ob1,int[] ob2){
        return ob1[1]-ob2[1];
    }	
     });
     pq.add(rail[0]);
     for(int i=1;i<rail.length;++i){
    if(pq.peek()[1]>rail[i][0]){
        pq.add(rail[i]);
    }else{
        int[] poll=pq.poll();
        pq.add(rail[i]);
    }
     }
     return pq.size();
} 

File: CountNumberOfTowerToCoverHouses.txt
Question Type: GreedyAlgorithm
DSA Question: DSA problem related to: CountNumberOfTowerToCoverHouses
----------------------
int numberOfTowers(int[] houses,int range){
    int count=1;
    int lastLoc=houses[0]+range;
    for(int i=1;i<houses.length;++i){
     if(Math.abs(houses[i]-lastLoc)>range){
         ++count;
         lastLoc=houses[i]+range;
     }
    }
    return count;
 }

File: questions.txt
Question Type: TODO
DSA Question: DSA problem related to: questions
----------------------
why streams
connection pool
data strucutre for mySql,mongodb
tranactional
difference between rest controller and controlller
proxy setup
cache setup
timeout setup in java
cassandra vs mongoDB
normalization and denormalization-serialID
mySql to cassandra shifting
linkedlist vs arraylist
jdbc classFor
Auth token
microservices
query in mongoDB
how jobs get data from rabbitMQ
runnable interface
customer centric suggestion
cyclic barrier
circuit breaker

AWS
ORM-hibernate
how jpa connects to db
how to add multiple database support
design pattern
DATA EXPORT
LOCKS
collection framework- when to choose set and list
reverse a list using recursion
cycle detection
bubble sort
example of design pattens in Spring
check if string is rotation of other string or not
how spring security works
WHERE INDEXES INFO is stored
how to limit the search totop 100 out of 10000 on db side pagination
how to handle lock on db side,and jump to next available
A server can have how many consecutive read write requests
where your server is hosted(A)
AnyThing you have done from your side - Customer obsession(A)
Count of good nodes(A)
find count of a number in a array(A)
how to get top 100 result based on time.How to optimize db queries
how to do consistent hashing using userID

Function Overloading which funcion will be clled

Generics

Functional Programming
List<Employee> filterEmployees(List<Employee> employees,Set<String> deignations){
	//return employees.stream().filter(emp->deignations.contains(emp.getDesignation()).collect(Collectors.toList());
	return employees.stream().filter(Employee::getStatus).collect(Collectors.toList());
}
Functional Interface
lambda perdicate filter how indetify
Default Method

Method Reference

Immutable

class Employee{
	final Employee emp;
	Employee(){
		emp=new Employee();
	}
	
	Employee getEmployee(){
		return emp;
	}
	Set
}

? 

TypeEraser

Employee emp1,emp2,emp3;
@qualifer

@Component
class c{
	@
	ThirdParty reference;
} 

CrossOrigin

class ThridParty

@Confiuration
@AutoConfiguration

@preDestroy

@postConstruct


i1 i2 getName()  getI1()  getI2()

public sttic void getName(int

List<String>  

public string getname(){
	try{
		return "try";
	}catch(Exception e){
		return "catch";
	}catch(){

	}
	finally(){
		return "finally";
	}
	
}



@PostMapping("/createAccount/1")
List<Employee> createAccount(@RequestBody Employye emp,@Required @PathVaribale id){
	employeeService.save(emp);
}

/createAccount?id="1"
10 Emp,id,
1-
""All

Name marks
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
String name="Arun Bhati";
" "  dup  reverse

ithbnura

String getCustomizeString(String str){
	char[] chars=str.toCharArray();
	chars[] newArray=reverse(removeDuplicatesAndEmptyCharsUpper(chars));
	StringBuilder s=getString(newArray);
	return s.toString();
}

char[] removeDuplicatesAndEmptyCharsUpper(char[] chars){
	StringBuilder s=new StringBuilder();
	HashSet<Charcater> set=new HashSet<>();
	for(int i=0;i<chars.lrngth;++i){
		if(chars[i]=' '|| set.contains(chrs[i]) continue;
		if(chars[i]>='A' && chars[i]<='Z'){
			chars[i]=chars[i]-'A'+'a';
		}
		set.add(chars[i]);
		s.append(chars[i]);
	}
	return s.toString().toCharArray();
}

char[] reverse(char[] arr){
	int l=0,h=arr.length-1;
	while(l<=h){
		char temp=arr[l];
		arr[l]=arr[h];
		arr[h]=temp;
		++l;
		--h;
	}
	return arr;
}


Difference between array and linked list, under which situation would u choose one over the other

3 largest element in MYSQl

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
class DNode{
	String key;
	String value;
	DNode prev;
	DNode next;

	public DNode(){}
	public DNode(String key,String value){
		this.key=key;
		this.value=value;
	}
}

class LRU{
	int size=0;
	int limit;
	        //key   //node
	Hashmap<String,DNode> map;
	DNode head=new DNode(),tail=new DNode();
	public LRU(int limit){
		map=new HashMap<>();
		head.next=tail;
		tail.prev=head;
        this.limit=limit;
	}

	String get(String key){
		if(!map.contains(key)) {
			String data=dataService.fetchData(key);
			return insert(key,data);
		}
		DNode temp=map.get(key);
		moveToHead(temp);
		return temp.value;
	}

	void moveToHead(DNode temp){
		node.next=temp;
		node.prev=head;
		head.next=node;
		map.put(key,node);
	}

	String insert(String key,String value){
		if(map.contains(key)) return;
		if(size==limit){
			delete();
		}
		DNode node=new DNode(key,value);
		DNode temp=head.next;
		moveToHead(temp);
		++size;
		return value;
	}
	
	void delete(){
		Node temp=tail.prev;
		Node prev=temp.prev;
		prev.next=tail;
		tail.prev=prev;
		map.remove(tempkey);
		--size;
	}
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

3. Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1.


Element       NGE
   4      -->   5
   5      -->   25
   2      -->   25
   25     -->   -1
   11     -->   19
   19     -->   -1
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
A 2-D grid consisting of some blocked (represented as '#') and some unblocked (represented as '.') cells is given. The starting position of a pointer is in the top-left corner of the grid. It is guaranteed that the starting position is in an unblocked cell. It is also guaranteed that the bottom-right cell is unblocked. Each cell of the grid is connected with its right, left, top, and bottom cells (if those cells exist). It takes 1 second for a pointer to move from a cell to its adjacent cell. If the pointer can reach the bottom-right corner of the grid within k seconds, return the string 'Yes'. Otherwise, return the string 'No'. 

 

Example

rows = 3

grid = ['..##', '#.##', '#...']

maxTime = 5

. . # #
# . # #
# . . .
It will take the pointer 5 seconds to reach the bottom right corner. As long as k <= 5, return 'Yes'.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Vechile
-------
vechileNumber
type
passCount

Jobs
-----
id
DateTime LastRunDate

Ticket
-------
Integer id
String vechileNumber
String attendentId
DateTime enterTime
DateTime exitTime
Integer SparkingLotId
Double price

Attendents
--------
id
Name
Address

parkingLot
----------
Integer id
address
name


vechileType
----------
TWO_WHEELER
FOUR_WHEELER
BIG_TRUCK
ELECTRIC_VECHILE


ticketRepository.getTickets(by vechileNumber,btween dates).filter(exutTime-enter>=30).count();


Heap working 
KMP working



{1,2-5,3,4,-1,2}

int maximumSum(int[] arr){
	int[] memo=new int[arr.length];
	memo[0]=arr[0];
	int maxSum=memo[0];
	for(int i=1;i<arr.length;++i){
		memo[i]=Math.max(arr[i],arr[i]+memo[i-1]);
		maxSum=Math.max(maxSum.memo[i]);
	}
	return maxSum;
}

//  {1,2-5,3,4,-1,2}
int i=0  1  2  3   4  5  6
memo {1  3  -2  3  7  6   }
maxSm=1  3  3   3  7  7


//Linked list 

	5 7 9 2 3 6->  5 9 3  7 2 6
	
	Node rearrangeListOddEven(Node head){
		if(head==null) return null;
		Node dummyO=new Node(),dummyE=new Node();
		Node currO=dummyO,prevO=null,currE=dummyE;
		Node curr=head;
		boolean isOdd=true;
		while(curr!=null){
			if(isOdd){
			   prev=currO;
			   currO.next=curr;
			   currO=currO.next;
			}else{
			   currE.next=curr;
			   currE=currE.next;
			}
			isOdd=!isOdd;
			curr=curr.next;
		}
		prev.next=dummyE.next;
		dummyE=null;
		return dummyO.next;
	}

	5 7 9 2 3 6
	         curr=5  7  9  2  3  6
	isOdd=        t  f  t  f  t  f
	currO=   New ,5     9     3
	currE=   new    ,7     2     6

File: TODO.txt
Question Type: TODO
DSA Question: DSA problem related to: TODO
----------------------
SystemDesign Problem statement in detail to refer:
-------------------------------------------------
Practice class diagrams
OOPs concept for class diagrams

JWT
consistent hashing
Indexing
Inverse Indexing
Microservices and communication between them
notification service
Messaging queue
time stamp- how to maintain sequencing as clint time stamp may be unreliable
Class diagram for chess,conv
recommendation system

– Explain design patterns used so far.
– How is code review done.
– How is design review done.
What type of cache do you use in your projects/SYstem.
Using generics
How will you resolved the concurrency issue when 2 customers try to book same seat.

Complete design of my project HLD, LLD, UI, DB etc.

Any big enhancement suggested by you to make your code better.
A running stream of numbers is coming you need to keep track of top K elements
Heap interface and using that implement min heap or max heap. And also write the heapify code
Clone a Binary Tree with Random Pointers

Program for Best Fit algorithm in Memory Management
Design a deck of card (only the model classes)
NoSQL vs a SQL database (when to choose which)

Design Promo Code API taking Amazon’s customer traffic into picture (HLD and LLD was discussed – including in memory databases)
Variation of Topological Sorting : You have been given a set of inter-dependent tasks along with the time taken to execute them. We have more number of parallel processors available than the number of tasks given. There could be multiple starting tasks. There could also be cyclic dependencies. Calculate the minimum time required to complete all the task. Complete end to end production ready code was expected.

Design a vending machine with following functionalities

Three types of Users : User, Operator, Admin
User can select and buy multiple items at a time. Money can be inputted multiple times (you will get the item if there is a time gap > 30 secs). He can also do window shopping (see only the prices of items and buy nothing)
Operator can load the items and mark the items as expired if needed, gets notified if a product goes out of stock.
Admin can own multiple vending machines, he should have a analytics report of the items purchased in a month. He can also change the prices directly and it should reflect in all the vending machines which he owns.
Exception handling in all the edge cases

Design a Whatsapp like service.
Given the high level design first, then dived deeper explaining load balancing, splitting into microservies and communication between them, notification service, message queuing, database sharding, etc.
Asked me how to maintain the sequencing of messages, since client’s time-stamp would be unreliable.

Class diagram for a standalone Chess board game.
Discussion on the my design like, why this class/relationship is needed, why this method is in this class rather than that, etc. Convinced him for few of them, giving proper reasons, and made changes in the design for other few.
Pseudo code for all the possible moves of any piece.

Design:
Do integration for Splitwise app with Amazon Pay (or Paytm)
1) where a person can pay to another person and money directly gets deposited into other person’s bank account.
2) A person can also send reminder to another person for owning money.

Design a job scheduler, scalability, fault tolerance, high availability, how scheduler picks up job,
how will you take care where one job can run for 30 min and one for 30 hour, how will you distribute jobs on servers.
Based on frequency & time how will you execute them ?
How will you notify back the user about start/stop or completion of a job ?
How will your system know if a job is killed / terminated due to unknown reasons ?


.........
Behavioural
-----------
Job Description

Any task/project which was designed and implemented in less time but had a great impact on the production/Business Side.

http://kraftshala.com/how-to-raise-the-bar-in-the-amazon-interview/


........
Google :-
........
Given a result of a competition among all the students of a class, write a program to make students stand in a order such that every student must have lost to the student in his/her immediate left and won against the student to his/her immediate right.
https://www.geeksforgeeks.org/anagram-substring-search-search-permutations/
https://www.geeksforgeeks.org/the-celebrity-problem/
B trees and B+ Trees
AVL tree
hamilton path
Rat in a maze
sudoku
knights tour problem
hamiltonian cycle
m coloring
Robber
np hard problem
Best-First Search.
travelling salesman problem
Reliability design dp
Branch and Bound
QuickSort LinkedList
Row-Major and Column-Major

File: DSA_ODO.txt
Question Type: TODO
DSA Question: DSA problem related to: DSA_ODO
----------------------
AVL delete a node
longestPalindromincSubString
longestPalindromicSubSequence
longestCommonSubSequence
longestConsecutiveSequence
longestNonRepeatingSubString
Critical Connections in a Network

File: Tech_TODO.txt
Question Type: TODO
DSA Question: DSA problem related to: Tech_TODO
----------------------
Zookeeper
linux 
PostgreSQL 
AWS
kafka 
ELK
loadbalancer
cache
Proxy
Kubernetes

File: TrieImplementationRecursive.txt
Question Type: Trie
DSA Question: DSA problem related to: TrieImplementationRecursive
----------------------
class TrieNode{
    public Map<Character,TrieNode> map;
    public boolean isEnd;
    
    public TrieNode() {
        map=new HashMap<>();
    }
}
class Trie {
    TrieNode trieNode;
    public Trie() {
        trieNode=new TrieNode();
    }
    
    public void insert(String word) {
        insertCharacter(trieNode,word,0);
    }
    
    void insertCharacter(TrieNode dict,String word,int i){
        if(word.length()-1==i){
            if(dict.map.containsKey(word.charAt(i))){
                dict.map.get(word.charAt(i)).isEnd=true;
            }else{
                TrieNode trieNode=new TrieNode();
                trieNode.isEnd=true;
                dict.map.put(word.charAt(i),trieNode);
            }
            return;
        }else{
            if(dict.map.containsKey(word.charAt(i))){
                insertCharacter(dict.map.get(word.charAt(i)),word,i+1);
            }else{
                TrieNode trieNode=new TrieNode();
                dict.map.put(word.charAt(i),trieNode);
                insertCharacter(dict.map.get(word.charAt(i)),word,i+1);
            }
        }
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        return searchChar(trieNode,word,0);
    }
    
    boolean searchChar(TrieNode dict,String word,int i){
        if(word.length()-1==i){
          if(dict.map.containsKey(word.charAt(i)) && dict.map.get(word.charAt(i)).isEnd) return true; 
          return false;  
        } 
        if(dict.map.containsKey(word.charAt(i))){
            return searchChar(dict.map.get(word.charAt(i)),word,i+1);
        }
        return false;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return searchPrefix(trieNode,prefix,0);
    }
    
    boolean searchPrefix(TrieNode dict,String word,int i){
        if(word.length()-1==i){
          if(dict.map.containsKey(word.charAt(i))) return true; 
          return false;  
        } 
        if(dict.map.containsKey(word.charAt(i))){
            return searchPrefix(dict.map.get(word.charAt(i)),word,i+1);
        }
        return false;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */


File: TrieMapSumPairs.txt
Question Type: Trie
DSA Question: DSA problem related to: TrieMapSumPairs
----------------------
class TrieNode{
    public Map<Character,TrieNode> map;
    public int sum;
    
    public TrieNode() {
        map=new HashMap<>();
    }
}

class MapSum {
    TrieNode trieNode;
    Map<String,Integer> map;
    public MapSum() {
        trieNode=new TrieNode();
        map=new HashMap<>();
    }
    
    public void insert(String key, int val) {
        int existingValue=map.getOrDefault(key,0);
        map.put(key,val);
        insertCharacter(trieNode,key,0,val,existingValue);
    }
    
    void insertCharacter(TrieNode dict,String word,int i,int val,int existingValue){
        if(word.length()-1==i){
            if(dict.map.containsKey(word.charAt(i))){
                dict.map.get(word.charAt(i)).sum=dict.map.get(word.charAt(i)).sum + val - existingValue; 
            }else{
                TrieNode trieNode=new TrieNode();
                trieNode.sum=val;
                dict.map.put(word.charAt(i),trieNode);
            }
            return;
        }else{
            if(dict.map.containsKey(word.charAt(i))){
                dict.map.get(word.charAt(i)).sum=dict.map.get(word.charAt(i)).sum+val- existingValue;
                insertCharacter(dict.map.get(word.charAt(i)),word,i+1,val,existingValue);
            }else{
                TrieNode trieNode=new TrieNode();
                trieNode.sum=val;
                dict.map.put(word.charAt(i),trieNode);
                insertCharacter(dict.map.get(word.charAt(i)),word,i+1,val,existingValue);
            }
        }
    }
    
    public int sum(String prefix) {
        return searchChar(trieNode,prefix,0);
    }
    
    int searchChar(TrieNode dict,String word,int i){
        if(word.length()-1==i){
          if(dict.map.containsKey(word.charAt(i))) {
              return dict.map.get(word.charAt(i)).sum;
          }
        } 
        if(dict.map.containsKey(word.charAt(i))){
            return searchChar(dict.map.get(word.charAt(i)),word,i+1);
        }
        return 0;
    }
}


File: WordBreak.txt
Question Type: Trie
DSA Question: DSA problem related to: WordBreak
----------------------
class Solution {
    HashMap<String,Boolean> map=new HashMap<>();
    public boolean wordBreak(String s, List<String> words) {
        TNode node=new TNode();
        for(String word:words){
            insert(node,word);            
        }
        return searchHelper(node,s);
    }
    
    public boolean searchHelper(TNode node,String s){
       if(map.containsKey(s)) return map.get(s);
       if(s.length()==0) return true;
       for(int i=1;i<=s.length();++i){
           if(search(node,s.substring(0,i)) && searchHelper(node,s.substring(i,s.length()))){
               map.put(s,true);
               return true;
           } 
       }
       map.put(s,false);
       return false; 
    }
    
    public boolean search(TNode node,String s){
        if(map.containsKey(s)) return map.get(s);
        if(s.length()==0) return false;
        int i=0;
        while(i<s.length()){
            if(!node.dic.containsKey(s.charAt(i))) return false;
            node=node.dic.get(s.charAt(i));
            i++;
        }
        map.put(s,node.isEnd);
        return node.isEnd;
    }
    
    public void insert(TNode node,String word){
        int i=0;
        if(word.length()==0) return;
        while(i<word.length()){
            if(!node.dic.containsKey(word.charAt(i))){
                node.dic.put(word.charAt(i),new TNode());
            }
            node=node.dic.get(word.charAt(i));
            i++;
        }
        node.isEnd=true;
    }
}

class TNode{
    public boolean isEnd;
    public Map<Character,TNode> dic=new HashMap<>();
}

File: ReplaceWords.txt
Question Type: Trie
DSA Question: DSA problem related to: ReplaceWords
----------------------
/*
In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word successor. For example, when the root "an" is followed by the successor word "other", we can form a new word "another".
Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. If a successor can be replaced by more than one root, replace it with the root that has the shortest length.
Return the sentence after the replacement.
Example 1:
Input: dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
Output: "the cat was rat by the bat"
*/
class TrieNode{
    Map<Character,TrieNode> map;
    boolean isEnd;
    TrieNode(){
        map=new HashMap<>();
    }
}
class Solution {
    public String replaceWords(List<String> dictionary, String sentence) {
        TrieNode trie=new TrieNode();
        for(String word:dictionary){
            insertWord(trie,word,0);
        }
        String[] arr=sentence.split(" ");
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<arr.length;++i){
            String prefix=searchHelper(trie,arr[i]);
            if(prefix.length()!=0){
                sb.append(prefix+" ");
            }else{
                sb.append(arr[i]+" ");
            }
        }
        return sb.toString().trim();
        
    }
    String searchHelper(TrieNode dict,String word){
        int index=searchChar(dict,word);
        return word.substring(0,index);
    }
    
    int searchChar(TrieNode dict,String word){
        TrieNode curr=dict;
        int i=0;
        while(i<word.length()){
            if(!curr.map.containsKey(word.charAt(i))){
                return 0;
            }else{
                if(curr.map.get(word.charAt(i)).isEnd){
                    return i+1;
                }
                curr=curr.map.get(word.charAt(i));
            }
            ++i;
        }
        return 0;
    }
    
    private void insertWord(TrieNode dict,String word,int i){
        if(word.length()-1==i){
            if(!dict.map.containsKey(word.charAt(i))){
                TrieNode trieNode=new TrieNode();
                trieNode.isEnd=true;
                dict.map.put(word.charAt(i),trieNode);
            }else{
                dict.map.get(word.charAt(i)).isEnd=true;
            }
            return;
        }else{
            if(dict.map.containsKey(word.charAt(i))){
                insertWord(dict.map.get(word.charAt(i)),word,i+1);
            }else{
                TrieNode trieNode=new TrieNode();
                dict.map.put(word.charAt(i),trieNode);
                insertWord(dict.map.get(word.charAt(i)),word,i+1);
            }
        }        
    }
}


File: Trie.txt
Question Type: Trie
DSA Question: DSA problem related to: Trie
----------------------
public boolean search(TNode node,String s){
    if(s.length()==0) return false;
    int i=0;
    while(i<s.length()){
        if(!node.dic.containsKey(s.charAt(i))) return false;
        node=node.dic.get(s.charAt(i));
        i++;
    }
    return node.isEnd;
}
    
public void insert(TNode node,String word){
    int i=0;
    if(word.length()==0) return;
    while(i<word.length()){
        node.dic.put(word.charAt(i),new TNode());
        node=node.dic.get(word.charAt(i));
        i++;
    }
    node.isEnd=true;
}

class TNode{
    public boolean isEnd;
    public Map<Character,TNode> dic=new HashMap<>();
}

File: MinHeap.txt
Question Type: Heap
DSA Question: DSA problem related to: MinHeap
----------------------
public class MinHeap{
	static int [] arr;
	static int size;
	
	MinHeap(int size){
		this.size=size;
		this.arr=new int[size];
	}


	MinHeap(int arr[]){
		this.size=arr.length;
		this.arr=arr;
	}
	
	public static void printAllElements(){
		System.out.println("\nprinting all heap elements");
		for(int i=0;i<size;++i){
			System.out.print(arr[i]+"-");			
		}
	}
	
	public static void buildHeap(){ // bottom to top //o(n)
		for(int i=(size-2)/2;i>=0;--i){
			minHeapify(i);//top to bottom
		}
	}
	
	private static void swap(int x,int y){
		int temp=arr[x];
		arr[x]=arr[y];
		arr[y]=temp;
	}
	
	public static void minHeapify(int root){ //top to bottom - o(logn)
		int left=2*root+1;
		int right=2*root+2;

		int smallest=root;
		if(right<size && arr[smallest]>arr[right]){
			smallest=right;
		}
		if(left<size && arr[smallest]>arr[left]){
			smallest=left;
		}
		if(smallest!=root){
			swap(root,smallest);
			minHeapify(smallest);
		}
	}

	public static int extractMin(){
		if(size==0) return Integer.MAX_VALUE;
		if(size==1){
			size--;
			return arr[0];
		}
		swap(0,size-1);
		--size;
		minHeapify(0);
		return arr[size];
	}

	public static void sort(){
		System.out.print("\nSorted numbers:-");
		while(size!=0){
			System.out.print(extractMin()+"-");
		}
	}

	public static void main(String args[]){
		int arr[]={2,0,21,1221,12,233,3,1};
		MinHeap minHeap=new MinHeap(arr);
		buildHeap();
		printAllElements();
		System.out.println("\nhighest prority element in min heap is: "+extractMin());
		printAllElements();
		sort();
	}

}

File: findKthLargest-Selection Approach better.txt
Question Type: Heap
DSA Question: DSA problem related to: findKthLargest-Selection Approach better
----------------------
class findKthLargest{
    public int findKthLargest(int[] nums, int k) {
        MaxHeap heap=new MaxHeap(nums);
        heap.buildHeap();
        for(int i=0;i<k-1;++i){
            heap.extract();
        }
        return heap.extract();
    }
    
}

public class MaxHeap{
	static int [] arr;
	static int size;
	
	MaxHeap(int size){
		this.size=size;
		this.arr=new int[size];
	}


	MaxHeap(int arr[]){
		this.size=arr.length;
		this.arr=arr;
	}
	
	public static void printAllElements(){
		System.out.println("\nprinting all heap elements");
		for(int i=0;i<size;++i){
			System.out.print(arr[i]+"-");			
		}
	}
	
	public static void buildHeap(){ // bottom to top //o(n)
		for(int i=(size-2)/2;i>=0;--i){
			Heapify(i);
		}
	}
	
	private static void swap(int x,int y){
		int temp=arr[x];
		arr[x]=arr[y];
		arr[y]=temp;
	}
	
	public static void Heapify(int root){ //top to bottom - o(logn)
		int left=2*root+1;
		int right=2*root+2;

		int largest=root;
		if(right<size && arr[largest]<arr[right]){
			largest=right;
		}
		if(left<size && arr[largest]<arr[left]){
			largest=left;
		}
		if(largest!=root){
			swap(root,largest);
			Heapify(largest);
		}
	}

	public static int extract(){
		if(size==0) return Integer.MIN_VALUE;
		if(size==1){
			size--;
			return arr[0];
		}
		swap(0,size-1);
		--size;
		Heapify(0);
		return arr[size];
	}

}

File: MedianOfTwoSortedArray-Selection Approach better.txt
Question Type: Heap
DSA Question: DSA problem related to: MedianOfTwoSortedArray-Selection Approach better
----------------------
class MedianOfTwoSortedArray{
    int size=0;
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {        
      MiddleHeap heap=new MiddleHeap(nums1.length+nums2.length);

      for(int i=0;i<nums1.length;++i){
           heap.insertMiddle(nums1[i]);
      }  
       for(int i=0;i<nums2.length;++i){
           heap.insertMiddle(nums2[i]);
      }    
        return heap.getMedian();
        
    }
    
    

}

 class MiddleHeap {
    MinHeap minHeap;
    MaxHeap maxHeap;

    public MiddleHeap(int capacity) {
        if ((double) (capacity % 2) > 0.0) {
            this.minHeap = new MinHeap(capacity / 2);
            this.maxHeap = new MaxHeap(capacity / 2 + 1);
        } else {
            this.minHeap = new MinHeap(capacity / 2);
            this.maxHeap = new MaxHeap(capacity / 2);
        }
    }

    public void printAll(){
        maxHeap.printAll();
        minHeap.printAll(minHeap.getArr());

    }

    public void insertMiddle(int newValue) {
        if (maxHeap.arr[0] == null) {
            maxHeap.insertMax(newValue);
        } else if (maxHeap.size > minHeap.size) {
            if (newValue < maxHeap.getMax()) {
                minHeap.insertMin(maxHeap.extractMax());
                maxHeap.insertMax(newValue);
            } else {
                minHeap.insertMin(newValue);
            }
        } else if (maxHeap.size == minHeap.size) {
            if (newValue > minHeap.getMin()) {
                maxHeap.insertMax(minHeap.extractMin());
                minHeap.insertMin(newValue);
            } else {
                maxHeap.insertMax(newValue);
            }
        }
    }

    public double getMedian() {
        if ((double) ((maxHeap.size + minHeap.size) % 2) > 0.0) {
           return maxHeap.getMax();
        } else {
            return (double)(maxHeap.getMax() +minHeap.getMin())/2;
        }
    }

    public void extractMedian() {
        if ((double) ((maxHeap.size + minHeap.size) % 2) > 0.0) {
            System.out.println(maxHeap.extractMax());
        } else {
            System.out.println(maxHeap.extractMax() +" & "+ minHeap.extractMin());
        }
    }

    public void medianDelete(int i) {
        if ((double) ((maxHeap.size + minHeap.size) % 2) > 0.0) {
            System.out.println(maxHeap.maxdelete(0));
        } else {
            System.out.println(maxHeap.maxdelete(0) +" & "+ minHeap.Mindelete(0));
        }
    }

}


 class MinHeap {
    public static Integer arr[];
    public static int size;
    public static int capacity;

    public static Integer[] getArr() {
        return arr;
    }

    public static void setArr(Integer[] arr) {
        MinHeap.arr = arr;
    }

    public static void setSize(int size) {
        MinHeap.size = size;
    }

    public static int getCapacity() {
        return capacity;
    }

    public static void setCapacity(int capacity) {
        MinHeap.capacity = capacity;
    }

    public MinHeap() {

    }

    public MinHeap(int capacity) {
        this.arr = new Integer[capacity];
        this.size = 0;
        this.capacity = capacity;
    }

    public int getSize() {
        return this.size;
    }

    public Boolean isEmpty() {
        return this.size < 1;
    }

    public int getParent(int i) {
        return (i - 1) / 2;
    }

    public int getLeftChild(int i) {
        return 2 * i + 1;
    }

    public int getRightChild(int i) {
        return 2 * i + 2;
    }


    public void insertMin(int newValue) {  //O(log(size))
        if (this.getSize() + 1 > capacity) {
            System.out.println("Size is full");
            return;
        }
        size++;
        arr[size - 1] = newValue;
        int i = size - 1;
        while (i >= 0 && arr[getParent(i)] > arr[i]) {
            int temp = arr[getParent(i)];
            arr[getParent(i)] = arr[i];
            arr[i] = temp;
            i = getParent(i);
        }
    }

    public static void printAll(Integer[] arrr) {
        for (int i = 0; i < arrr.length; ++i) {
            System.out.print(arrr[i] + " ");
        }
    }


    public int getMin() {
        return arr[0];
    }


    public int extractMin() {
        if (size == 0) {
            return Integer.MIN_VALUE;
        }
        if (size == 1) {
            size--;
            return arr[0];
        }
        int temp = arr[0];
        arr[0] = arr[size - 1];
        arr[size - 1] = temp;
        size--;
        MinHeapify(arr,size,0);
        return arr[size];
    }


    public int Mindelete(int i) {
        int key;
        if (size < 1) {
            System.out.println("Wrong Position");
            return 0;
        }
        key = arr[i];
        arr[i] = arr[size - 1];
        size--;
        MinHeapify(arr,size,i);
        return key;
    }


    public static void buildMinHeap(Integer[] arrr) {
        arr = arrr;
        capacity = arr.length;
        size = arr.length;
        for (int i = (size - 2) / 2; i >= 0; i--) {
            MinHeapify(arr,size,i);
        }
    }



    public static void MinHeapify(Integer[] arrr, int modifiedSize, int i) { //O(logN)
        int leftIndex = 2*i + 1;
        int rightIndex = 2*i + 2;
        int smallest = i;
        if (leftIndex < modifiedSize && arrr[leftIndex] < arrr[smallest]) {
            smallest = leftIndex;
        }
        if (rightIndex < modifiedSize && arrr[rightIndex] < arrr[smallest]) {
            smallest = rightIndex;
        }
        if (smallest != i) {
            int temp = arrr[i];
            arrr[i] = arrr[smallest];
            arrr[smallest] = temp;
            MinHeapify(arrr,modifiedSize,smallest);
        }
    }

    public static void sort(Integer arr[]) {
        int n = arr.length;
        buildMinHeap(arr);

        for (int i = n - 1; i >=1; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            //we are putting the smallest one in the last position and keep decreasing the size
            MinHeapify(arr, i, 0);
        }
    }
    
}

 class MaxHeap {
    Integer arr[];
    int size;
    int capacity;

    public MaxHeap() {

    }

    public MaxHeap(int capacity) {
        this.arr = new Integer[capacity];
        this.size = 0;
        this.capacity = capacity;
    }

    public int getSize() {
        return this.size;
    }

    public Boolean isEmpty() {
        return this.size < 1;
    }

    public int getParent(int i) {
        return (i - 1) / 2;
    }

    public int getLeftChild(int i) {
        return 2 * i + 1;
    }

    public int getRightChild(int i) {
        return 2 * i + 2;
    }


    public void insertMax(int newValue) {  //O(log(size))
        if (this.getSize() + 1 > capacity) {
            System.out.println("Size is full");
            return;
        }
        size++;
        arr[size - 1] = newValue;
        int i = size - 1;
        while (i >= 0 && arr[getParent(i)] < arr[i]) {
            int temp = arr[getParent(i)];
            arr[getParent(i)] = arr[i];
            arr[i] = temp;
            i = getParent(i);
        }
    }

    public void printAll() {
        for (int i = 0; i < size; ++i) {
            System.out.print(arr[i] + " ");
        }
    }


    public int getMax() {
        return arr[0];
    }


    public int extractMax() {
        if (size == 0) {
            return Integer.MIN_VALUE;
        }
        if (size == 1) {
            size--;
            return arr[0];
        }
        int temp = arr[0];
        arr[0] = arr[size - 1];
        arr[size - 1] = temp;
        size--;
        maxHeapify(arr,size,0);
        return arr[size];
    }


    public int maxdelete(int i) {
        int key;
        if (size < 1) {
            System.out.println("Wrong Position");
            return 0;
        }
        key = arr[i];
        arr[i] = arr[size - 1];
        size--;
        maxHeapify(arr,size,i);
        return key;
    }


    public void buildMaxHeap(Integer[] arr) {
        this.arr = arr;
        this.capacity = arr.length;
        this.size = arr.length;
        for (int i = (size - 2) / 2; i >= 0; i--) {
            maxHeapify(arr,size,i);
        }
    }



    public void maxHeapify(Integer[] arrr, int modifiedSize, int i) { //O(logN)
        int leftIndex = 2*i + 1;
        int rightIndex = 2*i + 2;
        int largest = i;
        if (leftIndex < modifiedSize && arrr[leftIndex] > arrr[largest]) {
            largest = leftIndex;
        }
        if (rightIndex < modifiedSize && arrr[rightIndex] > arrr[largest]) {
            largest = rightIndex;
        }
        if (largest != i) {
            int temp = arrr[i];
            arrr[i] = arrr[largest];
            arrr[largest] = temp;
            maxHeapify(arrr,modifiedSize,largest);
        }
    }

    public void sort(Integer arr[]) {
        int n = arr.length;
        buildMaxHeap(arr);

        for (int i = n - 1; i >=1; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            //we are putting the largest one in the last position and keep decreasing the size
            maxHeapify(arr, i, 0);
        }
    }


}



File: KthLargestElementInAStream.txt
Question Type: Heap
DSA Question: DSA problem related to: KthLargestElementInAStream
----------------------
class KthLargest {
    PriorityQueue<Integer> pq;
    int k;
    public KthLargest(int k, int[] nums) {
        this.k=k;
        pq=new PriorityQueue<>(k+1);
        for(int num:nums){
            add(num);
        }
    }
    public int add(int val) {
        pq.add(val); 
        if(pq.size()==k+1){
            pq.poll();
        }
        return pq.peek();
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest obj = new KthLargest(k, nums);
 * int param_1 = obj.add(val);
 */

File: Top K Frequent Element.txt
Question Type: Heap
DSA Question: DSA problem related to: Top K Frequent Element
----------------------
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        if (k == nums.length) {
            return nums;
        }
        int[] ans=new int[k];
        HashMap<Integer,Integer> map=new HashMap<>();
        PriorityQueue<Integer> pq=new PriorityQueue<>((n1, n2) ->   map.get(n1)-map.get(n2));
        
        int i=0;
        while(i<=nums.length-1){
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
            i++;
        }
        for(Integer key:map.keySet()){
            pq.add(key);
            if(pq.size()>k){
                pq.poll();
            }
        }
        for(i=0;i<k;++i){
            ans[i]=pq.poll();
        }
        return ans;
    }
}

File: MergeKSortedLists.txt
Question Type: Heap
DSA Question: DSA problem related to: MergeKSortedLists
----------------------
/*
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
*/
class The_Comparator implements Comparator<ListNode> { 
    public int compare(ListNode l1, ListNode l2) 
    {  
        return l1.val-l2.val; 
    } 
} 

class MergeKSortedLists{
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0) return null;
        ListNode result=new ListNode();
        ListNode current=result,top=null;
        PriorityQueue<ListNode> pq=new PriorityQueue<>(lists.length,new The_Comparator());
        for(int i=0;i<lists.length;++i){
            if(lists[i]!=null){
                pq.add(lists[i]);
            }
        }
        while(!pq.isEmpty()){
            top=pq.poll();//main point
         
            if(top.next!=null){
                pq.add(top.next);    
            }
            current.next=top;
            current= current.next;
        }
        
      return result.next;  
    }
}

File: firstMissingPositiveInteger.txt
Question Type: Maths
DSA Question: DSA problem related to: firstMissingPositiveInteger
----------------------
class Solution {//100
    public int firstMissingPositive(int[] nums) {
        boolean oneFound=false;
        for(int i=0;i<nums.length;++i){
            if(nums[i]==1){
                oneFound=true;
            }else if(nums[i]>nums.length || nums[i]<=0){
                nums[i]=1;
            }
        }
        if(!oneFound) return 1;
        if(nums.length==1) return 2;
        for(int i=0;i<nums.length;++i){
            int index=Math.abs(nums[i])-1;
            nums[index]=nums[index]>0?-1*nums[index]:nums[index];
        }
        
        for(int i=0;i<nums.length;++i){
            if(nums[i]>0) return i+1;
        }
        
        return nums.length+1;
    }
}


File: Power.txt
Question Type: Maths
DSA Question: DSA problem related to: Power
----------------------
class Solution {
    public double myPow(double x, int n) {
        long N=n;
        if(N<0){
            x=1/x;
            N=-1*N;
        }
        return myPowL(x,N);
    }
    
    public double myPowL(double x, long N) {
        if(N==0) return 1;
        double pow=myPowL(x,N/2);
        if(N%2==0){
            return pow*pow;
        }
        return pow*pow*x;
    }
}

File: SquareRootOfInteger.txt
Question Type: Maths
DSA Question: DSA problem related to: SquareRootOfInteger
----------------------
/*
Implement int sqrt(int x).

Compute and return the square root of x, where x is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.
*/
class Solution {
    public int mySqrt(int x) {
        if(x<2) return x;
        return helper(x,0,x);
    }
    
    int helper(int x,int l,int h){
        if(l>h) return -1;
        if(l+1==h) return l;
        long avg=l+(h-l)/2;
        long mul=avg*avg;
        if(mul==x){
          return (int)avg;  
        }else if(mul<x){
            return helper(x,(int)avg,h);
        } return helper(x,l,(int)avg);
        
    }
}

class Solution {
    public int mySqrt(int x) {
        if(x<=1) return x;
        int left=2,right=x/2;
        while(left<=right){
            int pivot=(left+right)/2;
            if((long)pivot*pivot>x) {right=pivot-1;}
            else if((long)pivot*pivot<x) {left=pivot+1;}
            else return pivot;
        }
        return right;
    }
}


File: FindDuplicateElementsInAnArray.txt
Question Type: Maths
DSA Question: DSA problem related to: FindDuplicateElementsInAnArray
----------------------
class Solution {
    public int findDuplicate(int[] nums) {
        for(int i=0;i<nums.length;++i){
            int abs=Math.abs(nums[i]);
            if(nums[abs]<0){
                return abs;
            }
            nums[abs]=-1*nums[abs];
        }
        return -1;
    }
}


File: ReverseNumber.txt
Question Type: Maths
DSA Question: DSA problem related to: ReverseNumber
----------------------
/*
Given a 32-bit signed integer, reverse digits of an integer.
*/
class Solution {//improved
    public int reverse(int x) {
        boolean negative=x<0?true:false;
        x=Math.abs(x);
        int ans=0;
        while(x!=0){ //123
            int pop=x%10;
/*
However, this approach is dangerous, because the pop can cause overflow.
*/
            if (ans > Integer.MAX_VALUE/10 || (ans == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (ans < Integer.MIN_VALUE/10 || (ans == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            ans=ans*10+pop; //3
            x=x/10;//12
        }
        ans=negative?(ans*-1):ans;
        return ans;
    }
}

class ReverseNumber {
    public int reverse(int x) {
        boolean negative=x<0?true:false;
        x=Math.abs(x);
        String s=((Integer)x).toString();
        int len=s.length();
        s="";
        int rem=0;
        for(int i=1;i<=len;++i){
            rem=x%10;
            s=s+rem;
            x=x/10;
        }
        try{
          x=Integer.parseInt(s);  
        }catch(Exception ex){
            x=0;
        }
        
        x=negative?(x*-1):x;
        return x;
    }
}

File: Convert Binary to Integer.txt
Question Type: Maths
DSA Question: DSA problem related to: Convert Binary to Integer
----------------------
//Convert Binary Number in a Linked List to Integer
class Solution {
    public int getDecimalValue(ListNode head) {
        if(head==null){
            return 0;
        }
        head=reverseList(head);
        int ans=0;
        int i=0;
        while(head!=null){
            ans=ans+head.val*(int)Math.pow(2,i);
            ++i;
            head=head.next;
        }
        return ans;
    }

    ListNode reverseList(ListNode root){
        ListNode prev=null,curr=root,next=null;
        while(curr!=null){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
    }
}

File: PrimeNumber Count upto N number(Sieve of Eratosthenes).txt
Question Type: Maths
DSA Question: DSA problem related to: PrimeNumber Count upto N number(Sieve of Eratosthenes)
----------------------
//The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n.
class Solution {
    public int countPrimes(int n) {
        int count=0;
        boolean[] isPrime=new boolean[n];
        for(int i=2;i<n;++i){
            isPrime[i]=true;
        }
        for(int i=2;i*i<n;++i){
            if(!isPrime[i]) continue;
            markMultiplesAsNotPrime(i,n,isPrime);
        }
        for(int i=2;i<n;++i){
            if(isPrime[i]) count++;
        }
        return count;
    }
    
    void markMultiplesAsNotPrime(int i,int n,boolean [] isPrime){
        for(int j=i*i;j<n;j=j+i){
            isPrime[j]=false;
        }
    }
}

File: InsertionSort.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
//o(n2)

public class InsertionSort{
	static void doInsertionSort(int arr[]){	
		for(int i=1;i<arr.length;++i){ //first loop provides key
			int j,key=arr[i];

			//2nd loop insert the key at right position
			for(j=i-1;j>=0 && arr[j]>key;--j){ // before j all are sorted;   arr[j]>key condition of being unsorted
				arr[j+1]=arr[j];
			}	
			arr[j+1]=key;   
					//for loop go ahead bhavuk hoke 
				        //j is the position i.e arr[j]<key
					//arr[j+1]th element is already shifted to arr[j+2]
					//so no need of swap just allocate j+1 th elemt with key
					//Insertion Sort- as inserting right element at right place.		
		}
	}
	
	static void printAll(int[] arr){
		System.out.print("All Elements are : ");
		for(int i=0;i<arr.length;++i){
			System.out.print(arr[i]+"-");
		}
	}

	public static void main(String args[]){
		int arr[]={21,32,123,12,3,12,434,1};
		doInsertionSort(arr);
		printAll(arr);
	}

}

File: ThreeSum.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums); // Sort the array to enable two-pointer approach
        
        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicates for the first element
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            // Use two pointers to find the other two elements
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    // Found a valid triplet
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // Skip duplicates for the second and third elements
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < 0) {
                    // If sum is less than 0, move the left pointer to increase the sum
                    left++;
                } else {
                    // If sum is greater than 0, move the right pointer to decrease the sum
                    right--;
                }
            }
        }

        return result;
    }
}

class Solution {
    Set<List<Integer>> result=new HashSet<>();
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);

        for(int k=0;k<nums.length;++k){
            twoSum(k,nums);
        }
        return new ArrayList<>(result);
    }

    private void twoSum(int k,int[] nums){
        int l=0,h=nums.length-1;

        while(l<h && l!=k && h!=k){
            int sum=nums[l]+nums[h];
            if(sum+nums[k]==0){
                List<Integer> list=new LinkedList<>();
                if(nums[l]<nums[k]){  
                    list.add(nums[l]);
                    list.add(Math.min(nums[h],nums[k]));
                    list.add(Math.max(nums[h],nums[k]));
                }else{
                    list.add(nums[k]);
                    list.add(nums[l]);
                    list.add(nums[h]);
                }
                result.add(list); ++l;
            }else if(sum>-nums[k]){
                --h;
            }else if(sum<-nums[k]){
                ++l;
            }
        }
    }
}

class Solution {//MAP
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result=new ArrayList<>();
        if(nums.length!=0){
            Integer prev=null;
            for(int i=0;i<nums.length;++i){
                if(prev!=null && prev==nums[i]){
                    continue;
                }
                prev=nums[i];   
                int A=nums[i]*-1;
                twoSum(result,nums,i,A);
            }   
        }
        return result;
    }

    void twoSum(List<List<Integer>> result,int[] nums,int AIndex, int sum) {
        int l=AIndex+1,h=nums.length-1;
        while(l<h){
            int BC=nums[l]+nums[h];
            if(BC>sum || (h<nums.length-1 && nums[h]==nums[h+1])){
                h--;
            }else if(BC<sum || (l>AIndex+1 && nums[l]==nums[l-1])){
                l++;
            }else{
                result.add(Arrays.asList(nums[AIndex],nums[l++],nums[h--]));
            }
            
        }
    }
}


File: BubbleSort.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
public class BubbleSort{//o(n2) //detect if already sorted

	static void doBubbleSort(int arr[]){
		Boolean swapped=true;
		while(swapped){
			swapped=false;
			for(int i=0;i<arr.length-1;++i){
				if(arr[i]>arr[i+1]){
					int temp=arr[i];
					arr[i]=arr[i+1];
					arr[i+1]=temp;
					swapped=true;
				}
			}
		}
	}
	
	static void printAll(int[] arr){
		System.out.print("All Elements are : ");
		for(int i=0;i<arr.length;++i){
			System.out.print(arr[i]+"-");
		}
	}

	public static void main(String args[]){
		int arr[]={21,32,123,12,3,12,434,1};
		doBubbleSort(arr);
		printAll(arr);
	}

}

File: ThreeSumClosest.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    int minDiff=Integer.MAX_VALUE;
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        for(int i=0;i<=nums.length-3;++i){
            twoSum(nums,target,i,i+1,nums.length-1);
            if(minDiff==0) break;
        }
        return target-minDiff;
    }
    
    void twoSum(int[] nums,int target,int i,int l,int h){
        while(l<h){
            int sum=nums[i]+nums[l]+nums[h];
            if(Math.abs(target-sum)<Math.abs(minDiff)){
                minDiff=target-sum;
            }
            if(sum>target){
                --h;
            }else if(sum<target){
                ++l;
            }else{
                return;
            }
        }
    }
}

File: MergeIntervals.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public int[][] merge(int[][] intervals) {
        int[][] ans=new int[0][0];
        if(intervals.length==0) return ans;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[0]-b[0];
            }
        });
        PriorityQueue<int[]> pq=new PriorityQueue<>(new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return b[1]-a[1];
            }
        });
        
        pq.add(intervals[0]);
        for(int i=1;i<intervals.length;++i){
            if(pq.peek()[1]>=intervals[i][0]){
                int[] poll=pq.poll();
                if(poll[1]<intervals[i][1]){
                    poll[1]=intervals[i][1];
                }
                pq.add(poll);
            }else{
                pq.add(intervals[i]);
            }
        }
        ans=new int[pq.size()][2]; 
        int i=0;
        while(!pq.isEmpty()){
            ans[i]=pq.poll();
            ++i;
        }
        return ans;
    }
}

File: MergeSort.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null) return null;
        ListNode last=head;
        while(last.next!=null){
            last=last.next;
        }
        return mergeSort(head,last);
    }
    
    ListNode mergeSort(ListNode l,ListNode h){
        if(l==h) return l;
        ListNode middle=findMiddle(l);
        ListNode next=middle.next;
        middle.next=null;
        ListNode left=mergeSort(l,middle);
        ListNode right=mergeSort(next,h);
        return sort(left,right);
    }
    
    ListNode sort(ListNode list1,ListNode list2){
        ListNode dummy=new ListNode();
        ListNode curr=dummy;
        while(list1!=null && list2!=null){
            if(list1.val<=list2.val){
                curr.next=list1;
                curr=curr.next;
                list1=list1.next;
            }else{
                curr.next=list2;
                curr=curr.next;
                list2=list2.next;                
            }
        }
        while(list1!=null){
                curr.next=list1;
                curr=curr.next;
                list1=list1.next;
        }
        while(list2!=null){
                curr.next=list2;
                curr=curr.next;
                list2=list2.next;
        }
        return dummy.next;
    }
    
    ListNode findMiddle(ListNode head){
        ListNode ptr1=head,ptr2=head;
        while(ptr2.next!=null && ptr2.next.next!=null){
            ptr1=ptr1.next;
            ptr2=ptr2.next.next;
        }
        return ptr1;
    }
}
public class MergeSort{
    static void doMergeSort(int [] arr,int l,int h){
	if(h>l){
        	int mid=(l+(h-l)/2);
		doMergeSort(arr,l,mid);
		doMergeSort(arr,mid+1,h);
		merge(arr,l,mid,h);
	}
    }
	
    static void merge(int[] arr,int l,int mid,int high){
	int[] left=new int[mid-l+1];
	int[] right=new int[high-(mid+1)+1];
	for(int i=l;i<=mid;++i){
		left[i-l]=arr[i];
	}
	for(int i=mid+1;i<=high;++i){
		right[i-(mid+1)]=arr[i];
	}
	int indexL=0; int indexR=0; int mainIndex=l;
	while(indexL<left.length && indexR<right.length){
		if(left[indexL]<right[indexR]){
			arr[mainIndex++]=left[indexL++];
		}else{
			arr[mainIndex++]=right[indexR++];
		}
	}
	while(indexL<left.length){
		arr[mainIndex++]=left[indexL++];
	}
	while(indexR<right.length){
		arr[mainIndex++]=right[indexR++];
	}

    }		

    static void printAll(int[] arr){
        System.out.print("\nAll Elements after partitioning are : ");
        for(int i=0;i<arr.length;++i){
            System.out.print(arr[i]+"-");
        }
    }

    public static void main(String args[]){
        int [] arr={12,2132,12,3,1,32,53,1,212,42};
        doMergeSort(arr,0,arr.length-1);
        printAll(arr);
    }

}


File: TwoSum.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
/*
Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
*/

import java.util.Arrays;
class TwoSum{
    public int[] twoSumUsingSorting(int[] nums, int target) {
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;++i){
            map.put(nums[i],i);
        }
        Arrays.sort(nums);
        int l=0,h=nums.length-1,currSum;
        while(l<h){
            currSum=nums[l]+nums[h];
            if(currSum==target){
                break;
            }
            if(currSum>target) --h;
            else ++l;
        }
        int [] result={map.get(nums[l]),map.get(nums[h])};
        return result;
    }

class Solution {
    public int[] twoSum(int[] nums, int target) {
        int l=0,h=nums.length-1;
        while(l<h){
            int sum=nums[l]+nums[h];
            if(sum==target){
                int[] ans={l+1,h+1};
               return ans; 
            } 
            else if(sum>target){
                --h;
            }else if(sum<target){
                ++l;
            }
        }
        return null;
    }
}

    public static int[] twoSumUsingHashMap(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int[] result = new int[2];
        for (int i = 0; i < nums.length; ++i) {
            if (map.containsKey(target - nums[i])) {
                result[1] = i;
                result[0] = map.get(target - nums[i]);
                break;
            }
            map.put(nums[i], i);
        }
        return result;
    }

class Solution {//Revision
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map=new HashMap<>();
        int [] result=new int[2];
        for(int i=0;i<nums.length;++i){
            if(map.containsKey(target-nums[i])){
                result[1]=i;
                result[0]=map.get(target-nums[i]);
                break;
            }
            map.put(nums[i],i);
        }
        return result;
    }
}
}

File: MinimumSwapsToSortAnArray.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
/*
You are given an unordered array consisting of consecutive integers  [1, 2, 3, ..., n] without any duplicates. You are allowed to swap any two elements. You need to find the minimum number of swaps required to sort the array in ascending order.
*/    
static int minimumSwaps(int[] arr) {
        int count=0;
        boolean [] visited=new boolean[arr.length+1]; 
        for(int i=0;i<arr.length;++i){
            if(visited[i+1]==false){
               visited[i+1]=true;
               if(arr[i]==i+1)continue;
               else{
                   int next=arr[i];
                   while(visited[next]!=true){
                       visited[next]=true;
                       ++count;
                       next=arr[next-1];
                   }
               }
            }
        }
        return count;
    }


File: QuickSortPartition.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public int findKthLargest(int[] nums, int k) {
        sort(nums,0,nums.length);
        return nums[nums.length-k];
    }

    void sort(int[] nums,int l,int h){
      if(l>=h) return ;
      int j=partition(nums,l,h);
      sort(nums,l,j);
      sort(nums,j+1,h);
    }

    int partition(int[] arr,int l,int h){
      int pivot=arr[l];
      int i=l,j=h;
      while(i<h){
        do{
          ++i;
        }while(i<arr.length && arr[i]<=pivot);

        do{
          --j;
        }while(j>=0 && arr[j]>pivot);

        if(j<i){
          break;
        }else{
          swap(i,j,arr);
        }
      }
      swap(l,j,arr);
      return j;
    }

    void swap(int i,int j,int[] arr){
      int temp=arr[i];
      arr[i]=arr[j];
      arr[j]=temp;
    }
}

public class QuickSortPartition{//o(nlogn) // do not use extra memory space other than recursion stack merge sort use memory space for left and right array while merging
					   //in merge sort left and right array are sorted while merging so need to pick one by one from each array for merging
					   // both follow divide nd concur		
    static void doQuickSort(int [] arr,int l,int h){
        int p;
        if(l<h){
            p=doPartition(arr,l,h); //p is pivot at its right place
            doQuickSort(arr,l,p); //p->sorted element
            doQuickSort(arr,p+1,h); //h->infi
        }
    }

    static int doPartition(int [] arr,int l,int h){   //11,1,6,2,21
        int pivot=arr[l];
        int i=l,j=h;
        while(i<j){
            do{
                i++;
            }
            while(i<arr.length && arr[i]<=pivot);
            do{
                j--;
            }
            while(arr[j]>pivot);
            if(j<i) {
                break;
            }else{
                int temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
        }
        int temp2=arr[l];
        arr[l]=arr[j];
        arr[j]=temp2;
        return j;
    }

    static void printAll(int[] arr){
        System.out.print("\nAll Elements after Sorting are : ");
        for(int i=0;i<arr.length;++i){
            System.out.print(arr[i]+"-");
        }
    }

    public static void main(String args[]){
        int [] arr={12,2132,12,3,1,32,53,1,212,42};
        doQuickSort(arr,0,arr.length);
        printAll(arr);
    }

}


File: MergeSortedArray.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i=m-1,j=n-1,ptr=nums1.length-1;
        while(i>=0 && j>=0){
            int temp;
            if(nums1[i]>nums2[j]){
                temp=nums1[i--];
            }else{
                temp=nums2[j--];
            }
            nums1[ptr--]=temp;
        }
        while(i>=0){
            int temp;
            temp=nums1[i--];
            nums1[ptr--]=temp;
        }
        while(j>=0){
            int temp;
            temp=nums2[j--];
            nums1[ptr--]=temp;
        }
    }
}
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index=nums1.length-1;
        int m1=nums1.length;
        while(n>0){
            if(m==0 || nums1[m-1]<nums2[n-1]){
               nums1[index]=nums2[n-1];
               n--; 
            }else{
               nums1[index]=nums1[m-1]; 
               m--; 
            }
            index--;
        }
    }
}


File: ThreeSumSmaller.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    int ans=0;
    public int threeSumSmaller(int[] nums, int target) {
        Arrays.sort(nums);
        for(int i=0;i<=nums.length-3;++i){
            twoSum(nums,target-nums[i],i+1,nums.length-1);
        }
        return ans;
    }
    
    void twoSum(int[] nums,int target,int l,int h){
        while(l<h){
            if(nums[l]+nums[h]>=target){
                --h;
            }else{
                ans=ans+h-l;
                ++l;
            }
        }
    }
}

File: SelectionSort.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
public class SelectionSort{//o(n2) //Selection sort as it selects the lowest one in secound iteration and put at first iteration index

	static void doSelectionSort(int arr[]){
		
		for(int j=0;j<arr.length;++j){
			int min=j;
			for(int i=j;i<arr.length;++i){
				if(arr[min]>arr[i]){
					min=i;
				}
			}
			if(j!=min){
				int temp=arr[j];
				arr[j]=arr[min];
				arr[min]=temp;
			}	
		}
	}
	

	static void printAll(int[] arr){
		System.out.print("All Elements are : ");
		for(int i=0;i<arr.length;++i){
			System.out.print(arr[i]+"-");
		}
	}

	public static void main(String args[]){
		int arr[]={21,32,123,12,3,12,434,1};
		doSelectionSort(arr);
		printAll(arr);
	}

}

File: ContainsDuplicates.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        for(int i=1;i<nums.length;++i){
            if(nums[i-1]==nums[i]) return true;
        }
        return false;    
    }
}

File: NutsAndBolts.txt
Question Type: Sorting
DSA Question: Write an algorithm to sort an array.
----------------------
public class NutsAndBolts{
	
	static void quickSort(int[] nuts,int[] bolts,int l,int h){
		if(l<h){
			int pivot=partition(nuts,l,h);
			partition(bolts,l,h,nuts[pivot]);
			quickSort(nuts,bolts,l,pivot);
			quickSort(nuts,bolts,pivot+1,h);
		}
	}

	static void partition(int[] arr,int l,int h,Integer pivot){
		int i=l-1,j=h;
		while(i<h){
			do{
			 ++i;
			}while(i<(arr.length) && arr[i]<=pivot);

			do{
			 --j;
			}while(arr[j]>pivot);

			if(j>i){
			int temp=arr[i];
			arr[i]=arr[j];
			arr[j]=temp;
			}else{
			 break;
			}
			
		}
	}

	static int partition(int[] arr,int l,int h){
		int pivot=arr[l];
		int i=l,j=h;
		while(i<h){
			do{
			 ++i;
			}while(i<(arr.length) && arr[i]<=pivot);

			do{
			 --j;
			}while(arr[j]>pivot);

			if(j>i){
			int temp=arr[i];
			arr[i]=arr[j];
			arr[j]=temp;
			}else{
			 break;
			}
			
		}
		int temp2=arr[j];
		arr[j]=arr[l];
		arr[l]=temp2;
		return j;
	}
	
	static void printAll(int[] arr){
		System.out.print("\n");
		for(int i=0;i<arr.length;++i){
			System.out.print(arr[i]+" ");
		}
	}

	public static void main(String args[]){
		int nuts[]={2,1,3,4,7,6,9};
		int bolts[]={3,4,2,1,9,7,6};
		quickSort(nuts,bolts,0,nuts.length);
		printAll(nuts);
		printAll(bolts);
		
		
	}
}

File: Readme.txt
Question Type: Data-Structures-and-Algorithms-II
DSA Question: DSA problem related to: Readme
----------------------
Charity given out of duty, 
without expectation of  return, 
at the proper time and place, 
and to a worthy person is considered to be in the mode of goodness.


File: KthLargestElementInAnArray.txt
Question Type: Selection
DSA Question: DSA problem related to: KthLargestElementInAnArray
----------------------
class Solution {
    public int findKthLargest(int[] arr, int k) {
        if(arr.length==0) return 0;
        helper(arr,0,arr.length,k);
        return arr[k-1];
    }
    
    void helper(int[] arr,int l,int h,int k){
        if(l>h) return;
        int j=partition(arr,l,h,k);
        if(j==k-1) {
            return;
        }else if(j<k-1){
            helper(arr,j+1,h,k);
        }else{
            helper(arr,l,j,k);
        }
    }
    
    int partition(int[] arr,int l,int h,int k){
        int i=l,j=h,pivot=arr[l];
        while(i<j){
            do{
                ++i;
            }while(i<h && arr[i]>=pivot);
            do{
                --j;
            }while(j>=0 && arr[j]<pivot);
            if(i<j) swap(arr,i,j);
        }
        swap(arr,l,j);
        return j;
    }
    
    void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}

File: MedianOfTwoSortedArray.txt
Question Type: Selection
DSA Question: DSA problem related to: MedianOfTwoSortedArray
----------------------
    public double findMedianSortedArrays(int[] nums1, int[] nums2) { //log(min(x,y))
        if(nums1.length>nums2.length){
            return findMedianSortedArrays(nums2,nums1);
        }
        int length1=nums1.length;
        int length2=nums2.length;
        int l=0,h=length1;
        while(l<=h){
            int posX=(l+h)/2;
            int posY=(length1 + length2+1)/2-posX;
            
            int minX=(posX==0)?Integer.MIN_VALUE:nums1[posX-1];
            int maxX=(posX==length1)?Integer.MAX_VALUE:nums1[posX];
            int minY=(posY==0)?Integer.MIN_VALUE:nums2[posY-1];
            int maxY=(posY==length2)?Integer.MAX_VALUE:nums2[posY]; 
            if(minX<=maxY && minY<=maxX){
                double avg=(length1 + length2);
                avg=avg%2;
                if(avg==0.0){
                    return (double)(Math.max(minX,minY)+Math.min(maxX,maxY))/2;
                }else{
                    return Math.max(minX,minY);
                }
            }else if(maxY<minX){
                h=posX-1;
            }else if(minY>maxX){
                l=posX+1;
            }
        }
        throw new IllegalArgumentException();
    }


File: KthLargestElementInStream.txt
Question Type: Selection
DSA Question: DSA problem related to: KthLargestElementInStream
----------------------
class KthLargest {
    PriorityQueue<Integer> minPQ=new PriorityQueue<>();
    int k;
    public KthLargest(int k, int[] nums) {
        this.k=k;
        if(nums.length==0) return;
        if(k<nums.length){
            partitionHelper(k,nums,0,nums.length);            
        }
        int index=Math.min(k,nums.length);
        for(int i=0;i<index;++i){
            minPQ.add(nums[i]);
        }
    }
    
    void partitionHelper(int k,int[] nums,int l,int h){
        if(l>h) return ;
        int j=partition(nums,l,h);
        if(j==k-1) return;
        if(j<k-1){
            partitionHelper(k,nums,j+1,h);
        }else{
            partitionHelper(k,nums,l,j);
        }
    }
    
    int partition(int[] nums,int l,int h){
        int i=l,j=h;
        while(i<j){
            do{
                ++i;
            }while(i<nums.length && nums[i]>=nums[l]);  
            do{
                --j;
            }while(nums[j]<nums[l]);
            if(i>j) break;
            swap(nums,i,j);
        }
        swap(nums,l,j);
        return j;
    }
    
    void swap(int[] nums,int l,int h){
        int temp=nums[l];
        nums[l]=nums[h];
        nums[h]=temp;
    }
    
    public int add(int val) {
        if(minPQ.size()<k){
           minPQ.add(val); 
        }
        else if(minPQ.peek()<val){
            minPQ.poll();
            minPQ.add(val);
        }
        return minPQ.peek();
    }
}


File: Top K Frequent Elements.txt
Question Type: Selection
DSA Question: DSA problem related to: Top K Frequent Elements
----------------------
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int[] ans=new int[k];
        if (k == nums.length) {
            return ans=nums;
        }
        HashMap<Integer,Integer> countMap=new HashMap<>();
        for(int i=0;i<nums.length;++i){
            countMap.put(nums[i],countMap.getOrDefault(nums[i],0)+1);
        }
        nums=new int[countMap.keySet().size()];
        int m=0;
        for(Integer key:countMap.keySet()){
            nums[m]=key;
            ++m;
        }
        int j=helper(nums,k,0,nums.length,countMap);
        for(int i=0;i<ans.length;++i){
            ans[i]=nums[i];
        }
        return ans;
    }
    
    int helper(int[] nums,int k,int l,int h,Map<Integer,Integer> map){
        if(l>h) return -1;
        int j=partition(nums,l,h,map);
        if(j==k-1){
            return j;
        }else if(j>k-1){
            return helper(nums,k,l,j,map);
        }
        return helper(nums,k,j+1,h,map);
    }
    
    int partition(int[] nums,int l,int h,Map<Integer,Integer> map){
        int pivot=l,i=l,j=h;
        while(i<j){
            do{
                ++i;
            }while(i<nums.length && map.get(nums[i])>=map.get(nums[pivot]));
            do{
                --j;
            }while(j>=0 && map.get(nums[j])<map.get(nums[pivot]));
            if(i>j) break;
            int temp1=nums[i];
            nums[i]=nums[j];
            nums[j]=temp1;
        }
        int temp2=nums[pivot];
        nums[pivot]=nums[j];
        nums[j]=temp2;
        return j;
    }
}

File: 973. K Closest Points to Origin.txt
Question Type: Selection
DSA Question: DSA problem related to: 973. K Closest Points to Origin
----------------------
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        helper(points,K,0,points.length);
        int[][] result=new int[K][2];
        for(int i=0;i<K;++i){
            result[i][0]=points[i][0];
            result[i][1]=points[i][1];
        }
        return result;
    }
    
    void helper(int[][] nums, int k,int l,int h){
            int pivot=partition(nums,l,h);
            if(pivot==k-1){
                return ;
            }
            else if(k-1<pivot){
                 helper(nums,k,l,pivot);
            }else{
                 helper(nums,k,pivot+1,h);                
            }
    }
    
    int partition(int[][] nums,int l,int h){
        int[] pivot=nums[l];
        int i=l,j=h;
        while(i<j){
            do{
                ++i;
            }while(i<nums.length && getEuclideanDistance(nums[i])<=getEuclideanDistance(pivot));

            do{
               --j; 
            }while(getEuclideanDistance(nums[j])>getEuclideanDistance(pivot));
            if(i>j){
                break;
            }else{
                int[] temp1=nums[j];
                nums[j]=nums[i];
                nums[i]=temp1;
            }
        }
        int[] temp2=nums[j];
        nums[j]=pivot;
        nums[l]=temp2;  
        return j;
    }
    
    
    Double getEuclideanDistance(int ob[]){
        int x=ob[0],y=ob[1];
        int compute=x*x+y*y;
        return Math.sqrt(compute);
    }

}



File: ReverseStack.txt
Question Type: Stack
DSA Question: DSA problem related to: ReverseStack
----------------------
import java.util.Stack;

/* 1       5
 2       4
 3       3
 4       2
 5       1 
 
   
*/
class ABR{
	void reverse(Stack<Integer> s){
		if(s.isEmpty()) return;
		int pop=s.pop();
		reverse(s);
		insertAtBottom(s,pop);
	}
	private void insertAtBottom(Stack<Integer> s, int val){
		if(s.isEmpty()){
			s.push(val);
			return;
		}
		int pop=s.pop();
		insertAtBottom(s,val);
		s.push(pop);
	}

}


File: MinStack.txt
Question Type: Stack
DSA Question: DSA problem related to: MinStack
----------------------
/*
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
*/
class Node {
    Integer val; 
    Node next; 
    public Node(){} 
    public Node(Integer val){this.val=val;}
}

class MinStack {
    int size=0;
    Node top1=new Node(); 
    Node top2=new Node(Integer.MAX_VALUE); 

    public MinStack() {
        
    }
    
    public void push(int x) {
        Node newNode=new Node(x);
        newNode.next=top1; top1=newNode;
        Node newMinNode=new Node(Math.min(x,top2.val));
        newMinNode.next=top2; top2=newMinNode;
        ++size;
    }
    
    public void pop() {
        top1=top1.next; top2=top2.next; --size;
    }
    
    public int top() {
        return top1.val;
    }
    
    public int getMin() {
        return top2.val;
    }
}


File: StackUsingQueue.txt
Question Type: Stack
DSA Question: DSA problem related to: StackUsingQueue
----------------------
class MyStack {
    Queue<Integer> topCarrier,restCarrier;
    public MyStack() {
        topCarrier=new LinkedList<>();
        restCarrier=new LinkedList<>();
        
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        if(topCarrier.isEmpty()){
            topCarrier.add(x);
        }else{
            while(!topCarrier.isEmpty()){
                restCarrier.add(topCarrier.poll());
            }
            topCarrier.add(x);
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        int top=topCarrier.poll();
        while(restCarrier.size()>=2){
            topCarrier.add(restCarrier.poll());
        }
        Queue<Integer> temp=topCarrier;
        topCarrier=restCarrier;
        restCarrier=temp;
        return top;
    }
    
    /** Get the top element. */
    public int top() {
        return topCarrier.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return topCarrier.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */

File: LargestAreaInHistogram.txt
Question Type: Stack
DSA Question: DSA problem related to: LargestAreaInHistogram
----------------------
/*
Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, 
find the area of largest rectangle in the histogram.
*/
class Solution {
    Stack<Integer> stack=new Stack<Integer>();
    int maxArea=0;
    public int largestRectangleArea(int[] heights) {
        stack.push(-1);
        for(int i=0;i<heights.length;++i){
            while(stack.peek()!=-1 && heights[stack.peek()]>=heights[i]){
                maxArea=Math.max(maxArea,heights[stack.pop()]*(i-(stack.peek()+1)));
            }
            stack.push(i);
        }
        while(stack.peek()!=-1){
            maxArea=Math.max(maxArea,heights[stack.pop()]*(heights.length-(stack.peek()+1)));
        }
        return maxArea;
    }
}
//*********************************8
class Solution {   //Revised One
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> s=new Stack<>();
        s.push(-1);
        int maxArea=0;
        for(int i=0;i<heights.length;++i){
            while(s.peek()!=-1 && heights[s.peek()]>=heights[i]){// 1 2 3 4 for decreasing 3
                maxArea=Math.max(maxArea,heights[s.pop()]*(i-(s.peek()+1))); // calculate for (4<-)  , (4 & 3<-) , (2<-,3,4)   (1<-,2,3,4)
            }
            s.push(i);
        }
        while(s.peek()!=-1){ // for increasing 1 2 3 4 5 6 7
            maxArea=Math.max(maxArea,heights[s.pop()]*(heights.length-(s.peek()+1)));
        }
        return maxArea;
        
    }
}


class Solution {//Faulty
    public int largestRectangleArea(int[] arr) {
        if(arr.length==0) return 0;
        int largestArea=arr[0]*1;
        Stack<Integer> stack=new Stack<>();
        stack.push(0);
        for(int i=1;i<arr.length;++i){
                while(!stack.isEmpty()&&arr[i]<=arr[stack.peek()]){
                    int pop=stack.pop();
                    int area=stack.isEmpty()?arr[pop]*(i-0):arr[pop]*(i-pop);
                    largestArea=Math.max(largestArea,area);
                }
            stack.push(i);
        }
        while(!stack.isEmpty()){
           int pop=stack.pop();
           int area=stack.isEmpty()?arr[pop]*(arr.length-0):arr[pop]*(arr.length-pop);
           largestArea=Math.max(largestArea,area);
        }
        return largestArea;
    }
}



File: InfixExpressionEval.txt
Question Type: Stack
DSA Question: DSA problem related to: InfixExpressionEval
----------------------
class Solution {
    public int calculate(String s) {
        Stack<Integer> numbers=new Stack<>();
        Stack<Character> operators=new Stack<>();
        Boolean isPrevInt=false;
        for(char c:s.toCharArray()){
            if(c==' ') continue;
            if(c>='0' && c<='9'){
                if(isPrevInt){
                    int prev=numbers.pop();
                    numbers.push(prev*10+(c-'0'));
                }else{
                    numbers.push(c-'0');
                }
                isPrevInt=true;
            }else if(c=='('){
                operators.push(c);
                isPrevInt=false;
            }
            else if(c=='-'|| c=='+'){
                while(!operators.isEmpty() && operators.peek()!='('){
                    char oper=operators.pop();
                    int b=numbers.pop();
                    int a=numbers.pop();
                    if(oper=='+'){
                        numbers.push(a+b);
                    }else{
                        numbers.push(a-b);
                    } 
                }
                operators.push(c);
                isPrevInt=false;
            }
            else if(c==')'){
                while(operators.peek()!='('){
                    char oper=operators.pop();
                    int b=numbers.pop();
                    int a=numbers.pop();
                    if(oper=='+'){
                        numbers.push(a+b);
                    }else{
                        numbers.push(a-b);
                    }
                }
                operators.pop();  
                isPrevInt=false;
            }
        }
        while(numbers.size()!=1){
            char oper=operators.pop();
            int b=numbers.pop();
            int a=numbers.pop();
            if(oper=='+'){
                numbers.push(a+b);
            }else{
                numbers.push(a-b);
            }
        }
        return numbers.peek();
    }
}

File: StockSpanner.txt
Question Type: Stack
DSA Question: DSA problem related to: StockSpanner
----------------------
class StockSpanner {
    Stack<Integer> stack=new Stack<>();
    HashMap<Integer,Integer> map=new HashMap<>();
    int index=-1;
    public StockSpanner() {
        
    }
    
    public int next(int price) {
        ++index;map.put(index,price);
        int span=1;
        if(index!=0){
            while(!stack.isEmpty() && map.get(stack.peek())<=price){
                stack.pop();
            }
            span=stack.isEmpty()?index+1:index-stack.peek();
        }
        stack.push(index);
        return span;
    }
}

/**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner obj = new StockSpanner();
 * int param_1 = obj.next(price);
 */

File: StockSpan.txt
Question Type: Stack
DSA Question: DSA problem related to: StockSpan
----------------------
/*
import java.util.Stack;

class ABR{
	static void calculateSpan(int arr[], int n, int span[])
	{
		span[0]=1;
		Stack<Integer> stack=new Stack<>();
		stack.push(0);
		for(int i=1;i<arr.length;++i){
			while(!stack.isEmpty()&&arr[stack.peek()]<=arr[i]){
				stack.pop();
			}
			span[i]=stack.isEmpty()?(i-0+1):(i-stack.peek());
			stack.push(i);
		}
	}
}
*/


File: ValidParentheses.txt
Question Type: Stack
DSA Question: DSA problem related to: ValidParentheses
----------------------
/*
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.
*/
class ValidParentheses {
    public  boolean isValid(String s) {
        HashMap<Character,Character> map=new HashMap<>();
        map.put('(',')');
        map.put('{','}');
        map.put('[',']');
        char[] arr=s.toCharArray();
        if(arr.length==0) return true;
        Stack<Character> stack=new Stack<>();
        stack.push(arr[0]);
        for(int i=1;i<arr.length;++i){
            Character top=stack.isEmpty()?null:stack.peek();
            if(top !=null && isOpenBracket(top) && !isOpenBracket(arr[i])){
                if(map.get(top).equals(arr[i])){
                    stack.pop();
                }else {
                    return false;
                }
            }
            else {
                stack.push(arr[i]);
            }
        }
        return stack.isEmpty();
    }
     boolean isOpenBracket(char c){
        if(c=='('||c=='{'||c=='[')
            return true;
        return false;
    }
}

File: MaximumContiguousSubsequence.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MaximumContiguousSubsequence
----------------------
import java.lang.Math;


class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==0) return 0;
        int ans=nums[0];
        int start =0,end=0;
        int tillHere=nums[0];
        for(int i=1;i<nums.length;++i){
            if(tillHere+nums[i]<nums[i]){
                start=i;
            }
            tillHere=Math.max(tillHere+nums[i],nums[i]);
            if(tillHere<=0){
                start=i+1;
            }
            if(ans<tillHere){
                end=i;
            }
            ans=Math.max(ans,tillHere);
            
        }
        System.out.println(start+" ->"+ end);
        return ans;
    }
}


public class MaximumContiguousSubsequence{ // 

   	int max=Integer.MIN_VALUE;
  	public int maxSubArray(int[] nums) {
        	 helper(nums, nums.length-1);
        	 return max;
  	}

    	int helper(int[] nums,int h){
      		 if(h==0) return max= nums[0];
     		 int currMax=Math.max(nums[h],nums[h]+helper(nums,h-1));
       		 max=Math.max(max,currMax);
       		 return currMax;
    	}


	static int MCS(int arr[]){ //o(n2)
		int maxSum=Integer.MIN_VALUE;
		for(int i=0;i<arr.length;++i){
			int sum=0;
			for(int j=i;j<arr.length;++j){
				sum=sum+arr[j];
				maxSum=Math.max(maxSum,sum); // capture every max value
			}
		}
		return maxSum;
	}

	static int MCSLinear(int arr[]){ //o(n)
		
		int [] A=new int[arr.length];
		A[0]=arr[0];
		int maxSum=arr[0];
		for(int i=1;i<arr.length;++i){
			A[i]=Math.max(arr[i]+A[i-1],arr[i]);
			maxSum=Math.max(maxSum,A[i]); // capture every max value

		}
		return maxSum;
	}

    static int solve(String S){ // linear revised
        char[] A=S.toCharArray();
        HashMap<Character,Integer> map=new HashMap<>();
        map.put('A',-1);
        map.put('C',1);
        int[] M=new int[S.length()];
        M[0]=map.get(A[0]);
        int maxSum=map.get(A[0]);
        for(int i=1;i<A.length;++i){
            M[i]=Math.abs(map.get(A[i]))>Math.abs(M[i-1]+map.get(A[i]))?map.get(A[i]):M[i-1]+map.get(A[i]);
            maxSum=Math.abs(maxSum)>Math.abs(M[i])?maxSum:M[i];
        }
        maxSum=Math.abs(maxSum);
        return maxSum;
    }
	
	public static void main(String args[]){
		int arr[]={-2,11,-4,13,-5,2};	//20	
		
		System.out.println("Max Value of Contiguous Subsequence using o(n2) - "+MCS(arr));
		System.out.println("Max Value of Contiguous Subsequence using o(n) - "+MCSLinear(arr));

	}
}

File: NumberOfDistinctSubSequence.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: NumberOfDistinctSubSequence
----------------------
int numberOfDistinctSubSequqnce(String p,String t){
    int[][] memo=new int[p.length+1][t.length+1];
    for(int i=0;i<=t.length;++i){
        memo[0][i]=1;
    }
    for(int i=1;i<=p.length;++i){
        char pc=p.charAt(i-1);
        for(int j=1;j<=t.length;++j){
            char tc=t.charAt(j-1);
              if(tc==pc){
                    memo[i][j]=memo[i-1][j-1]+memo[i][j-1];	
            }else{
                memo[i][j]=memo[i][j-1];
            }
            
        }  
    }
    
    return memo[memo.length-1][memo[0].length-1];
}


File: CoinExchange.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: CoinExchange
----------------------
class Solution {
  int maxCoins;
    public int coinChange(int[] coins, int amount) {
      Integer[][] memo=new Integer[amount+1][coins.length];
      int result=helper(coins,amount,0,memo);
      return result==Integer.MAX_VALUE?-1:result;
    }

    int helper(int[] coins,int amount,int index,Integer[][] memo){
      if(index>=coins.length || amount<0) return Integer.MAX_VALUE;
      if(amount==0) return 0;
      if(memo[amount][index]!=null) return memo[amount][index];
      int include=helper(coins,amount-coins[index],index,memo);
      if(include!=Integer.MAX_VALUE){
        include=include+1;
      }
      int exclude=helper(coins,amount,index+1,memo);
      return memo[amount][index]=Math.min(include,exclude);
    }
}

class Solution {
    Integer[] memo;
    public int coinChange(int[] coins, int amount) {
        memo=new Integer[amount+1];
        return helper(coins,amount);
    }
    
    int helper(int coins[],int amount){
        if(amount<0)return -1;
        if(memo[amount]!=null) return memo[amount];
        if(amount==0)return memo[amount]=0;
        int coinCount=Integer.MAX_VALUE;
        for(int i=0;i<coins.length;++i){
            if(coins[i]<=amount){
                int ahead=helper(coins,amount-coins[i]);
                if(ahead>=0 && ahead<coinCount){
                    coinCount=1+ahead;
                }
            }
        }
        if(coinCount==Integer.MAX_VALUE){
            return memo[amount]=-1;
        }
        return memo[amount]=coinCount;
    }
}


class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount<1) return 0;
        int[] memo=new int[amount+1];
        memo[0]=0;
        for(int i=1;i<memo.length;++i){
            memo[i]=amount+1;
        }
        for(int i=0;i<=amount;++i){//amount 5
            for(int j=0;j<coins.length;++j){//coins 2
                if(i>=coins[j]){
                    memo[i]=Math.min(memo[i],1+memo[i-coins[j]]);                    
                }
            }
        }
        return memo[amount]>amount?-1:memo[amount];
    }
}



File: MaximalSquare.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MaximalSquare
----------------------
//Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.
class Solution {
    public int maximalSquare(char[][] matrix) {
        if(matrix.length==0) return 0;
        int[][] memo=new int[matrix.length+1][matrix[0].length+1];
        int squareSize=0;
        for(int i=1;i<memo.length;++i){
            for(int j=1;j<memo[0].length;++j){
                if(matrix[i-1][j-1]=='1'){
                    memo[i][j]=Math.min(Math.min(memo[i-1][j-1],memo[i-1][j]),memo[i][j-1])+1;
                    squareSize=Math.max(squareSize,memo[i][j]);
                }
            }
        }
        return squareSize*squareSize;
    }
}

File: LongestPalindromicSubSequence.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: LongestPalindromicSubSequence
----------------------
/*
Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.
*/
class Solution {
    Integer memo[][];
    public int longestPalindromeSubseq(String s) {
        if(s.length()==0) return 0;
        memo=new Integer[s.length()][s.length()];
        return helper(s,0,s.length()-1);
    }
    
    int helper(String s,int l,int h){
        if(l>h) return 0;
        if(memo[l][h]!=null) return memo[l][h];
        if(l==h) {
            return memo[l][h]=1;
        }
        if(s.charAt(l)==s.charAt(h)){
            return memo[l][h]=2+helper(s,l+1,h-1);
        }else{
            return memo[l][h]=Math.max(helper(s,l,h-1),helper(s,l+1,h));
        }
    }
}

File: UniquePathRobot.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: UniquePathRobot
----------------------
/*
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the 
bottom-right corner of the grid (marked 'Finish' in the diagram below).
Now consider if some obstacles are added to the grids. How many unique paths would there be?
*/
class Solution {
    Integer memo[][];
    public int uniquePathsWithObstacles(int[][] arr) {
        memo=new Integer[arr.length+1][arr[0].length+1];
        return helper(arr,0,0);
    }
    
    int helper(int[][] arr,int i,int j){
        if(arr[i][j]==1){ return 0;} 
        else if(i==arr.length-1 && j==arr[0].length-1) {return 1;}
        else if (memo[i][j]!=null) return memo[i][j];
        int way=0;
        if(i+1<arr.length){
            way=way+helper(arr,i+1,j);
        }
        if(j+1<arr[0].length){
            way=way+helper(arr,i,j+1);     
        }
        memo[i][j]=way;
        return memo[i][j];
        
    }
}

class Solution {
    Integer[][] memo;
    public int uniquePathsWithObstacles(int[][] grid) {
        memo=new Integer[grid.length][grid[0].length];
        return helper(grid,0,0);
    }
    
    int helper(int[][] grid,int i,int j){
        if(i>grid.length-1||j>grid[0].length-1) return 0;
        if(memo[i][j]!=null) return memo[i][j];
        if(grid[i][j]==1) return memo[i][j]=0;
        if(i==grid.length-1 && j==grid[0].length-1){
            return memo[i][j]=1;
        }
        int count=0;
        count=count+helper(grid,i+1,j);
        count=count+helper(grid,i,j+1);
        return memo[i][j]=count;
    }
}

File: CombinationSum.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: CombinationSum
----------------------
/*
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), 
find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
*/
class Solution {
    
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result=new ArrayList<>();
        helper(candidates,0,target,result,new ArrayList<Integer>());
        return result; 
    }
    
    void helper(int[] arr,int index,int target,List<List<Integer>> result,List<Integer> temp){
        if(target<0) return;
        if(target==0){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i]){
                temp.add(arr[i]);
                helper(arr,i,target-arr[i],result,temp);
                temp.remove(temp.size()-1);
            }
        }
    }
}

File: LongestCommonSubsequence.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: LongestCommonSubsequence
----------------------
class Solution {
    
    public int longestCommonSubsequence(String text1, String text2) {
        int result[][]=new int[text1.length()+1][text2.length()+1];
        for(int i=text1.length()-1;i>=0;--i){
            for(int j=text2.length()-1;j>=0;--j){
                if(text1.charAt(i)==text2.charAt(j)){
                    result[i][j]= 1+result[i+1][j+1];
                }else{
                    result[i][j]= Math.max(result[i+1][j],result[i][j+1]);
                }
            }
        }
        return result[0][0];
    }
}

class Solution {
    Integer[][] memo;
    public int longestCommonSubsequence(String text1, String text2) {
        memo=new Integer[text1.length()][text2.length()];
        return helper(text1,text2,0,0);
    }
    
    int helper(String text1,String text2,int n,int m){
        if(n==text1.length()|| m==text2.length()) return 0;
        if(memo[n][m]!=null) return memo[n][m];
        if(text1.charAt(n)==text2.charAt(m)){
            return memo[n][m]=1+helper(text1,text2,n+1,m+1);
        }
        return memo[n][m]=Math.max(helper(text1,text2,n,m+1),helper(text1,text2,n+1,m));
    }
}

class Solution {
    
    public int longestCommonSubsequence(String text1, String text2) {
        Integer result[][]=new Integer[text1.length()+1][text2.length()+1];
       return helper(text1.toCharArray(),text2.toCharArray(),text1.length()-1,text2.length()-1,result) ;
    }
    
    int helper(char arr1[],char arr2[], int i1,int i2,Integer result[][]){
        if(i1<0 || i2<0){ return 0;}
        if(result[i1][i2]!=null) return result[i1][i2];
        else if(arr1[i1]==arr2[i2]){
           result[i1][i2]= 1+helper(arr1,arr2,i1-1,i2-1,result); 
        }else{
           result[i1][i2]= Math.max(helper(arr1,arr2,i1-1,i2,result),helper(arr1,arr2,i1,i2-1,result));
        }
        return result[i1][i2];
    }
}

File: Factorial.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: Factorial
----------------------
public class Factorial{
	static int factorial(int n){
		if(n==0 || n==1) return 1;
		return n*factorial(n-1);
	}

	public static void main(String args[]){
		System.out.print("factorial of 5 is :  "+factorial(5));
	}
}

File: Fibonacii.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: Fibonacii
----------------------
public class Fibonacii{
	static int fibonacii(int n){
		if(n==0)return 0;
		if(n==1) return 1;
		return fibonacii(n-1)+fibonacii(n-2);
	}

	public static void main(String args[]){
		System.out.print("fibonacii of 8 is :  "+fibonacii(8));
	}
}

File: MinDistance.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MinDistance
----------------------
class Solution {
    Integer[][] arr;
    public int minDistance(String word1, String word2) {
        arr=new Integer[word1.length()+1][word2.length()+1];
        return helper(word1,word1.length(),word2,word2.length());
    }
    
    
    int helper(String word1,int i1,String word2,int i2){
        if(arr[i1][i2]!=null) return arr[i1][i2];
        if(i1==0) return arr[i1][i2]=i2;
        if(i2==0) return arr[i1][i2]=i1;
        if(word1.charAt(i1-1)==word2.charAt(i2-1)){
            return arr[i1][i2]=helper(word1,i1-1,word2,i2-1);
        }else{
            return arr[i1][i2]=1+ Math.min(helper(word1,i1,word2,i2-1), //insetion
                    Math.min(helper(word1,i1-1,word2,i2), //deletion
                             helper(word1,i1-1,word2,i2-1))); //replace
        }
    }
}

File: MinimumPathSum.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MinimumPathSum
----------------------
/*
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the
sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
*/
class Solution {
    Integer[][] memo;
    public int minPathSum(int[][] grid) {
        memo=new Integer[grid.length+1][grid[0].length+1];
        if(grid.length==0) return 0;
        return helper(grid,0,0);
    }
    
    int helper(int[][] grid,int i,int j){
        if(memo[i][j]!=null) return memo[i][j];
        if(i==grid.length || j==grid[0].length) return  memo[i][j]= Integer.MAX_VALUE;
        if(i==grid.length-1 && j==grid[0].length-1) {
            return memo[i][j]=grid[i][j]; 
        }   
        return  memo[i][j]=grid[i][j]+Math.min(helper(grid,i+1,j),helper(grid,i,j+1));
    }
}

File: JumpGame.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: JumpGame
----------------------
/*
Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
*/

class Solution {
    public boolean canJump(int[] nums) {
        int lastGood=nums.length-1;
        for(int i=nums.length-1;i>=0;--i){
            if(i+nums[i]>=lastGood){
                lastGood=i;
            }    
        }
        return lastGood==0;
    }
}

class Solution {
    Boolean result[]=null;
    public boolean canJump(int[] nums) {
        result=new Boolean[nums.length+1];
        return helper(nums,0);
    }
    
    boolean helper(int[] nums,int i){
        if(i==nums.length-1) return true;
        if(result[i]!=null) return result[i];
        for(int j=1;j<=nums[i];++j){
            if(helper(nums,i+j)) return result[i]=true;
        }
        return result[i]=false;
    }
}

class Solution {
    boolean memo[];
    public boolean canJump(int[] nums) {
        memo=new boolean[nums.length];
        memo[nums.length-1]=true;
        for(int i=nums.length-2;i>=0;--i){
            for(int j=1;j<=nums[i];++j){
                if(i+j<nums.length && memo[i+j]==true){
                    memo[i]=true;
                    break;
                }
            }
        }
        return memo[0];
    }
}



File: ClimbStairs.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: ClimbStairs
----------------------
class Solution {
    Integer[] ways;
    public int climbStairs(int n) {
        ways=new Integer[n+1];
        ways[0]=0;
        if(n<3) return n;
        ways[1]=1;
        ways[2]=2;
        for(int i=3;i<=n;++i){
            ways[i]=ways[i-1]+ways[i-2];
        }
        return ways[n];
    }
}

class Solution {
    Integer counter[]=null;
    public int climbStairs(int n) {
        counter=new Integer[n+1];
        return help(n);
    }
    
    public int help(int n){
        if(n<0)return 0;
        if(counter[n]!=null) return counter[n];
        if(n==0) return counter[n]=1;
        return counter[n]=(help(n-2)+help(n-1));
    }
}


File: DP Revision Notes.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: DP Revision Notes
----------------------
Solved List:-
1)Factorial -------------------- fact(n)=n*fact(n-1); (n=0 || n=1)->1
2)Fibonaci --------------------- fibonaci(n)=fibonaci(n-1)+fibonaci(n-2); 
3)Longest Common SubString ----- LCS(char[] arr1,char[] arr2,arr1.length-1,arr2.length-1)=
					arr1[i1]==arr[i2] -->1+LCS(arr1,arr2,i1-1,i2-1);
					else
					Max(LCS(arr1,arr2,i1-1,i2),LCS(arr1,arr2,i1,i2-1));
				
4)Maximum continuous Sub Array - MCS(int [] arr,arr.length-1) =
					max(arr[i],MCS(arr,i-1));
5)Longest Increasing SubArray  - Max(LIS[])  -> where -> LIS[i]=1+max(LIS[j]) where  (0>=j<i)
6)Coin Change ------------------ minCoinChange(int [] coins,amount) ->
					        for(j=0->coins.length){
						result[amount] = Math.min( result[amount] , minCoinChange( coins,amount-coins[j])
						}	
					//here we are repeating this for different amount leift
7)KnapSAck --------------------- take one item or not - total two decisions required
					//here we are repeating for different weight left
					//also we are pickig one item only once

File: CombinationSumII.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: CombinationSumII
----------------------
/*
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
*/
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> result=new ArrayList<>();
        helper(candidates,0,target,result,new ArrayList<Integer>());
        return result;
    }
    
    void helper(int[] arr,int index,int target,List<List<Integer>> result,List<Integer> selected){
        if(target<0){
          return;   
        }
        if(target==0){
            result.add(new ArrayList<>(selected));
            return;
        }
        for(int i=index;i<arr.length;++i){
            if(target>=arr[i] && (i==index || arr[i]!=arr[i-1])){
                selected.add(arr[i]);
                helper(arr,i+1,target-arr[i],result,selected);
                selected.remove(selected.size()-1);
            }
        }
    }
}

File: DivisorGame.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: DivisorGame
----------------------
/*
Alice and Bob take turns playing a game, with Alice starting first.
Initially, there is a number N on the chalkboard.  On each player's turn, that player makes a move consisting of:
Choosing any x with 0 < x < N and N % x == 0.
Replacing the number N on the chalkboard with N - x.
Also, if a player cannot make a move, they lose the game.
Return True if and only if Alice wins the game, assuming both players play optimally.
 */
// Java program for implementation of
// optimal strategy for the divisor
// game using dynamic programming

public class DivisorGame {

    public static boolean divisorGame(int N) {
        Boolean[] memo =new Boolean[N+1];
        return canWin(N,memo);
    }

    static boolean canWin(int N,Boolean[] memo) {
        if(memo[N]!=null)return memo[N];
        if (N <= 1)
            return memo[N]=false;
        for (int i = 1; i * i <= N && N%i==0; i++) {
            if(!canWin(N-i,memo)){
                return memo[N]=true;
            }
        }
        return memo[N]=false;
    }

    public static void main(String[] args) {
        int N = 3;
        if (divisorGame(N))
            System.out.print("yes you can");
        else
            System.out.print("other will win");
    }
}



File: SubSetSumExistOrNot.txt
Question Type: KnapSack 01
DSA Question: DSA problem related to: SubSetSumExistOrNot
----------------------
public class SubSetSumExistOrNot {
    boolean subsetSumExist(int[] arr,int sum){
        return helper(arr,sum,0);
    }

    helper(int[] arr,int sum,int index){
        if(index>=arr.length || sum<0) return false;
        if(sum==0) return true;
        boolean exist=false;
        if(arr[index]<=sum){
            exist=helper(arr,sum-arr[index],index+1);
        }
        if(exist) return true;
        return helper(arr,sum,index+1);
    }
}

public class SubSetSumExistOrNot {
    boolean subsetSumExist(int[] arr,int sum){
        if(sum==0) return true;
        if(sum<0 || arr.length==0) return false;
        boolean[][] memo=new boolean[arr.length][sum+1];
        for(int i=0;i<arr.length;++i){
            memo[i][0]=true;
        }
        for(int w=1;w<sum+1;++w){
            if(arr[0]==w){
                memo[0][w]=true;
            }
        }
        for(int i=1;i<arr.length;++i){
            for(int w=1;w<sum+1;++w){
                boolean result=false;
                if(arr[i]<=w){
                    result=memo[i-1][w-arr[i]];
                }
                memo[i][w]=result||memo[i-1][w];
            }
        }
        return memo[arr.length-1][sum];
    }
}


File: KnapSack.txt
Question Type: KnapSack 01
DSA Question: DSA problem related to: KnapSack
----------------------
class Knapsack { 
	static int helper(int val[],int wt[],int weight,int i){
      	if(i<0) return 0;
        if(wt[i]>weight ) return 0;
      	return Math.max(helper(val,wt,weight,i-1),val[i]+helper(val,wt,weight-wt[i],i-1));
      	
    }  


	public static void main(String args[]) 
	{ 
		int val[] = new int[] { 60, 100, 120 }; 
		int wt[] = new int[] { 10, 20, 30 }; 
		int W = 50; 
		int n = val.length; 
		System.out.println(helper(val,wt,W,n-1));
	} 
} 

File: CountOfSubSetSum.txt
Question Type: KnapSack 01
DSA Question: DSA problem related to: CountOfSubSetSum
----------------------
public class CountOfSubSetSum {
    
    int countOfSubSetSum(int[] arr,int sum){
        return helper(arr,sum,0);
    }

    helper(int[] arr,int sum,int index){
        if(index>=arr.length || sum<0) return 0;
        if(sum==0) return 1;
        int count=0;
        if(arr[index]<=sum){
            count=helper(arr,sum-arr[index],index+1);
        }
        return count+helper(arr,sum,index+1);
    }
}

public class CountOfSubSetSum {
    
    int countOfSubSetSum(int[] arr,int sum){
        if(sum==0 || arr.length==0) return 0;
        Integer[][] memo=new Integer[arr.length][sum+1];
        for(int i=0;i<arr.length;++i){
            memo[i][0]=1;
        }
        for(int w=1;w<sum+1;++w){
            if(arr[i]==sum)
            memo[0][w]=1;
        }
        for(int i=1;i<arr.length;++i){
            for(int w=1;w<sum+1;++w){
                int count=0;
                if(arr[i]<=w){
                    count=memo[i-1][w-arr[i]];
                }
                count=count+memo[i-1][w];
                memo[i][w]=count;
            }
        }
        return memo[arr.length-1][sum];
    }
}

File: WordBreak.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: WordBreak
----------------------
class Solution { //Faulty Code first attempt
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set=new HashSet<>();
        wordDict.forEach(word->{
          set.add(word);  
        });
        int l=0,h=0;
        int lastFoundindex=-1;
        while(h<s.length()){
            String subString=s.substring(l,h+1);
            if(set.contains(subString)){
                lastFoundindex=h;
                l=h+1;
                ++h;
            }else{
                ++h;
            }
        }
        return lastFoundindex==s.length()-1;
    }
}

class Solution {
    Boolean[] memo;
    public boolean wordBreak(String s, List<String> wordDict) {
        memo=new Boolean[s.length()+1];
        return helper(new HashSet(wordDict),s,0);
    }
    
    boolean helper(Set<String> set,String s,int start){
        if(memo[start]!=null) return memo[start];
        if(start==s.length()) return true;
        for(int end=start;end<s.length();++end){
            if(set.contains(s.substring(start,end+1)) && helper(set,s,end+1)){
                return true;
            }
        }
        return memo[start]=false;
    }
}

class Solution {
    HashMap<String,Boolean> map=new HashMap<>();
    public boolean wordBreak(String s, List<String> wordDict) {
        if(map.containsKey(s)) return map.get(s);
        if(s.length()==0){
            map.put(s,true);
            return true; 
        }
        Set<String> set=new HashSet(wordDict);
        for(int h=0;h<s.length();++h){
            if(set.contains(s.substring(0,h+1)) && wordBreak(s.substring(h+1,s.length()),wordDict)){
                map.put(s,true);
                return true;
            }            
        }
        map.put(s,false);
        return false;
    }
}


File: LIS.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: LIS
----------------------
class Solution {
    public int lengthOfLIS(int[] nums) {
        int LIS[]=new int[nums.length];
        if(nums.length==0) return 0;
        LIS[0]=1;
        for(int i=1;i<nums.length;++i){
            LIS[i]=1;
            for(int j=0;j<i;++j){
                if(nums[j]<nums[i]){
                   LIS[i]=Math.max(LIS[i],LIS[j]+1); 
                }
            }
        }
        int result=Integer.MIN_VALUE;
        for(int i=0;i<LIS.length;++i){
            result=Math.max(result,LIS[i]);
        }
        return result;
    }
}

class Solution {
    int[] LIS;
    public int lengthOfLIS(int[] nums) {
        LIS=new int[nums.length+1];
        for(int j=0;j<nums.length;++j){
            LIS[j]=1;
        }
        for(int i=1;i<nums.length;++i){
            helper(nums,i);
        }
        int lis=Integer.MIN_VALUE;
        for(int j=0;j<LIS.length;++j){
            lis=Math.max(lis,LIS[j]);
        }
        return lis;
    }
    
    void helper(int[] nums,int i){
        for(int j=0;j<i;++j){
           if(nums[i]>nums[j]){
               LIS[i]=Math.max(LIS[i],1+LIS[j]);
           } 
        }
    }
}

File: MinimumCoinChange.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MinimumCoinChange
----------------------
class Solution {
   
    public int coinChange(int[] coins, int amount) {
         Integer [] arr=new Integer[amount+1];
        int result=  helper(coins,amount,arr);
        if(result==Integer.MAX_VALUE) return -1;
        return result;
    }
    
    int helper(int[] coins,int amount,Integer [] arr){
        if (amount < 0) return -1;
        if(arr[amount]!=null) return arr[amount];
        if(amount==0) return arr[amount]=0; 
        arr[amount]= Integer.MAX_VALUE;
        for(int i=0;i<coins.length;++i){
            if(coins[i]>amount) continue;
            arr[amount]=Math.min(arr[amount],helper(coins,amount-coins[i],arr));
        }
        arr[amount]=(arr[amount]==Integer.MAX_VALUE)?arr[amount]:arr[amount]+1;
        return arr[amount];
    }
}

File: JumpGameII.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: JumpGameII
----------------------
class Solution {   //Jump Games2              
    public int jump(int[] nums) {
        int jump=0;
        int maxPos=0;
        int nextIndex=0;
        for(int i=0;i<nums.length-1;++i){
            maxPos=Math.max(maxPos,i+nums[i]);
            if(i==nextIndex){
                nextIndex=maxPos;
                ++jump;
            }
        }
        return jump;
    }
}

class Solution {//Not optimal
    Integer memo[];
    public int jump(int[] nums) {
        memo=new Integer[nums.length+1];
        return helper(nums,0);
    }
    int helper(int[] nums,int index){
        if(index>=nums.length) return nums.length+1;
        if(memo[index]!=null) return memo[index];
        if(index==nums.length-1) return 0;
        int ans=nums.length+1;
        for(int i=nums[index];i>=1;--i){
            ans=Math.min(ans,1+helper(nums,index+i));
        }
        return memo[index]=ans;
    }
}



File: LongestPalindromeSubString.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: LongestPalindromeSubString
----------------------
/*
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
*/
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()<1 || s==null) return "";
        int left=0,right=0;
        for(int i=0;i<s.length();++i){
            int len1=lengthOfPalindromeExpandingFromCentreIndex(i,i,s);
            int len2=lengthOfPalindromeExpandingFromCentreIndex(i,i+1,s);
            int len=Math.max(len1,len2);
            if(right-left+1<len){
                left=i-(len-1)/2;
                right=i+len/2;
            }
        }
        return s.substring(left,right+1);
    }
    
    int lengthOfPalindromeExpandingFromCentreIndex(int center1,int center2,String s){
        if(center1>center2 || s==null) return 0;
        while(center1>=0 && center2<s.length() && s.charAt(center1)==s.charAt(center2)){
            --center1;
            ++center2;
        }
        return center2-center1-1;
    }
}


File: MaximumSubSequenceArrayRobber.txt
Question Type: DynamicProgramming
DSA Question: DSA problem related to: MaximumSubSequenceArrayRobber
----------------------
class Solution {
    public int rob(int[] nums) {
        if(nums.length==0) return 0;
        int A[]=new int[nums.length+1];
        A[0]=nums[0];
        if(nums.length==1) return A[nums.length-1];
        A[1]=Math.max(nums[0],nums[1]);
        for(int i=2;i<nums.length;++i){
            A[i]=Math.max(nums[i]+A[i-2],A[i-1]);
        }
        return A[nums.length-1];
    }
}

File: KnapSackUnlimtited.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: KnapSackUnlimtited
----------------------
class Solution {
    static int knapSack(int val[], int wt[], int capacity) {
      Integer[][] memo=new Integer[capacity+1][val.length];
      return helper(val,wt,capacity,0,memo);
    }
    static int helper(int[] val,int wt[],int capacity,int index,Integer[][] memo){
      if(capacity<0) return Integer.MIN_VALUE;
      if(index>=val.length || capacity==0) return 0;
      if(memo[capacity][index]!=null) return memo[capacity][index];
      int include=Integer.MIN_VALUE;
      if(capacity>=wt[index]){
          include=val[index]+helper(val,wt,capacity-wt[index],index,memo);
      }
      int exclude=helper(val,wt,capacity,index+1,memo);
      return memo[capacity][index]=Math.max(include,exclude);
    }
}

int maxProfit(int[] W,int[] P,int C){

	helper(W,P,C,0);
}

int helper(int[] W,int[] P,int C,int index){
	if(C<=0 || index>=W.length) return 0;
	if(memo[index][C]!=null) return memo[index][C];
	int profit1=0;
	if(C>=W[index]){
		profit1=P[index]+helper(W,P,C-W[index],index);
	}
	int profit2=helper(W,P,C,index+1);
	return Math.max(profit1,profit2);
}

int maxProfit(int[] W,int[] P,int C){
	if(C<=0 || W.length==0 || W.length!=P.length) return 0;
	Integer memo[][]=new Integer[W.length][C+1];
        for(int i=0;i<P.length;++i){
		memo[i][0]=0;
	}
	for(int i=0;i<P.length;++i){
		for(int w=1;w<C+1;++w){
			int profit1=0;
			if(W[i]<=w){
				profit1=P[i]+memo[i][w-W[i]];
			}
			int profit2=0;
			if(i>0){
				profit2=memo[i-1][w];
			}
			memo[i][w]=Math.max(profit1,profit2);
		}
	}
	return memo[W.length-1][C];
}


File: CoinChangeWays.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: CoinChangeWays
----------------------
/*
Denominations: {1,2,3}
Total amount: 5
Output: 5
Explanation: There are five ways to make the change for '5', here are those ways:
  1. {1,1,1,1,1} 
  2. {1,1,1,2} 
  3. {1,2,2}
  4. {1,1,3}
  5. {2,3}
  */
public class CoinChangeWays {
    Integer[][] memo;
    int coinChangeWays(int[] coins,int total){
        memo=new Integer[coins.length][total+1];
        return helper(coins,total,coins.length-1);
    }

    int helper(int[] coins,int total,int index){
        if(total==0) return 1;
        if(index==-1 || total<0) return 0;
        if(memo[index][total]!=null) return memo[index][total];
        int ways=0;
        if(coins[index]<=total){
            ways=helper(coins,total-coins[index],index);
        }
        return memo[index][total]=ways+helper(coins,total,index-1);
    }
}


File: CoinChangeMinCount.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: CoinChangeMinCount
----------------------
public class CoinChangeMinCount {
    Integer[][] memo;
    Integer max;
    int minCoinChangeCount(int[] coins,int total){
        memo=new Integer[coins.length][total+1];
        max=total+1;
        int ans=helper(coins,total,coins.length-1);
        if(ans>=max) return -1;
        return ans;
    }

    int helper(int[] coins,int total,int index){
        if(total==0) return 0;
        if(index==-1 || total<0) return max;
        if(memo[index][total]!=null) return memo[index][total];
        int count1=max;
        if(coins[index]<=total){
            int local=1+helper(coins,total-coins[index],index);
            count1=Math.min(count1,local);
        }
        int count2=helper(coins,total,index-1);
        return memo[index][total]=Math.min(count1,count2);
    }
}

File: MaximumRibbonCutCount.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: MaximumRibbonCutCount
----------------------
/*
n: 7
Ribbon Lengths: {2,3}
Output: 3
Explanation: Ribbon pieces will be {2,2,3}.
*/


int maxRibbonPieceCutCount(int[] valid,int length){
    int count=helper(valid,length,valid.length-1);
    if(count<0) return -1;
    return count;
}

int helper(int[] valid,int length,int index){
     if(length==0) return 0; 
     if(index==-1 || length<0) return -1;
     int count1=-1;
     if(valid[index]<=length){
         int temp=1+helper(valid,length-valid[index],index);
         if(temp>=0){
             count1=1+temp;
         }
     }
     int count2=helper(valid,length,index-1);
     return Math.max(count1,count2);
}

                            


File: RodCutting.txt
Question Type: KnapSackUnlimited
DSA Question: DSA problem related to: RodCutting
----------------------
int maxProfit(int[] L,int[] P,int length){
	helper(L,P,length,0);
}

int helper(int[] L,int[] P,int length,int index){
	if(length<=0 || index>=L.length) return 0;
	if(memo[index][length]!=null) return memo[index][length];
	int profit1=0;
	if(length>=L[index]){
		profit1=P[index]+helper(L,P,length-L[index],index);
	}
	int profit2=helper(L,P,length,index+1);
	return Math.max(profit1,profit2);
}


File: SetMatrixZeroes.txt
Question Type: Matrix
DSA Question: DSA problem related to: SetMatrixZeroes
----------------------
//Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.
class Solution {
    public void setZeroes(int[][] matrix) {
        boolean row=false,col=false;
        for(int i=0;i<matrix.length;++i){
            if(matrix[i][0]==0){
                col=true;
                break;
            }
        }
        for(int j=0;j<matrix[0].length;++j){
            if(matrix[0][j]==0){
                row=true;
                break;
            }
        }
            
        for(int i=0;i<matrix.length;++i){
            for(int j=0;j<matrix[0].length;++j){
              if(matrix[i][j]==0){
                    matrix[i][0]=0;
                    matrix[0][j]=0;
              }  
            }
        }
        for(int i=1;i<matrix.length;++i){
            for(int j=1;j<matrix[0].length;++j){
                  if(matrix[i][0]==0 || matrix[0][j]==0){
                      matrix[i][j]=0;
                  }  
            }
        }
        if(col){
            for(int i=0;i<matrix.length;++i){
                matrix[i][0]=0;
            }            
        }

        if(row){
            for(int j=0;j<matrix[0].length;++j){
                matrix[0][j]=0;
            }            
        }

    }  
}


class Solution {//Wrong Approach
    public void setZeroes(int[][] matrix) {
        for(int i=0;i<matrix.length;++i){
            for(int j=0;j<matrix[0].length;++j){
                if(matrix[i][j]==0){
                    Line(matrix,i,j);
                }
            }
        }
        
        for(int i=0;i<matrix.length;++i){
            for(int j=0;j<matrix[0].length;++j){
                if(matrix[i][j]==-1000000){
                    matrix[i][j]=0;
                }
            }
        }
    }
    
    void Line(int[][] matrix,int i,int j){
        for(int m=0;m<matrix.length;++m){
            if(m!=i && matrix[m][j]!=0){
                matrix[m][j]=-1000000;
            }
        }
        for(int m=0;m<matrix[0].length;++m){
            if(m!=j && matrix[i][m]!=0){
                matrix[i][m]=-1000000;
            }
        }
    }
}


File: TheGameOfLife.txt
Question Type: Matrix
DSA Question: DSA problem related to: TheGameOfLife
----------------------
/*
According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."

Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

Any live cell with fewer than two live neighbors dies, as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population..
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.
*/
class Solution {
    Boolean visited[][];
    int x[]={0,0,1,-1,-1,1,1,-1};
    int y[]={1,-1,0,0,1,-1,1,-1};
    public void gameOfLife(int[][] board) {
        visited=new Boolean[board.length][board[0].length];
        helper(board);
        restoreUpdateValues(board);
    }
    
    void restoreUpdateValues(int[][] board){
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]==-1){board[i][j]=0;}
                if(board[i][j]==2){board[i][j]=1;}
            }
        }        
    }
    
    void helper(int[][] board){
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(visited[i][j]==null){
                    DFS(board,i,j);      
                }
            }
        }
    }
    
    void DFS(int[][] board,int i,int j){
        visited[i][j]=true;
        int count=sourroundingOneCount(board,i,j);
        if(board[i][j]==1&&count<2){
            board[i][j]=-1;
        }else if(board[i][j]==1&&(count==2 || count==3)){
            board[i][j]=board[i][j];
        }else if(board[i][j]==1 && count>3){
            board[i][j]=-1;
        }else if(board[i][j]==0 && count==3){
            board[i][j]=2;
        }
        for(int m=0;m<x.length;++m){
            if(isSafe(board,i+x[m],j+y[m])){
                DFS(board,i+x[m],j+y[m]);
            }
        }
    }
    
    int sourroundingOneCount(int[][] board,int i,int j){
        int count=0;
        for(int m=0;m<x.length;++m){
            int currI=i+x[m]; int currJ=j+y[m];
            if(isSafeW(board,currI,currJ)){
                if(board[currI][currJ]==1 || board[currI][currJ]==-1) ++count;
            }
        }
        return count; 
    }
    
    boolean isSafeW(int[][] board,int i,int j){
        return (i>=0 && i<board.length) && (j>=0 && j<board[0].length);
    }
    boolean isSafe(int[][] board,int i,int j){
        return (i>=0 && i<board.length) && (j>=0 && j<board[0].length) && visited[i][j]==null;
    }
    
    
}

File: SearchMatrix.txt
Question Type: Matrix
DSA Question: DSA problem related to: SearchMatrix
----------------------
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix.length==0) return false;
        int i=0;
        int j=matrix[0].length-1;
        while(i<=matrix.length-1 && j>=0){
            if(matrix[i][j]==target) return true;
            else if(matrix[i][j]>target) j--;
            else if(matrix[i][j]<target) i++;
        }
        return false;
    }
}

File: CaptureRegions.txt
Question Type: Matrix
DSA Question: DSA problem related to: CaptureRegions
----------------------
/*
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.
*/
class Pair{
    public int i;
    public int j;
    
    public Pair(int i,int j){
        this.i=i;
        this.j=j;
    }
}
class Solution {
    public void solve(char[][] board) {
        if(board.length==0) return;
        List<Pair> list=new ArrayList<>();
        for(int i=0;i<board.length;++i){
            list.add(new Pair(i,0));
            list.add(new Pair(i,board[0].length-1));
        }
        for(int i=0;i<board[0].length;++i){
            list.add(new Pair(0,i));
            list.add(new Pair(board.length-1,i));
        }
        for(Pair pair:list){
            DFS(board,pair.i,pair.j);
        }
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]=='O'){
                 board[i][j]='X';                    
                }else if(board[i][j]=='#'){
                 board[i][j]='O';
                }
            }
        }
    }
    
    void DFS(char[][] board,int i,int j){
        if(board[i][j]!='O') return;
        int []x={0,0,1,-1};
        int []y={1,-1,0,0};
        board[i][j]='#';
        for(int m=0;m<x.length;++m){
            if(isSafe(board,i+x[m],j+y[m])){
                DFS(board,i+x[m],j+y[m]);
            }
        }
    }
    
    boolean isSafe(char[][] board,int i,int j){
        return i>=0 && i<board.length && j>=0 && j<board[0].length && board[i][j]=='O';
    }
}

File: RobotPathWithoutObstructuion.txt
Question Type: Matrix
DSA Question: DSA problem related to: RobotPathWithoutObstructuion
----------------------
/*
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
*/
class Solution {
    Integer memo[][];
    public int uniquePaths(int m, int n) {
        memo=new Integer[m][n];
        return helper(m,n,0,0);
    }
    
    int helper(int m,int n,int i,int j){
        if(i>=m || j>=n) return 0;
        if(i==m-1 && j==n-1) return 1;
        if(memo[i][j]!=null) return memo[i][j];
        int possibleWays=0;
        possibleWays=possibleWays+helper(m,n,i+1,j)+helper(m,n,i,j+1);
        return memo[i][j]=possibleWays;
    }
}

File: Flood Fill.txt
Question Type: Matrix
DSA Question: DSA problem related to: Flood Fill
----------------------
class Solution {
    /*
An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).

Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.

To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.

At the end, return the modified image.
    */
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        boolean visited[][] =new boolean[image.length][image[0].length];
        dfs(image,visited,sr,sc,image[sr][sc],newColor);
        return image;
    }
    
    void dfs(int[][] image,boolean visited[][], int x, int y, int colorToReplace,int newColor){
        image[x][y]=newColor;
        visited[x][y]=true;
        int[] xx={0,0,1,-1};
        int[] yy={1,-1,0,0};
        for(int i=0;i<xx.length;++i){
            if(!isSafe(image,visited,x+xx[i],y+yy[i],colorToReplace)) continue;
            dfs(image,visited,x+xx[i],y+yy[i],colorToReplace,newColor);
        }
        visited[x][y]=false;
    }
    
    boolean isSafe(int[][] image,boolean visited[][], int x, int y, int colorToReplace){
        return x>=0 && x<image.length && y>=0 && y<image[0].length && !visited[x][y] && 
            image[x][y]==colorToReplace;
    }
}

File: UniquePathRobot.txt
Question Type: Matrix
DSA Question: DSA problem related to: UniquePathRobot
----------------------
/*
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?
*/
class Solution {
    Integer memo[][];
    public int uniquePathsWithObstacles(int[][] arr) {
        memo=new Integer[arr.length+1][arr[0].length+1];
        return helper(arr,0,0);
    }
    
    int helper(int[][] arr,int i,int j){
        if(arr[i][j]==1){ return 0;} 
        else if(i==arr.length-1 && j==arr[0].length-1) {return 1;}
        else if (memo[i][j]!=null) return memo[i][j];
        int way=0;
        if(i+1<arr.length){
            way=way+helper(arr,i+1,j);
        }
        if(j+1<arr[0].length){
            way=way+helper(arr,i,j+1);     
        }
        memo[i][j]=way;
        return memo[i][j];
        
    }
}

File: WordSearch2.txt
Question Type: Matrix
DSA Question: DSA problem related to: WordSearch2
----------------------
/*
Given a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally 
or vertically neighboring. The same letter cell may not be used more than once in a word.
*/
class Solution {

    public List<String> findWords(char[][] board, String[] words) {
        List<String> ans=new ArrayList<>();
        if(words.length==0) return ans;
        for(String word:words){
            if(exist(board,word)){
                ans.add(word);
            }
        }
        return ans;
    }
    Boolean visited[][];
    private boolean exist(char[][] board, String word) {
        boolean visited[][] =new boolean[board.length][board[0].length];
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]==word.charAt(0)){
                    if(dfs(board,visited,i,j,word,0)){
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    boolean dfs(char[][] board,boolean visited[][],int x,int y,String word,int index){
        if(index==word.length()-1) return true;
        visited[x][y]=true;
        int[] xx={0,0,1,-1};
        int[] yy={1,-1,0,0};
        for(int i=0;i<xx.length;++i){
            if(!isSafe(board,visited,x+xx[i],y+yy[i],word,index+1)) continue;
            if(dfs(board,visited,x+xx[i],y+yy[i],word,index+1)){
                return true;
            }
        }
        visited[x][y]=false;
        return false;
    }
    
    boolean isSafe(char[][] board,boolean visited[][], int x, int y,String word,int index){
        return x>=0 && x<board.length && y>=0 && y<board[0].length && !visited[x][y] && 
            board[x][y]==word.charAt(index);
    }
    
}


class Solution {
    Boolean[][] visited;
    public List<String> findWords(char[][] board, String[] words) {
        List<String> list=new LinkedList<>();
        for(int i=0;i<words.length;++i){
            if(wordSearch(board,words[i].toCharArray())){
                list.add(words[i]);
            }
        }
        return list;
    }
    
    Boolean wordSearch(char[][] board, char[] words){
        visited=new Boolean[board.length][board[0].length];
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(visited[i][j]==null && words[0]==board[i][j]){
                    visited[i][j]=true;
                    if(DFS(board,i,j,words,0)){return true;}
                    visited[i][j]=null;                    
                }
            }
        }
        return false;
    }
    
    Boolean DFS(char[][] board,int i,int j,char[] words,int n){
        int[] x={0,0,-1,1};
        int[] y={1,-1,0,0};
        if(n==words.length-1) return true;
        for(int m=0;m<x.length;++m){
            if(isSafe(board,i+x[m],j+y[m],words,n+1)){
                visited[i+x[m]][j+y[m]]=true;
                if(DFS(board,i+x[m],j+y[m],words,n+1)){return true;}
                visited[i+x[m]][j+y[m]]=null;
            }
        }
        return false;
    }
    
    Boolean isSafe(char[][] board,int i,int j,char[] words,int n){
        return (i>=0 && i<board.length && j>=0 && j<board[0].length && visited[i][j]==null 
                && n<words.length && words[n]==board[i][j]);
    }
    
}

File: RottingOrangeTime.txt
Question Type: Matrix
DSA Question: DSA problem related to: RottingOrangeTime
----------------------
class Solution {
    public int orangesRotting(int[][] grid) {
        Integer[][] time=new Integer[grid.length][grid[0].length];
        boolean[][] visited=new boolean[grid.length][grid[0].length];
        for(int i=0;i<grid.length;++i){
            for(int j=0;j<grid[0].length;++j){
                if(grid[i][j]==2){
                    time[i][j]=0;
                }else if(grid[i][j]==1){
                    time[i][j]=Integer.MAX_VALUE;
                }
            }
        }
        for(int i=0;i<grid.length;++i){
            for(int j=0;j<grid[0].length;++j){
                if(grid[i][j]==2 && visited[i][j]==false){
                    visited[i][j]=true;
                    DFS(i,j,grid,visited,time,0);
                }
            }
        }
        int maxTime=0;
        for(int i=0;i<grid.length;++i){
            for(int j=0;j<grid[0].length;++j){
                if(grid[i][j]==3){
                    if(time[i][j]==null) return -1;
                    maxTime=Math.max(maxTime,time[i][j]);
                }else if(grid[i][j]==1){
                    return -1;
                }
            }
        }
        return maxTime;
    }
    
    boolean isSafe(int i,int j,boolean[][] visited,Integer[][] time,int t,int[][] grid){
        return i>=0 && i<visited.length && j>=0 && j<visited[0].length 
            && (time[i][j]!=null && t<time[i][j]) && visited[i][j]==false && (grid[i][j]==1||grid[i][j]==3);
    }
    void DFS(int i,int j,int[][] grid,boolean[][] visited,Integer[][] time,int t){
        time[i][j]=Math.min(t,time[i][j]);
        int[] x={1,-1,0,0};
        int[] y={0,0,1,-1};
        for(int m=0;m<x.length;++m){
            if(isSafe(i+x[m],j+y[m],visited,time,t+1,grid)){
                grid[i+x[m]][j+y[m]]=3;
                visited[i+x[m]][j+y[m]]= true;
                DFS(i+x[m],j+y[m],grid,visited,time,t+1);
                visited[i+x[m]][j+y[m]]= false;
            }
        }
    }
}

File: RotateMatrix.txt
Question Type: Matrix
DSA Question: DSA problem related to: RotateMatrix
----------------------
class Solution {
  public void rotate(int[][] matrix) {
    int n = matrix.length;

    // transpose matrix
    for (int i = 0; i < n; i++) {
      for (int j = i; j < n; j++) {
        int tmp = matrix[j][i];
        matrix[j][i] = matrix[i][j];
        matrix[i][j] = tmp;
      }
    }
    // reverse each row
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n / 2; j++) {
        int tmp = matrix[i][j];
        matrix[i][j] = matrix[i][n - j - 1];
        matrix[i][n - j - 1] = tmp;
      }
    }
  }
}


File: FindTheJudge.txt
Question Type: Matrix
DSA Question: DSA problem related to: FindTheJudge
----------------------
/*
In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.
*/
class Solution {
    public int findJudge(int N, int[][] trust) {
        if(trust.length==0 && N==1){
            return 1;
        }    
        List<List<Integer>> graph=new LinkedList<>();
        List<Integer> possibleJudges=new LinkedList<>();
        Integer count[] =new Integer[N+1];
        for(int i=0;i<N;++i){
            graph.add(new LinkedList<Integer>());
        }
        
        for(int i=0;i<trust.length;++i){
            count[trust[i][1]]=count[trust[i][1]]==null?1:count[trust[i][1]]+1;
            if(count[trust[i][1]]==N-1){possibleJudges.add(trust[i][1]);}
            graph.get(trust[i][0]-1).add(trust[i][1]);
        }
        for(int i=0;i<possibleJudges.size();++i){
            if(graph.get(possibleJudges.get(i)-1).size()==0) return possibleJudges.get(i); 
        }
        return -1;
    }
}

File: MaxAreaOfIsland.txt
Question Type: Matrix
DSA Question: DSA problem related to: MaxAreaOfIsland
----------------------
/*
Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected
 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)
*/
class Solution {
    Boolean visited[][];
    int maxCount=0;
    int currCount=0;
    public int maxAreaOfIsland(int[][] grid) {
        if(grid.length==0) return 0;
        visited=new Boolean[grid.length][grid[0].length];
        islandHelper(grid);
        return maxCount;
    }
    
    void islandHelper(int[][] arr){
        for(int i=0;i<arr.length;++i){
            for(int j=0;j<arr[0].length;++j){
                currCount=0;
                if(visited[i][j]==null && arr[i][j]==1){
                    DFS(i,j,arr);
                }
                maxCount=Math.max(maxCount,currCount);
            }
        }
    }
    
    void DFS(int i,int j,int[][] arr){
        visited[i][j]=true; ++currCount;
        int [] x={0,0,-1,1};
        int [] y={1,-1,0,0};
        for(int m=0;m<x.length;++m){
            if(isValid(i+x[m],j+y[m],arr)){
                DFS(i+x[m],j+y[m],arr);
            }
        }
    }
    
    Boolean isValid(int i,int j,int[][] arr){
        return (i>=0 && i<arr.length) && (j>=0 && j<arr[0].length) 
            && visited[i][j]==null && arr[i][j]==1;
    }
}

//******************************
class Solution { //revised
    Boolean visited[][]; int maxArea=0,islandSize=0;
    public int maxAreaOfIsland(int[][] matrix) {
        if(matrix.length==0) return 0;
        visited =new Boolean[matrix.length][matrix[0].length];
        for(int i=0;i<matrix.length;++i){
            for(int j=0;j<matrix[0].length;++j){
                islandSize=0;
                if(visited[i][j]==null && matrix[i][j]==1){
                    DFS(matrix,i,j);
                }
                maxArea=Math.max(maxArea,islandSize);
            }
        }
        return maxArea;
    }
    
    private void DFS(int[][] matrix,int i,int j){
        int[] x={0,0,-1,1};
        int[] y={1,-1,0,0};
        ++islandSize;
        visited[i][j]=true;
        for(int m=0;m<x.length;++m){
            if(isSafe(matrix,i+x[m],j+y[m])){
                DFS(matrix,i+x[m],j+y[m]);
            }
        }
    }
    
    Boolean isSafe(int[][] matrix,int i,int j){
        return i<matrix.length && i>=0 && j<matrix[0].length && j>=0 && visited[i][j]==null && matrix[i][j]==1;
    }
}

File: WordSearch.txt
Question Type: Matrix
DSA Question: DSA problem related to: WordSearch
----------------------
/*
Share
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or 
vertically neighboring. The same letter cell may not be used more than once.
*/
class Solution {
    Boolean visited[][];
    public boolean exist(char[][] board, String word) {
        boolean visited[][] =new boolean[board.length][board[0].length];
        for(int i=0;i<board.length;++i){
            for(int j=0;j<board[0].length;++j){
                if(board[i][j]==word.charAt(0)){
                    if(dfs(board,visited,i,j,word,0)){
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    boolean dfs(char[][] board,boolean visited[][],int x,int y,String word,int index){
        if(index==word.length()-1) return true;
        visited[x][y]=true;
        int[] xx={0,0,1,-1};
        int[] yy={1,-1,0,0};
        for(int i=0;i<xx.length;++i){
            if(!isSafe(board,visited,x+xx[i],y+yy[i],word,index+1)) continue;
            if(dfs(board,

